(function (scope) {
    "use strict";
    function F(arity, fun, wrapper) {
        wrapper.a = arity;
        wrapper.f = fun;
        return wrapper;
    }
    function F2(fun) {
        var curried = function (a) {
            return function (b) {
                return fun(a, b);
            };
        };
        curried.a2 = fun;
        return curried;
    }
    function F3(fun) {
        var curried = function (a) {
            return function (b) {
                return function (c) {
                    return fun(a, b, c);
                };
            };
        };
        curried.a3 =
            fun;
        return curried;
    }
    function F4(fun) {
        var curried = function (a) {
            return function (b) {
                return function (c) {
                    return function (d) {
                        return fun(a, b, c, d);
                    };
                };
            };
        };
        curried.a4 = fun;
        return curried;
    }
    function F5(fun) {
        var curried = function (a) {
            return function (b) {
                return function (c) {
                    return function (d) {
                        return function (e) {
                            return fun(a, b, c, d, e);
                        };
                    };
                };
            };
        };
        curried.a5 = fun;
        return curried;
    }
    function F6(fun) {
        var curried = function (a) {
            return function (b) {
                return function (c) {
                    return function (d) {
                        return function (e) {
                            return function (f) {
                                return fun(a, b, c, d, e, f);
                            };
                        };
                    };
                };
            };
        };
        curried.a6 = fun;
        return curried;
    }
    function F7(fun) {
        var curried = function (a) {
            return function (b) {
                return function (c) {
                    return function (d) {
                        return function (e) {
                            return function (f) {
                                return function (g) { return fun(a, b, c, d, e, f, g); };
                            };
                        };
                    };
                };
            };
        };
        curried.
            a7 = fun;
        return curried;
    }
    function F8(fun) {
        var curried = function (a) {
            return function (b) {
                return function (c) {
                    return function (d) {
                        return function (e) {
                            return function (f) {
                                return function (g) {
                                    return function (h) {
                                        return fun(a, b, c, d, e, f, g, h);
                                    };
                                };
                            };
                        };
                    };
                };
            };
        };
        curried.a8 = fun;
        return curried;
    }
    function F9(fun) {
        var curried = function (a) {
            return function (b) {
                return function (c) {
                    return function (d) {
                        return function (e) {
                            return function (f) {
                                return function (g) {
                                    return function (h) {
                                        return function (i) {
                                            return fun(a, b, c, d, e, f, g, h, i);
                                        };
                                    };
                                };
                            };
                        };
                    };
                };
            };
        };
        curried
            .a9 = fun;
        return curried;
    }
    function A2(fun, a, b) {
        return fun.a2 ? fun.a2(a, b) : fun(a)(b);
    }
    function A3(fun, a, b, c) {
        return fun.a3 ? fun.a3(a, b, c) : fun(a)(b)(c);
    }
    function A4(fun, a, b, c, d) {
        return fun.a4 ? fun.a4(a, b, c, d) : fun(a)(b)(c)(d);
    }
    function A5(fun, a, b, c, d, e) {
        return fun.a5 ? fun.a5(a, b, c, d, e)
            : fun(a)(b)(c)(d)(e);
    }
    function A6(fun, a, b, c, d, e, f) {
        return fun.a6 ? fun.a6(a, b, c, d, e, f) : fun(a)(b)(c)(d)(e)(f);
    }
    function A7(fun, a, b, c, d, e, f, g) {
        return fun.a7 ? fun.a7(a, b, c, d, e, f, g) : fun(a)(b)(c)(d)(e)(f)(g);
    }
    function A8(fun, a, b, c, d, e, f, g, h) {
        return fun.a8 ? fun.a8(a, b, c, d, e, f, g, h) : fun(a)(b)(c)(d)(e)(f)(g)(h);
    }
    function A9(fun, a, b, c, d, e, f, g, h, i) {
        return fun.a9 ? fun.a9(a, b, c, d, e, f, g, h, i) : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
    }
    var _List_Nil = { $: 0, a: null, b: null };
    var _List_Nil_UNUSED = { $: "[]" };
    function _List_Cons(hd, tl) { return { $: 1, a: hd, b: tl }; }
    function _List_Cons_UNUSED(hd, tl) { return { $: "::", a: hd, b: tl }; }
    var _List_cons = F2(_List_Cons);
    function _List_fromArray(arr) {
        var out = _List_Nil;
        for (var i = arr.length; i--;) {
            out = _List_Cons(arr[i], out);
        }
        return out;
    }
    function _List_toArray(xs) {
        for (var out = []; xs.b; xs = xs.b) {
            out.push(xs.a);
        }
        return out;
    }
    var _List_map2_fn = function (f, xs, ys) {
        for (var arr = []; xs.b && ys.b; xs = xs.b, ys = ys.b) {
            arr.push(A2(f, xs.a, ys.a));
        }
        return _List_fromArray(arr);
    }, _List_map2_fn_unwrapped = function (f, xs, ys) {
        for (var arr = []; xs.b && ys.b; xs = xs.b, ys = ys.b) {
            arr.push(f(xs.a, ys.a));
        }
        return _List_fromArray(arr);
    }, _List_map2 = F3(_List_map2_fn);
    var _List_map3_fn = function (f, xs, ys, zs) {
        for (var arr = []; xs.b && ys.b && zs.b; xs = xs.b, ys = ys.b, zs = zs.b) {
            arr.push(A3(f, xs.a, ys.a, zs.a));
        }
        return _List_fromArray(arr);
    }, _List_map3_fn_unwrapped = function (f, xs, ys, zs) {
        for (var arr = []; xs.b && ys.b && zs.b; xs = xs.b, ys = ys.b, zs = zs.b) {
            arr.push(f(xs.a, ys.a, zs.a));
        }
        return _List_fromArray(arr);
    }, _List_map3 = F4(_List_map3_fn);
    var _List_map4_fn = function (f, ws, xs, ys, zs) {
        for (var arr = []; ws.b && xs.b && ys.b && zs.b; ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b) {
            arr.push(A4(f, ws.a, xs.a, ys.a, zs.a));
        }
        return _List_fromArray(arr);
    }, _List_map4_fn_unwrapped = function (f, ws, xs, ys, zs) {
        for (var arr = []; ws.b && xs.b && ys.b && zs.b; ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b) {
            arr.push(f(ws.a, xs.a, ys.a, zs.a));
        }
        return _List_fromArray(arr);
    }, _List_map4 = F5(_List_map4_fn);
    var _List_map5_fn = function (f, vs, ws, xs, ys, zs) {
        for (var arr = []; vs.b && ws.b && xs.b && ys.b && zs.b; vs = vs.b, ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b) {
            arr.push(A5(f, vs.a, ws.a, xs.a, ys.a, zs.a));
        }
        return _List_fromArray(arr);
    }, _List_map5_fn_unwrapped = function (f, vs, ws, xs, ys, zs) {
        for (var arr = []; vs.b && ws.b && xs.b && ys.b && zs.b; vs = vs.b, ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b) {
            arr.push(f(vs.a, ws.a, xs.a, ys.a, zs.a));
        }
        return _List_fromArray(arr);
    }, _List_map5 = F6(_List_map5_fn);
    var _List_sortBy_fn = function (f, xs) {
        return _List_fromArray(_List_toArray(xs).sort(function (a, b) {
            return _Utils_cmp(f(a), f(b));
        }));
    }, _List_sortBy = F2(_List_sortBy_fn);
    var _List_sortWith_fn = function (f, xs) {
        return _List_fromArray(_List_toArray(xs).sort(function (a, b) {
            var ord = A2(f, a, b);
            return ord === $elm$core$Basics$EQ ? 0 : ord === $elm$core$Basics$LT ? -1 : 1;
        }));
    }, _List_sortWith_fn_unwrapped = function (f, xs) {
        return _List_fromArray(_List_toArray(xs).sort(function (a, b) {
            var ord = f(a, b);
            return ord === $elm$core$Basics$EQ ? 0 : ord === $elm$core$Basics$LT ? -1 : 1;
        }));
    }, _List_sortWith = F2(_List_sortWith_fn);
    var _JsArray_empty = [];
    function _JsArray_singleton(value) {
        return [value];
    }
    function _JsArray_length(array) {
        return array.length;
    }
    var _JsArray_initialize_fn = function (size, offset, func) {
        var result = new Array(size);
        for (var i = 0; i < size; i++) {
            result[i] = func(offset + i);
        }
        return result;
    }, _JsArray_initialize = F3(_JsArray_initialize_fn);
    var _JsArray_initializeFromList_fn = function (max, ls) {
        var result = new Array(max);
        for (var i = 0; i < max && ls.b; i++) {
            result[i] = ls.a;
            ls = ls.b;
        }
        result.length = i;
        return _Utils_Tuple2(result, ls);
    }, _JsArray_initializeFromList = F2(_JsArray_initializeFromList_fn);
    var _JsArray_unsafeGet_fn = function (index, array) {
        return array[index];
    }, _JsArray_unsafeGet = F2(_JsArray_unsafeGet_fn);
    var _JsArray_unsafeSet_fn = function (index, value, array) {
        var length = array.length;
        var result = new Array(length);
        for (var i = 0; i < length; i++) {
            result[i] = array[i];
        }
        result[index] = value;
        return result;
    }, _JsArray_unsafeSet = F3(_JsArray_unsafeSet_fn);
    var _JsArray_push_fn = function (value, array) {
        var length = array.length;
        var result = new Array(length + 1);
        for (var i = 0; i < length; i++) {
            result[i] = array[i];
        }
        result[length] = value;
        return result;
    }, _JsArray_push = F2(_JsArray_push_fn);
    var _JsArray_foldl_fn = function (func, acc, array) {
        var length = array.length;
        for (var i = 0; i < length; i++) {
            acc = A2(func, array[i], acc);
        }
        return acc;
    }, _JsArray_foldl_fn_unwrapped = function (func, acc, array) {
        var length = array.length;
        for (var i = 0; i < length; i++) {
            acc = func(array[i], acc);
        }
        return acc;
    }, _JsArray_foldl = F3(_JsArray_foldl_fn);
    var _JsArray_foldr_fn = function (func, acc, array) {
        for (var i = array.length - 1; i >= 0; i--) {
            acc = A2(func, array[i], acc);
        }
        return acc;
    }, _JsArray_foldr_fn_unwrapped = function (func, acc, array) {
        for (var i = array.length - 1; i >= 0; i--) {
            acc = func(array[i], acc);
        }
        return acc;
    }, _JsArray_foldr = F3(_JsArray_foldr_fn);
    var _JsArray_map_fn = function (func, array) {
        var length = array.length;
        var result = new Array(length);
        for (var i = 0; i < length; i++) {
            result[i] = func(array[i]);
        }
        return result;
    }, _JsArray_map = F2(_JsArray_map_fn);
    var _JsArray_indexedMap_fn = function (func, offset, array) {
        var length = array.length;
        var result = new Array(length);
        for (var i = 0; i < length; i++) {
            result[i] = A2(func, offset + i, array[i]);
        }
        return result;
    }, _JsArray_indexedMap_fn_unwrapped = function (func, offset, array) {
        var length = array.length;
        var result = new Array(length);
        for (var i = 0; i < length; i++) {
            result[i] = func(offset + i, array[i]);
        }
        return result;
    }, _JsArray_indexedMap = F3(_JsArray_indexedMap_fn);
    var _JsArray_slice_fn = function (from, to, array) {
        return array.slice(from, to);
    }, _JsArray_slice = F3(_JsArray_slice_fn);
    var _JsArray_appendN_fn = function (n, dest, source) {
        var destLen = dest.length;
        var itemsToCopy = n - destLen;
        if (itemsToCopy > source.length) {
            itemsToCopy = source.length;
        }
        var size = destLen + itemsToCopy;
        var result = new Array(size);
        for (var i = 0; i < destLen; i++) {
            result[i] = dest[i];
        }
        for (var i = 0; i < itemsToCopy; i++) {
            result[i + destLen] = source[i];
        }
        return result;
    }, _JsArray_appendN = F3(_JsArray_appendN_fn);
    var _Debug_log_fn = function (tag, value) {
        return value;
    }, _Debug_log = F2(_Debug_log_fn);
    var _Debug_log_UNUSED_fn = function (tag, value) {
        console.log(tag + ": " + _Debug_toString(value));
        return value;
    }, _Debug_log_UNUSED = F2(_Debug_log_UNUSED_fn);
    function _Debug_todo(moduleName, region) {
        return function (message) {
            _Debug_crash(8, moduleName, region, message);
        };
    }
    function _Debug_todoCase(moduleName, region, value) {
        return function (message) {
            _Debug_crash(9, moduleName, region, value, message);
        };
    }
    function _Debug_toString(value) {
        return "<internals>";
    }
    function _Debug_toString_UNUSED(value) {
        return _Debug_toAnsiString(false, value);
    }
    function _Debug_toAnsiString(ansi, value) {
        if (typeof value === "function") {
            return _Debug_internalColor(ansi, "<function>");
        }
        if (typeof value === "boolean") {
            return _Debug_ctorColor(ansi, value ? "True" : "False");
        }
        if (typeof value === "number") {
            return _Debug_numberColor(ansi, value + "");
        }
        if (value instanceof String) {
            return _Debug_charColor(ansi, "'" + _Debug_addSlashes(value, true) + "'");
        }
        if (typeof value === "string") {
            return _Debug_stringColor(ansi, "\"" + _Debug_addSlashes(value, false) + "\"");
        }
        if (typeof value === "object" && "$" in value) {
            var tag = value.$;
            if (typeof tag === "number") {
                return _Debug_internalColor(ansi, "<internals>");
            }
            if (tag[0] === "#") {
                var output = [];
                for (var k in value) {
                    if (k === "$")
                        continue;
                    output.push(_Debug_toAnsiString(ansi, value[k]));
                }
                return "(" + output.join(",") + ")";
            }
            if (tag === "Set_elm_builtin") {
                return _Debug_ctorColor(ansi, "Set")
                    + _Debug_fadeColor(ansi, ".fromList") + " "
                    + _Debug_toAnsiString(ansi, $elm$core$Set$toList(value));
            }
            if (tag === "RBNode_elm_builtin" || tag === "RBEmpty_elm_builtin") {
                return _Debug_ctorColor(ansi, "Dict")
                    + _Debug_fadeColor(ansi, ".fromList") + " "
                    + _Debug_toAnsiString(ansi, $elm$core$Dict$toList(value));
            }
            if (tag === "Array_elm_builtin") {
                return _Debug_ctorColor(ansi, "Array")
                    + _Debug_fadeColor(ansi, ".fromList") + " "
                    + _Debug_toAnsiString(ansi, $elm$core$Array$toList(value));
            }
            if (tag === "::" || tag === "[]") {
                var output = "[";
                value.b && (output += _Debug_toAnsiString(ansi, value.a), value = value.b);
                for (; value.b; value = value.b) {
                    output += "," + _Debug_toAnsiString(ansi, value.a);
                }
                return output + "]";
            }
            var output = "";
            for (var i in value) {
                if (i === "$")
                    continue;
                var str = _Debug_toAnsiString(ansi, value[i]);
                var c0 = str[0];
                var parenless = c0 === "{" || c0 === "(" || c0 === "[" || c0 === "<" || c0 === "\"" || str.indexOf(" ") < 0;
                output += " " + (parenless ? str : "(" + str + ")");
            }
            return _Debug_ctorColor(ansi, tag) + output;
        }
        if (typeof DataView === "function" && value instanceof DataView) {
            return _Debug_stringColor(ansi, "<" + value.byteLength + " bytes>");
        }
        if (typeof File !== "undefined" && value instanceof File) {
            return _Debug_internalColor(ansi, "<" + value.name + ">");
        }
        if (typeof value === "object") {
            var output = [];
            for (var key in value) {
                var field = key[0] === "_" ? key.slice(1) : key;
                output.push(_Debug_fadeColor(ansi, field) + " = " + _Debug_toAnsiString(ansi, value[key]));
            }
            if (output.length === 0) {
                return "{}";
            }
            return "{ " + output.join(", ") + " }";
        }
        return _Debug_internalColor(ansi, "<internals>");
    }
    function _Debug_addSlashes(str, isChar) {
        var s = str
            .replace(/\\/g, "\\\\")
            .replace(/\n/g, "\\n")
            .replace(/\t/g, "\\t")
            .replace(/\r/g, "\\r")
            .replace(/\v/g, "\\v")
            .replace(/\0/g, "\\0");
        if (isChar) {
            return s.replace(/\'/g, "\\'");
        }
        else {
            return s.replace(/\"/g, "\\\"");
        }
    }
    function _Debug_ctorColor(ansi, string) {
        return ansi ? "\u001B[96m" + string + "\u001B[0m" : string;
    }
    function _Debug_numberColor(ansi, string) {
        return ansi ? "\u001B[95m" + string + "\u001B[0m" : string;
    }
    function _Debug_stringColor(ansi, string) {
        return ansi ? "\u001B[93m" + string + "\u001B[0m" : string;
    }
    function _Debug_charColor(ansi, string) {
        return ansi ? "\u001B[92m" + string + "\u001B[0m" : string;
    }
    function _Debug_fadeColor(ansi, string) {
        return ansi ? "\u001B[37m" + string + "\u001B[0m" : string;
    }
    function _Debug_internalColor(ansi, string) {
        return ansi ? "\u001B[36m" + string + "\u001B[0m" : string;
    }
    function _Debug_toHexDigit(n) {
        return String.fromCharCode(n < 10 ? 48 + n : 55 + n);
    }
    function _Debug_crash(identifier) {
        throw new Error("https://github.com/elm/core/blob/1.0.0/hints/" + identifier + ".md");
    }
    function _Debug_crash_UNUSED(identifier, fact1, fact2, fact3, fact4) {
        switch (identifier) {
            case 0:
                throw new Error("What node should I take over? In JavaScript I need something like:\n\n    Elm.Main.init({\n        node: document.getElementById(\"elm-node\")\n    })\n\nYou need to do this with any Browser.sandbox or Browser.element program.");
            case 1:
                throw new Error("Browser.application programs cannot handle URLs like this:\n\n    " + document.location.href + "\n\nWhat is the root? The root of your file system? Try looking at this program with `elm reactor` or some other server.");
            case 2:
                var jsonErrorString = fact1;
                throw new Error("Problem with the flags given to your Elm program on initialization.\n\n" + jsonErrorString);
            case 3:
                var portName = fact1;
                throw new Error("There can only be one port named `" + portName + "`, but your program has multiple.");
            case 4:
                var portName = fact1;
                var problem = fact2;
                throw new Error("Trying to send an unexpected type of value through port `" + portName + "`:\n" + problem);
            case 5:
                throw new Error("Trying to use `(==)` on functions.\nThere is no way to know if functions are \"the same\" in the Elm sense.\nRead more about this at https://package.elm-lang.org/packages/elm/core/latest/Basics#== which describes why it is this way and what the better version will look like.");
            case 6:
                var moduleName = fact1;
                throw new Error("Your page is loading multiple Elm scripts with a module named " + moduleName + ". Maybe a duplicate script is getting loaded accidentally? If not, rename one of them so I know which is which!");
            case 8:
                var moduleName = fact1;
                var region = fact2;
                var message = fact3;
                throw new Error("TODO in module `" + moduleName + "` " + _Debug_regionToString(region) + "\n\n" + message);
            case 9:
                var moduleName = fact1;
                var region = fact2;
                var value = fact3;
                var message = fact4;
                throw new Error("TODO in module `" + moduleName + "` from the `case` expression "
                    + _Debug_regionToString(region) + "\n\nIt received the following value:\n\n    "
                    + _Debug_toString(value).replace("\n", "\n    ")
                    + "\n\nBut the branch that handles it says:\n\n    " + message.replace("\n", "\n    "));
            case 10:
                throw new Error("Bug in https://github.com/elm/virtual-dom/issues");
            case 11:
                throw new Error("Cannot perform mod 0. Division by zero error.");
        }
    }
    function _Debug_regionToString(region) {
        if (region.bE.a5 === region.cm.a5) {
            return "on line " + region.bE.a5;
        }
        return "on lines " + region.bE.a5 + " through " + region.cm.a5;
    }
    function _Utils_eq(x, y) {
        for (var pair, stack = [], isEqual = _Utils_eqHelp(x, y, 0, stack); isEqual && (pair = stack.pop()); isEqual = _Utils_eqHelp(pair.a, pair.b, 0, stack)) { }
        return isEqual;
    }
    function _Utils_eqHelp(x, y, depth, stack) {
        if (x === y) {
            return true;
        }
        if (typeof x !== "object" || x === null || y === null) {
            typeof x === "function" && _Debug_crash(5);
            return false;
        }
        if (depth > 100) {
            stack.push(_Utils_Tuple2(x, y));
            return true;
        }
        if (x.$ < 0) {
            x = $elm$core$Dict$toList(x);
            y = $elm$core$Dict$toList(y);
        }
        for (var key in x) {
            if (!_Utils_eqHelp(x[key], y[key], depth + 1, stack)) {
                return false;
            }
        }
        return true;
    }
    var _Utils_equal = F2(_Utils_eq);
    var _Utils_notEqual_fn = function (a, b) { return !_Utils_eq(a, b); }, _Utils_notEqual = F2(_Utils_notEqual_fn);
    function _Utils_cmp(x, y, ord) {
        if (typeof x !== "object") {
            return x === y ? 0 : x < y ? -1 : 1;
        }
        if (typeof x.$ === "undefined") {
            return (ord = _Utils_cmp(x.a, y.a))
                ? ord
                : (ord = _Utils_cmp(x.b, y.b))
                    ? ord
                    : _Utils_cmp(x.c, y.c);
        }
        for (; x.b && y.b && !(ord = _Utils_cmp(x.a, y.a)); x = x.b, y = y.b) { }
        return ord || (x.b ? 1 : y.b ? -1 : 0);
    }
    var _Utils_lt_fn = function (a, b) { return _Utils_cmp(a, b) < 0; }, _Utils_lt = F2(_Utils_lt_fn);
    var _Utils_le_fn = function (a, b) { return _Utils_cmp(a, b) < 1; }, _Utils_le = F2(_Utils_le_fn);
    var _Utils_gt_fn = function (a, b) { return _Utils_cmp(a, b) > 0; }, _Utils_gt = F2(_Utils_gt_fn);
    var _Utils_ge_fn = function (a, b) { return _Utils_cmp(a, b) >= 0; }, _Utils_ge = F2(_Utils_ge_fn);
    var _Utils_compare_fn = function (x, y) {
        var n = _Utils_cmp(x, y);
        return n < 0 ? $elm$core$Basics$LT : n ? $elm$core$Basics$GT : $elm$core$Basics$EQ;
    }, _Utils_compare = F2(_Utils_compare_fn);
    var _Utils_Tuple0 = 0;
    var _Utils_Tuple0_UNUSED = { $: "#0" };
    function _Utils_Tuple2(a, b) { return { a: a, b: b }; }
    function _Utils_Tuple2_UNUSED(a, b) { return { $: "#2", a: a, b: b }; }
    function _Utils_Tuple3(a, b, c) { return { a: a, b: b, c: c }; }
    function _Utils_Tuple3_UNUSED(a, b, c) { return { $: "#3", a: a, b: b, c: c }; }
    function _Utils_chr(c) { return c; }
    function _Utils_chr_UNUSED(c) { return new String(c); }
    function _Utils_update(oldRecord, updatedFields) {
        var newRecord = {};
        for (var key in oldRecord) {
            newRecord[key] = oldRecord[key];
        }
        for (var key in updatedFields) {
            newRecord[key] = updatedFields[key];
        }
        return newRecord;
    }
    var _Utils_append = F2(_Utils_ap);
    function _Utils_ap(xs, ys) {
        if (typeof xs === "string") {
            return xs + ys;
        }
        if (!xs.b) {
            return ys;
        }
        var root = _List_Cons(xs.a, ys);
        xs = xs.b;
        for (var curr = root; xs.b; xs = xs.b) {
            curr = curr.b = _List_Cons(xs.a, ys);
        }
        return root;
    }
    var _Basics_add_fn = function (a, b) { return a + b; }, _Basics_add = F2(_Basics_add_fn);
    var _Basics_sub_fn = function (a, b) { return a - b; }, _Basics_sub = F2(_Basics_sub_fn);
    var _Basics_mul_fn = function (a, b) { return a * b; }, _Basics_mul = F2(_Basics_mul_fn);
    var _Basics_fdiv_fn = function (a, b) { return a / b; }, _Basics_fdiv = F2(_Basics_fdiv_fn);
    var _Basics_idiv_fn = function (a, b) { return (a / b) | 0; }, _Basics_idiv = F2(_Basics_idiv_fn);
    var _Basics_pow_fn = Math.pow, _Basics_pow = F2(_Basics_pow_fn);
    var _Basics_remainderBy_fn = function (b, a) { return a % b; }, _Basics_remainderBy = F2(_Basics_remainderBy_fn);
    var _Basics_modBy_fn = function (modulus, x) {
        var answer = x % modulus;
        return modulus === 0
            ? _Debug_crash(11)
            :
                ((answer > 0 && modulus < 0) || (answer < 0 && modulus > 0))
                    ? answer + modulus
                    : answer;
    }, _Basics_modBy = F2(_Basics_modBy_fn);
    var _Basics_pi = Math.PI;
    var _Basics_e = Math.E;
    var _Basics_cos = Math.cos;
    var _Basics_sin = Math.sin;
    var _Basics_tan = Math.tan;
    var _Basics_acos = Math.acos;
    var _Basics_asin = Math.asin;
    var _Basics_atan = Math.atan;
    var _Basics_atan2_fn = Math.atan2, _Basics_atan2 = F2(_Basics_atan2_fn);
    function _Basics_toFloat(x) { return x; }
    function _Basics_truncate(n) { return n | 0; }
    function _Basics_isInfinite(n) { return n === Infinity || n === -Infinity; }
    var _Basics_ceiling = Math.ceil;
    var _Basics_floor = Math.floor;
    var _Basics_round = Math.round;
    var _Basics_sqrt = Math.sqrt;
    var _Basics_log = Math.log;
    var _Basics_isNaN = isNaN;
    function _Basics_not(bool) { return !bool; }
    var _Basics_and_fn = function (a, b) { return a && b; }, _Basics_and = F2(_Basics_and_fn);
    var _Basics_or_fn = function (a, b) { return a || b; }, _Basics_or = F2(_Basics_or_fn);
    var _Basics_xor_fn = function (a, b) { return a !== b; }, _Basics_xor = F2(_Basics_xor_fn);
    var _String_cons_fn = function (chr, str) {
        return chr + str;
    }, _String_cons = F2(_String_cons_fn);
    function _String_uncons(string) {
        var word = string.charCodeAt(0);
        return !isNaN(word)
            ? $elm$core$Maybe$Just(55296 <= word && word <= 56319
                ? _Utils_Tuple2(_Utils_chr(string[0] + string[1]), string.slice(2))
                : _Utils_Tuple2(_Utils_chr(string[0]), string.slice(1)))
            : $elm$core$Maybe$Nothing;
    }
    var _String_append_fn = function (a, b) {
        return a + b;
    }, _String_append = F2(_String_append_fn);
    function _String_length(str) {
        return str.length;
    }
    var _String_map_fn = function (func, string) {
        var len = string.length;
        var array = new Array(len);
        var i = 0;
        while (i < len) {
            var word = string.charCodeAt(i);
            if (55296 <= word && word <= 56319) {
                array[i] = func(_Utils_chr(string[i] + string[i + 1]));
                i += 2;
                continue;
            }
            array[i] = func(_Utils_chr(string[i]));
            i++;
        }
        return array.join("");
    }, _String_map = F2(_String_map_fn);
    var _String_filter_fn = function (isGood, str) {
        var arr = [];
        var len = str.length;
        var i = 0;
        while (i < len) {
            var char = str[i];
            var word = str.charCodeAt(i);
            i++;
            if (55296 <= word && word <= 56319) {
                char += str[i];
                i++;
            }
            if (isGood(_Utils_chr(char))) {
                arr.push(char);
            }
        }
        return arr.join("");
    }, _String_filter = F2(_String_filter_fn);
    function _String_reverse(str) {
        var len = str.length;
        var arr = new Array(len);
        var i = 0;
        while (i < len) {
            var word = str.charCodeAt(i);
            if (55296 <= word && word <= 56319) {
                arr[len - i] = str[i + 1];
                i++;
                arr[len - i] = str[i - 1];
                i++;
            }
            else {
                arr[len - i] = str[i];
                i++;
            }
        }
        return arr.join("");
    }
    var _String_foldl_fn = function (func, state, string) {
        var len = string.length;
        var i = 0;
        while (i < len) {
            var char = string[i];
            var word = string.charCodeAt(i);
            i++;
            if (55296 <= word && word <= 56319) {
                char += string[i];
                i++;
            }
            state = A2(func, _Utils_chr(char), state);
        }
        return state;
    }, _String_foldl_fn_unwrapped = function (func, state, string) {
        var len = string.length;
        var i = 0;
        while (i < len) {
            var char = string[i];
            var word = string.charCodeAt(i);
            i++;
            if (55296 <= word && word <= 56319) {
                char += string[i];
                i++;
            }
            state = func(_Utils_chr(char), state);
        }
        return state;
    }, _String_foldl = F3(_String_foldl_fn);
    var _String_foldr_fn = function (func, state, string) {
        var i = string.length;
        while (i--) {
            var char = string[i];
            var word = string.charCodeAt(i);
            if (56320 <= word && word <= 57343) {
                i--;
                char = string[i] + char;
            }
            state = A2(func, _Utils_chr(char), state);
        }
        return state;
    }, _String_foldr_fn_unwrapped = function (func, state, string) {
        var i = string.length;
        while (i--) {
            var char = string[i];
            var word = string.charCodeAt(i);
            if (56320 <= word && word <= 57343) {
                i--;
                char = string[i] + char;
            }
            state = func(_Utils_chr(char), state);
        }
        return state;
    }, _String_foldr = F3(_String_foldr_fn);
    var _String_split_fn = function (sep, str) {
        return str.split(sep);
    }, _String_split = F2(_String_split_fn);
    var _String_join_fn = function (sep, strs) {
        return strs.join(sep);
    }, _String_join = F2(_String_join_fn);
    var _String_slice_fn = function (start, end, str) {
        return str.slice(start, end);
    }, _String_slice = F3(_String_slice_fn);
    function _String_trim(str) {
        return str.trim();
    }
    function _String_trimLeft(str) {
        return str.replace(/^\s+/, "");
    }
    function _String_trimRight(str) {
        return str.replace(/\s+$/, "");
    }
    function _String_words(str) {
        return _List_fromArray(str.trim().split(/\s+/g));
    }
    function _String_lines(str) {
        return _List_fromArray(str.split(/\r\n|\r|\n/g));
    }
    function _String_toUpper(str) {
        return str.toUpperCase();
    }
    function _String_toLower(str) {
        return str.toLowerCase();
    }
    var _String_any_fn = function (isGood, string) {
        var i = string.length;
        while (i--) {
            var char = string[i];
            var word = string.charCodeAt(i);
            if (56320 <= word && word <= 57343) {
                i--;
                char = string[i] + char;
            }
            if (isGood(_Utils_chr(char))) {
                return true;
            }
        }
        return false;
    }, _String_any = F2(_String_any_fn);
    var _String_all_fn = function (isGood, string) {
        var i = string.length;
        while (i--) {
            var char = string[i];
            var word = string.charCodeAt(i);
            if (56320 <= word && word <= 57343) {
                i--;
                char = string[i] + char;
            }
            if (!isGood(_Utils_chr(char))) {
                return false;
            }
        }
        return true;
    }, _String_all = F2(_String_all_fn);
    var _String_contains_fn = function (sub, str) {
        return str.indexOf(sub) > -1;
    }, _String_contains = F2(_String_contains_fn);
    var _String_startsWith_fn = function (sub, str) {
        return str.indexOf(sub) === 0;
    }, _String_startsWith = F2(_String_startsWith_fn);
    var _String_endsWith_fn = function (sub, str) {
        return str.length >= sub.length &&
            str.lastIndexOf(sub) === str.length - sub.length;
    }, _String_endsWith = F2(_String_endsWith_fn);
    var _String_indexes_fn = function (sub, str) {
        var subLen = sub.length;
        if (subLen < 1) {
            return _List_Nil;
        }
        var i = 0;
        var is = [];
        while ((i = str.indexOf(sub, i)) > -1) {
            is.push(i);
            i = i + subLen;
        }
        return _List_fromArray(is);
    }, _String_indexes = F2(_String_indexes_fn);
    function _String_fromNumber(number) {
        return number + "";
    }
    function _String_toInt(str) {
        var total = 0;
        var code0 = str.charCodeAt(0);
        var start = code0 == 43 || code0 == 45 ? 1 : 0;
        for (var i = start; i < str.length; ++i) {
            var code = str.charCodeAt(i);
            if (code < 48 || 57 < code) {
                return $elm$core$Maybe$Nothing;
            }
            total = 10 * total + code - 48;
        }
        return i == start
            ? $elm$core$Maybe$Nothing
            : $elm$core$Maybe$Just(code0 == 45 ? -total : total);
    }
    function _String_toFloat(s) {
        if (s.length === 0 || /[\sxbo]/.test(s)) {
            return $elm$core$Maybe$Nothing;
        }
        var n = +s;
        return n === n ? $elm$core$Maybe$Just(n) : $elm$core$Maybe$Nothing;
    }
    function _String_fromList(chars) {
        return _List_toArray(chars).join("");
    }
    function _Char_toCode(char) {
        var code = char.charCodeAt(0);
        if (55296 <= code && code <= 56319) {
            return (code - 55296) * 1024 + char.charCodeAt(1) - 56320 + 65536;
        }
        return code;
    }
    function _Char_fromCode(code) {
        return _Utils_chr((code < 0 || 1114111 < code)
            ? "\uFFFD"
            :
                (code <= 65535)
                    ? String.fromCharCode(code)
                    :
                        (code -= 65536,
                            String.fromCharCode(Math.floor(code / 1024) + 55296, code % 1024 + 56320)));
    }
    function _Char_toUpper(char) {
        return _Utils_chr(char.toUpperCase());
    }
    function _Char_toLower(char) {
        return _Utils_chr(char.toLowerCase());
    }
    function _Char_toLocaleUpper(char) {
        return _Utils_chr(char.toLocaleUpperCase());
    }
    function _Char_toLocaleLower(char) {
        return _Utils_chr(char.toLocaleLowerCase());
    }
    function _Json_succeed(msg) {
        return {
            $: 0,
            a: msg
        };
    }
    function _Json_fail(msg) {
        return {
            $: 1,
            a: msg
        };
    }
    function _Json_decodePrim(decoder) {
        return { $: 2, b: decoder };
    }
    var _Json_decodeInt = _Json_decodePrim(function (value) {
        return (typeof value !== "number")
            ? _Json_expecting("an INT", value)
            :
                (-2147483647 < value && value < 2147483647 && (value | 0) === value)
                    ? $elm$core$Result$Ok(value)
                    :
                        (isFinite(value) && !(value % 1))
                            ? $elm$core$Result$Ok(value)
                            : _Json_expecting("an INT", value);
    });
    var _Json_decodeBool = _Json_decodePrim(function (value) {
        return (typeof value === "boolean")
            ? $elm$core$Result$Ok(value)
            : _Json_expecting("a BOOL", value);
    });
    var _Json_decodeFloat = _Json_decodePrim(function (value) {
        return (typeof value === "number")
            ? $elm$core$Result$Ok(value)
            : _Json_expecting("a FLOAT", value);
    });
    var _Json_decodeValue = _Json_decodePrim(function (value) {
        return $elm$core$Result$Ok(_Json_wrap(value));
    });
    var _Json_decodeString = _Json_decodePrim(function (value) {
        return (typeof value === "string")
            ? $elm$core$Result$Ok(value)
            : (value instanceof String)
                ? $elm$core$Result$Ok(value + "")
                : _Json_expecting("a STRING", value);
    });
    function _Json_decodeList(decoder) { return { $: 3, b: decoder }; }
    function _Json_decodeArray(decoder) { return { $: 4, b: decoder }; }
    function _Json_decodeNull(value) { return { $: 5, c: value }; }
    var _Json_decodeField_fn = function (field, decoder) {
        return {
            $: 6,
            d: field,
            b: decoder
        };
    }, _Json_decodeField = F2(_Json_decodeField_fn);
    var _Json_decodeIndex_fn = function (index, decoder) {
        return {
            $: 7,
            e: index,
            b: decoder
        };
    }, _Json_decodeIndex = F2(_Json_decodeIndex_fn);
    function _Json_decodeKeyValuePairs(decoder) {
        return {
            $: 8,
            b: decoder
        };
    }
    function _Json_mapMany(f, decoders) {
        return {
            $: 9,
            f: f,
            g: decoders
        };
    }
    var _Json_andThen_fn = function (callback, decoder) {
        return {
            $: 10,
            b: decoder,
            h: callback
        };
    }, _Json_andThen = F2(_Json_andThen_fn);
    function _Json_oneOf(decoders) {
        return {
            $: 11,
            g: decoders
        };
    }
    var _Json_map1_fn = function (f, d1) {
        return _Json_mapMany(f, [d1]);
    }, _Json_map1 = F2(_Json_map1_fn);
    var _Json_map2_fn = function (f, d1, d2) {
        return _Json_mapMany(f, [d1, d2]);
    }, _Json_map2 = F3(_Json_map2_fn);
    var _Json_map3_fn = function (f, d1, d2, d3) {
        return _Json_mapMany(f, [d1, d2, d3]);
    }, _Json_map3 = F4(_Json_map3_fn);
    var _Json_map4_fn = function (f, d1, d2, d3, d4) {
        return _Json_mapMany(f, [d1, d2, d3, d4]);
    }, _Json_map4 = F5(_Json_map4_fn);
    var _Json_map5_fn = function (f, d1, d2, d3, d4, d5) {
        return _Json_mapMany(f, [d1, d2, d3, d4, d5]);
    }, _Json_map5 = F6(_Json_map5_fn);
    var _Json_map6_fn = function (f, d1, d2, d3, d4, d5, d6) {
        return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6]);
    }, _Json_map6 = F7(_Json_map6_fn);
    var _Json_map7_fn = function (f, d1, d2, d3, d4, d5, d6, d7) {
        return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7]);
    }, _Json_map7 = F8(_Json_map7_fn);
    var _Json_map8_fn = function (f, d1, d2, d3, d4, d5, d6, d7, d8) {
        return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7, d8]);
    }, _Json_map8 = F9(_Json_map8_fn);
    var _Json_runOnString_fn = function (decoder, string) {
        try {
            var value = JSON.parse(string);
            return _Json_runHelp(decoder, value);
        }
        catch (e) {
            return $elm$core$Result$Err($elm$json$Json$Decode$Failure_fn("This is not valid JSON! " + e.message, _Json_wrap(string)));
        }
    }, _Json_runOnString = F2(_Json_runOnString_fn);
    var _Json_run_fn = function (decoder, value) {
        return _Json_runHelp(decoder, _Json_unwrap(value));
    }, _Json_run = F2(_Json_run_fn);
    function _Json_runHelp(decoder, value) {
        switch (decoder.$) {
            case 2:
                return decoder.b(value);
            case 5:
                return (value === null)
                    ? $elm$core$Result$Ok(decoder.c)
                    : _Json_expecting("null", value);
            case 3:
                if (!_Json_isArray(value)) {
                    return _Json_expecting("a LIST", value);
                }
                return _Json_runArrayDecoder(decoder.b, value, _List_fromArray);
            case 4:
                if (!_Json_isArray(value)) {
                    return _Json_expecting("an ARRAY", value);
                }
                return _Json_runArrayDecoder(decoder.b, value, _Json_toElmArray);
            case 6:
                var field = decoder.d;
                if (typeof value !== "object" || value === null || !(field in value)) {
                    return _Json_expecting("an OBJECT with a field named `" + field + "`", value);
                }
                var result = _Json_runHelp(decoder.b, value[field]);
                return ($elm$core$Result$isOk(result)) ? result : $elm$core$Result$Err($elm$json$Json$Decode$Field_fn(field, result.a));
            case 7:
                var index = decoder.e;
                if (!_Json_isArray(value)) {
                    return _Json_expecting("an ARRAY", value);
                }
                if (index >= value.length) {
                    return _Json_expecting("a LONGER array. Need index " + index + " but only see " + value.length + " entries", value);
                }
                var result = _Json_runHelp(decoder.b, value[index]);
                return ($elm$core$Result$isOk(result)) ? result : $elm$core$Result$Err($elm$json$Json$Decode$Index_fn(index, result.a));
            case 8:
                if (typeof value !== "object" || value === null || _Json_isArray(value)) {
                    return _Json_expecting("an OBJECT", value);
                }
                var keyValuePairs = _List_Nil;
                for (var key in value) {
                    if (value.hasOwnProperty(key)) {
                        var result = _Json_runHelp(decoder.b, value[key]);
                        if (!$elm$core$Result$isOk(result)) {
                            return $elm$core$Result$Err($elm$json$Json$Decode$Field_fn(key, result.a));
                        }
                        keyValuePairs = _List_Cons(_Utils_Tuple2(key, result.a), keyValuePairs);
                    }
                }
                return $elm$core$Result$Ok($elm$core$List$reverse(keyValuePairs));
            case 9:
                var answer = decoder.f;
                var decoders = decoder.g;
                for (var i = 0; i < decoders.length; i++) {
                    var result = _Json_runHelp(decoders[i], value);
                    if (!$elm$core$Result$isOk(result)) {
                        return result;
                    }
                    answer = answer(result.a);
                }
                return $elm$core$Result$Ok(answer);
            case 10:
                var result = _Json_runHelp(decoder.b, value);
                return (!$elm$core$Result$isOk(result))
                    ? result
                    : _Json_runHelp(decoder.h(result.a), value);
            case 11:
                var errors = _List_Nil;
                for (var temp = decoder.g; temp.b; temp = temp.b) {
                    var result = _Json_runHelp(temp.a, value);
                    if ($elm$core$Result$isOk(result)) {
                        return result;
                    }
                    errors = _List_Cons(result.a, errors);
                }
                return $elm$core$Result$Err($elm$json$Json$Decode$OneOf($elm$core$List$reverse(errors)));
            case 1:
                return $elm$core$Result$Err($elm$json$Json$Decode$Failure_fn(decoder.a, _Json_wrap(value)));
            case 0:
                return $elm$core$Result$Ok(decoder.a);
        }
    }
    function _Json_runArrayDecoder(decoder, value, toElmValue) {
        var len = value.length;
        var array = new Array(len);
        for (var i = 0; i < len; i++) {
            var result = _Json_runHelp(decoder, value[i]);
            if (!$elm$core$Result$isOk(result)) {
                return $elm$core$Result$Err($elm$json$Json$Decode$Index_fn(i, result.a));
            }
            array[i] = result.a;
        }
        return $elm$core$Result$Ok(toElmValue(array));
    }
    function _Json_isArray(value) {
        return Array.isArray(value) || (typeof FileList !== "undefined" && value instanceof FileList);
    }
    function _Json_toElmArray(array) {
        return $elm$core$Array$initialize_fn(array.length, function (i) { return array[i]; });
    }
    function _Json_expecting(type, value) {
        return $elm$core$Result$Err($elm$json$Json$Decode$Failure_fn("Expecting " + type, _Json_wrap(value)));
    }
    function _Json_equality(x, y) {
        if (x === y) {
            return true;
        }
        if (x.$ !== y.$) {
            return false;
        }
        switch (x.$) {
            case 0:
            case 1:
                return x.a === y.a;
            case 2:
                return x.b === y.b;
            case 5:
                return x.c === y.c;
            case 3:
            case 4:
            case 8:
                return _Json_equality(x.b, y.b);
            case 6:
                return x.d === y.d && _Json_equality(x.b, y.b);
            case 7:
                return x.e === y.e && _Json_equality(x.b, y.b);
            case 9:
                return x.f === y.f && _Json_listEquality(x.g, y.g);
            case 10:
                return x.h === y.h && _Json_equality(x.b, y.b);
            case 11:
                return _Json_listEquality(x.g, y.g);
        }
    }
    function _Json_listEquality(aDecoders, bDecoders) {
        var len = aDecoders.length;
        if (len !== bDecoders.length) {
            return false;
        }
        for (var i = 0; i < len; i++) {
            if (!_Json_equality(aDecoders[i], bDecoders[i])) {
                return false;
            }
        }
        return true;
    }
    var _Json_encode_fn = function (indentLevel, value) {
        return JSON.stringify(_Json_unwrap(value), null, indentLevel) + "";
    }, _Json_encode = F2(_Json_encode_fn);
    function _Json_wrap_UNUSED(value) { return { $: 0, a: value }; }
    function _Json_unwrap_UNUSED(value) { return value.a; }
    function _Json_wrap(value) { return value; }
    function _Json_unwrap(value) { return value; }
    function _Json_emptyArray() { return []; }
    function _Json_emptyObject() { return {}; }
    var _Json_addField_fn = function (key, value, object) {
        object[key] = _Json_unwrap(value);
        return object;
    }, _Json_addField = F3(_Json_addField_fn);
    function _Json_addEntry(func) {
        return F2(function (entry, array) {
            array.push(_Json_unwrap(func(entry)));
            return array;
        });
    }
    var _Json_encodeNull = _Json_wrap(null);
    function _Scheduler_succeed(value) {
        return {
            $: 0,
            a: value
        };
    }
    function _Scheduler_fail(error) {
        return {
            $: 1,
            a: error
        };
    }
    function _Scheduler_binding(callback) {
        return {
            $: 2,
            b: callback,
            c: null
        };
    }
    var _Scheduler_andThen_fn = function (callback, task) {
        return {
            $: 3,
            b: callback,
            d: task
        };
    }, _Scheduler_andThen = F2(_Scheduler_andThen_fn);
    var _Scheduler_onError_fn = function (callback, task) {
        return {
            $: 4,
            b: callback,
            d: task
        };
    }, _Scheduler_onError = F2(_Scheduler_onError_fn);
    function _Scheduler_receive(callback) {
        return {
            $: 5,
            b: callback
        };
    }
    var _Scheduler_guid = 0;
    function _Scheduler_rawSpawn(task) {
        var proc = {
            $: 0,
            e: _Scheduler_guid++,
            f: task,
            g: null,
            h: []
        };
        _Scheduler_enqueue(proc);
        return proc;
    }
    function _Scheduler_spawn(task) {
        return _Scheduler_binding(function (callback) {
            callback(_Scheduler_succeed(_Scheduler_rawSpawn(task)));
        });
    }
    function _Scheduler_rawSend(proc, msg) {
        proc.h.push(msg);
        _Scheduler_enqueue(proc);
    }
    var _Scheduler_send_fn = function (proc, msg) {
        return _Scheduler_binding(function (callback) {
            _Scheduler_rawSend(proc, msg);
            callback(_Scheduler_succeed(_Utils_Tuple0));
        });
    }, _Scheduler_send = F2(_Scheduler_send_fn);
    function _Scheduler_kill(proc) {
        return _Scheduler_binding(function (callback) {
            var task = proc.f;
            if (task.$ === 2 && task.c) {
                task.c();
            }
            proc.f = null;
            callback(_Scheduler_succeed(_Utils_Tuple0));
        });
    }
    var _Scheduler_working = false;
    var _Scheduler_queue = [];
    function _Scheduler_enqueue(proc) {
        _Scheduler_queue.push(proc);
        if (_Scheduler_working) {
            return;
        }
        _Scheduler_working = true;
        while (proc = _Scheduler_queue.shift()) {
            _Scheduler_step(proc);
        }
        _Scheduler_working = false;
    }
    function _Scheduler_step(proc) {
        while (proc.f) {
            var rootTag = proc.f.$;
            if (rootTag === 0 || rootTag === 1) {
                while (proc.g && proc.g.$ !== rootTag) {
                    proc.g = proc.g.i;
                }
                if (!proc.g) {
                    return;
                }
                proc.f = proc.g.b(proc.f.a);
                proc.g = proc.g.i;
            }
            else if (rootTag === 2) {
                proc.f.c = proc.f.b(function (newRoot) {
                    proc.f = newRoot;
                    _Scheduler_enqueue(proc);
                });
                return;
            }
            else if (rootTag === 5) {
                if (proc.h.length === 0) {
                    return;
                }
                proc.f = proc.f.b(proc.h.shift());
            }
            else {
                proc.g = {
                    $: rootTag === 3 ? 0 : 1,
                    b: proc.f.b,
                    i: proc.g
                };
                proc.f = proc.f.d;
            }
        }
    }
    function _Process_sleep(time) {
        return _Scheduler_binding(function (callback) {
            var id = setTimeout(function () {
                callback(_Scheduler_succeed(_Utils_Tuple0));
            }, time);
            return function () { clearTimeout(id); };
        });
    }
    var _Platform_worker_fn = function (impl, flagDecoder, debugMetadata, args) {
        return _Platform_initialize(flagDecoder, args, impl.et, impl.fx, impl.fd, function () { return function () { }; });
    }, _Platform_worker = F4(_Platform_worker_fn);
    function _Platform_initialize(flagDecoder, args, init, update, subscriptions, stepperBuilder) {
        var result = _Json_run_fn(flagDecoder, _Json_wrap(args ? args["flags"] : undefined));
        $elm$core$Result$isOk(result) || _Debug_crash(2);
        var managers = {};
        var initPair = init(result.a);
        var model = initPair.a;
        var stepper = stepperBuilder(sendToApp, model);
        var ports = _Platform_setupEffects(managers, sendToApp);
        function sendToApp(msg, viewMetadata) {
            var pair = A2(update, msg, model);
            stepper(model = pair.a, viewMetadata);
            _Platform_enqueueEffects(managers, pair.b, subscriptions(model));
        }
        _Platform_enqueueEffects(managers, initPair.b, subscriptions(model));
        return ports ? { ports: ports } : {};
    }
    var _Platform_preload;
    function _Platform_registerPreload(url) {
        _Platform_preload.add(url);
    }
    var _Platform_effectManagers = {};
    function _Platform_setupEffects(managers, sendToApp) {
        var ports;
        for (var key in _Platform_effectManagers) {
            var manager = _Platform_effectManagers[key];
            if (manager.a) {
                ports = ports || {};
                ports[key] = manager.a(key, sendToApp);
            }
            managers[key] = _Platform_instantiateManager(manager, sendToApp);
        }
        return ports;
    }
    function _Platform_createManager(init, onEffects, onSelfMsg, cmdMap, subMap) {
        return {
            b: init,
            c: onEffects,
            d: onSelfMsg,
            e: cmdMap,
            f: subMap
        };
    }
    function _Platform_instantiateManager(info, sendToApp) {
        var router = {
            g: sendToApp,
            h: undefined
        };
        var onEffects = info.c;
        var onSelfMsg = info.d;
        var cmdMap = info.e;
        var subMap = info.f;
        function loop(state) {
            return _Scheduler_andThen_fn(loop, _Scheduler_receive(function (msg) {
                var value = msg.a;
                if (msg.$ === 0) {
                    return A3(onSelfMsg, router, value, state);
                }
                return cmdMap && subMap
                    ? A4(onEffects, router, value.i, value.j, state)
                    : A3(onEffects, router, cmdMap ? value.i : value.j, state);
            }));
        }
        return router.h = _Scheduler_rawSpawn(_Scheduler_andThen_fn(loop, info.b));
    }
    var _Platform_sendToApp_fn = function (router, msg) {
        return _Scheduler_binding(function (callback) {
            router.g(msg);
            callback(_Scheduler_succeed(_Utils_Tuple0));
        });
    }, _Platform_sendToApp = F2(_Platform_sendToApp_fn);
    var _Platform_sendToSelf_fn = function (router, msg) {
        return _Scheduler_send_fn(router.h, {
            $: 0,
            a: msg
        });
    }, _Platform_sendToSelf = F2(_Platform_sendToSelf_fn);
    function _Platform_leaf(home) {
        return function (value) {
            return {
                $: 1,
                k: home,
                l: value
            };
        };
    }
    function _Platform_batch(list) {
        return {
            $: 2,
            m: list
        };
    }
    var _Platform_map_fn = function (tagger, bag) {
        return {
            $: 3,
            n: tagger,
            o: bag
        };
    }, _Platform_map = F2(_Platform_map_fn);
    var _Platform_effectsQueue = [];
    var _Platform_effectsActive = false;
    function _Platform_enqueueEffects(managers, cmdBag, subBag) {
        _Platform_effectsQueue.push({ p: managers, q: cmdBag, r: subBag });
        if (_Platform_effectsActive)
            return;
        _Platform_effectsActive = true;
        for (var fx; fx = _Platform_effectsQueue.shift();) {
            _Platform_dispatchEffects(fx.p, fx.q, fx.r);
        }
        _Platform_effectsActive = false;
    }
    function _Platform_dispatchEffects(managers, cmdBag, subBag) {
        var effectsDict = {};
        _Platform_gatherEffects(true, cmdBag, effectsDict, null);
        _Platform_gatherEffects(false, subBag, effectsDict, null);
        for (var home in managers) {
            _Scheduler_rawSend(managers[home], {
                $: "fx",
                a: effectsDict[home] || { i: _List_Nil, j: _List_Nil }
            });
        }
    }
    function _Platform_gatherEffects(isCmd, bag, effectsDict, taggers) {
        switch (bag.$) {
            case 1:
                var home = bag.k;
                var effect = _Platform_toEffect(isCmd, home, taggers, bag.l);
                effectsDict[home] = _Platform_insert(isCmd, effect, effectsDict[home]);
                return;
            case 2:
                for (var list = bag.m; list.b; list = list.b) {
                    _Platform_gatherEffects(isCmd, list.a, effectsDict, taggers);
                }
                return;
            case 3:
                _Platform_gatherEffects(isCmd, bag.o, effectsDict, {
                    s: bag.n,
                    t: taggers
                });
                return;
        }
    }
    function _Platform_toEffect(isCmd, home, taggers, value) {
        function applyTaggers(x) {
            for (var temp = taggers; temp; temp = temp.t) {
                x = temp.s(x);
            }
            return x;
        }
        var map = isCmd
            ? _Platform_effectManagers[home].e
            : _Platform_effectManagers[home].f;
        return A2(map, applyTaggers, value);
    }
    function _Platform_insert(isCmd, newEffect, effects) {
        effects = effects || { i: _List_Nil, j: _List_Nil };
        isCmd
            ? (effects.i = _List_Cons(newEffect, effects.i))
            : (effects.j = _List_Cons(newEffect, effects.j));
        return effects;
    }
    function _Platform_checkPortName(name) {
        if (_Platform_effectManagers[name]) {
            _Debug_crash(3, name);
        }
    }
    function _Platform_outgoingPort(name, converter) {
        _Platform_checkPortName(name);
        _Platform_effectManagers[name] = {
            e: _Platform_outgoingPortMap,
            u: converter,
            a: _Platform_setupOutgoingPort
        };
        return _Platform_leaf(name);
    }
    var _Platform_outgoingPortMap_fn = function (tagger, value) { return value; }, _Platform_outgoingPortMap = F2(_Platform_outgoingPortMap_fn);
    function _Platform_setupOutgoingPort(name) {
        var subs = [];
        var converter = _Platform_effectManagers[name].u;
        var init = _Process_sleep(0);
        _Platform_effectManagers[name].b = init;
        _Platform_effectManagers[name].c = F3(function (router, cmdList, state) {
            for (; cmdList.b; cmdList = cmdList.b) {
                var currentSubs = subs;
                var value = _Json_unwrap(converter(cmdList.a));
                for (var i = 0; i < currentSubs.length; i++) {
                    currentSubs[i](value);
                }
            }
            return init;
        });
        function subscribe(callback) {
            subs.push(callback);
        }
        function unsubscribe(callback) {
            subs = subs.slice();
            var index = subs.indexOf(callback);
            if (index >= 0) {
                subs.splice(index, 1);
            }
        }
        return {
            subscribe: subscribe,
            unsubscribe: unsubscribe
        };
    }
    function _Platform_incomingPort(name, converter) {
        _Platform_checkPortName(name);
        _Platform_effectManagers[name] = {
            f: _Platform_incomingPortMap,
            u: converter,
            a: _Platform_setupIncomingPort
        };
        return _Platform_leaf(name);
    }
    var _Platform_incomingPortMap_fn = function (tagger, finalTagger) {
        return function (value) {
            return tagger(finalTagger(value));
        };
    }, _Platform_incomingPortMap = F2(_Platform_incomingPortMap_fn);
    function _Platform_setupIncomingPort(name, sendToApp) {
        var subs = _List_Nil;
        var converter = _Platform_effectManagers[name].u;
        var init = _Scheduler_succeed(null);
        _Platform_effectManagers[name].b = init;
        _Platform_effectManagers[name].c = F3(function (router, subList, state) {
            subs = subList;
            return init;
        });
        function send(incomingValue) {
            var result = _Json_run_fn(converter, _Json_wrap(incomingValue));
            $elm$core$Result$isOk(result) || _Debug_crash(4, name, result.a);
            var value = result.a;
            for (var temp = subs; temp.b; temp = temp.b) {
                sendToApp(temp.a(value));
            }
        }
        return { send: send };
    }
    function _Platform_export(exports) {
        scope["Elm"]
            ? _Platform_mergeExportsProd(scope["Elm"], exports)
            : scope["Elm"] = exports;
    }
    function _Platform_mergeExportsProd(obj, exports) {
        for (var name in exports) {
            (name in obj)
                ? (name == "init")
                    ? _Debug_crash(6)
                    : _Platform_mergeExportsProd(obj[name], exports[name])
                : (obj[name] = exports[name]);
        }
    }
    function _Platform_export_UNUSED(exports) {
        scope["Elm"]
            ? _Platform_mergeExportsDebug("Elm", scope["Elm"], exports)
            : scope["Elm"] = exports;
    }
    function _Platform_mergeExportsDebug(moduleName, obj, exports) {
        for (var name in exports) {
            (name in obj)
                ? (name == "init")
                    ? _Debug_crash(6, moduleName)
                    : _Platform_mergeExportsDebug(moduleName + "." + name, obj[name], exports[name])
                : (obj[name] = exports[name]);
        }
    }
    var _VirtualDom_divertHrefToApp;
    var _VirtualDom_doc = typeof document !== "undefined" ? document : {};
    function _VirtualDom_appendChild(parent, child) {
        parent.appendChild(child);
    }
    var _VirtualDom_init_fn = function (virtualNode, flagDecoder, debugMetadata, args) {
        var node = args["node"];
        node.parentNode.replaceChild(_VirtualDom_render(virtualNode, function () { }), node);
        return {};
    }, _VirtualDom_init = F4(_VirtualDom_init_fn);
    function _VirtualDom_text(string) {
        return {
            $: 0,
            a: string
        };
    }
    var _VirtualDom_nodeNS_fn = function (namespace, tag) {
        return F2(function (factList, kidList) {
            for (var kids = [], descendantsCount = 0; kidList.b; kidList = kidList.b) {
                var kid = kidList.a;
                descendantsCount += (kid.b || 0);
                kids.push(kid);
            }
            descendantsCount += kids.length;
            return {
                $: 1,
                c: tag,
                d: _VirtualDom_organizeFacts(factList),
                e: kids,
                f: namespace,
                b: descendantsCount
            };
        });
    }, _VirtualDom_nodeNS = F2(_VirtualDom_nodeNS_fn);
    var _VirtualDom_node_a0 = undefined, _VirtualDom_node = _VirtualDom_nodeNS(_VirtualDom_node_a0);
    var _VirtualDom_keyedNodeNS_fn = function (namespace, tag) {
        return F2(function (factList, kidList) {
            for (var kids = [], descendantsCount = 0; kidList.b; kidList = kidList.b) {
                var kid = kidList.a;
                descendantsCount += (kid.b.b || 0);
                kids.push(kid);
            }
            descendantsCount += kids.length;
            return {
                $: 2,
                c: tag,
                d: _VirtualDom_organizeFacts(factList),
                e: kids,
                f: namespace,
                b: descendantsCount
            };
        });
    }, _VirtualDom_keyedNodeNS = F2(_VirtualDom_keyedNodeNS_fn);
    var _VirtualDom_keyedNode_a0 = undefined, _VirtualDom_keyedNode = _VirtualDom_keyedNodeNS(_VirtualDom_keyedNode_a0);
    function _VirtualDom_custom(factList, model, render, diff) {
        return {
            $: 3,
            d: _VirtualDom_organizeFacts(factList),
            g: model,
            h: render,
            i: diff
        };
    }
    var _VirtualDom_map_fn = function (tagger, node) {
        return {
            $: 4,
            j: tagger,
            k: node,
            b: 1 + (node.b || 0)
        };
    }, _VirtualDom_map = F2(_VirtualDom_map_fn);
    function _VirtualDom_thunk(refs, thunk) {
        return {
            $: 5,
            l: refs,
            m: thunk,
            k: undefined
        };
    }
    var _VirtualDom_lazy_fn = function (func, a) {
        return _VirtualDom_thunk([func, a], function () {
            return func(a);
        });
    }, _VirtualDom_lazy = F2(_VirtualDom_lazy_fn);
    var _VirtualDom_lazy2_fn = function (func, a, b) {
        return _VirtualDom_thunk([func, a, b], function () {
            return A2(func, a, b);
        });
    }, _VirtualDom_lazy2_fn_unwrapped = function (func, a, b) {
        return _VirtualDom_thunk([func, a, b], function () {
            return func(a, b);
        });
    }, _VirtualDom_lazy2 = F3(_VirtualDom_lazy2_fn);
    var _VirtualDom_lazy3_fn = function (func, a, b, c) {
        return _VirtualDom_thunk([func, a, b, c], function () {
            return A3(func, a, b, c);
        });
    }, _VirtualDom_lazy3_fn_unwrapped = function (func, a, b, c) {
        return _VirtualDom_thunk([func, a, b, c], function () {
            return func(a, b, c);
        });
    }, _VirtualDom_lazy3 = F4(_VirtualDom_lazy3_fn);
    var _VirtualDom_lazy4_fn = function (func, a, b, c, d) {
        return _VirtualDom_thunk([func, a, b, c, d], function () {
            return A4(func, a, b, c, d);
        });
    }, _VirtualDom_lazy4_fn_unwrapped = function (func, a, b, c, d) {
        return _VirtualDom_thunk([func, a, b, c, d], function () {
            return func(a, b, c, d);
        });
    }, _VirtualDom_lazy4 = F5(_VirtualDom_lazy4_fn);
    var _VirtualDom_lazy5_fn = function (func, a, b, c, d, e) {
        return _VirtualDom_thunk([func, a, b, c, d, e], function () {
            return A5(func, a, b, c, d, e);
        });
    }, _VirtualDom_lazy5_fn_unwrapped = function (func, a, b, c, d, e) {
        return _VirtualDom_thunk([func, a, b, c, d, e], function () {
            return func(a, b, c, d, e);
        });
    }, _VirtualDom_lazy5 = F6(_VirtualDom_lazy5_fn);
    var _VirtualDom_lazy6_fn = function (func, a, b, c, d, e, f) {
        return _VirtualDom_thunk([func, a, b, c, d, e, f], function () {
            return A6(func, a, b, c, d, e, f);
        });
    }, _VirtualDom_lazy6_fn_unwrapped = function (func, a, b, c, d, e, f) {
        return _VirtualDom_thunk([func, a, b, c, d, e, f], function () {
            return func(a, b, c, d, e, f);
        });
    }, _VirtualDom_lazy6 = F7(_VirtualDom_lazy6_fn);
    var _VirtualDom_lazy7_fn = function (func, a, b, c, d, e, f, g) {
        return _VirtualDom_thunk([func, a, b, c, d, e, f, g], function () {
            return A7(func, a, b, c, d, e, f, g);
        });
    }, _VirtualDom_lazy7_fn_unwrapped = function (func, a, b, c, d, e, f, g) {
        return _VirtualDom_thunk([func, a, b, c, d, e, f, g], function () {
            return func(a, b, c, d, e, f, g);
        });
    }, _VirtualDom_lazy7 = F8(_VirtualDom_lazy7_fn);
    var _VirtualDom_lazy8_fn = function (func, a, b, c, d, e, f, g, h) {
        return _VirtualDom_thunk([func, a, b, c, d, e, f, g, h], function () {
            return A8(func, a, b, c, d, e, f, g, h);
        });
    }, _VirtualDom_lazy8_fn_unwrapped = function (func, a, b, c, d, e, f, g, h) {
        return _VirtualDom_thunk([func, a, b, c, d, e, f, g, h], function () {
            return func(a, b, c, d, e, f, g, h);
        });
    }, _VirtualDom_lazy8 = F9(_VirtualDom_lazy8_fn);
    var _VirtualDom_on_fn = function (key, handler) {
        return {
            $: "a0",
            n: key,
            o: handler
        };
    }, _VirtualDom_on = F2(_VirtualDom_on_fn);
    var _VirtualDom_style_fn = function (key, value) {
        return {
            $: "a1",
            n: key,
            o: value
        };
    }, _VirtualDom_style = F2(_VirtualDom_style_fn);
    var _VirtualDom_property_fn = function (key, value) {
        return {
            $: "a2",
            n: key,
            o: value
        };
    }, _VirtualDom_property = F2(_VirtualDom_property_fn);
    var _VirtualDom_attribute_fn = function (key, value) {
        return {
            $: "a3",
            n: key,
            o: value
        };
    }, _VirtualDom_attribute = F2(_VirtualDom_attribute_fn);
    var _VirtualDom_attributeNS_fn = function (namespace, key, value) {
        return {
            $: "a4",
            n: key,
            o: { f: namespace, o: value }
        };
    }, _VirtualDom_attributeNS = F3(_VirtualDom_attributeNS_fn);
    var _VirtualDom_RE_script = /^script$/i;
    var _VirtualDom_RE_on_formAction = /^(on|formAction$)/i;
    var _VirtualDom_RE_js = /^\s*j\s*a\s*v\s*a\s*s\s*c\s*r\s*i\s*p\s*t\s*:/i;
    var _VirtualDom_RE_js_html = /^\s*(j\s*a\s*v\s*a\s*s\s*c\s*r\s*i\s*p\s*t\s*:|d\s*a\s*t\s*a\s*:\s*t\s*e\s*x\s*t\s*\/\s*h\s*t\s*m\s*l\s*(,|;))/i;
    function _VirtualDom_noScript(tag) {
        return _VirtualDom_RE_script.test(tag) ? "p" : tag;
    }
    function _VirtualDom_noOnOrFormAction(key) {
        return _VirtualDom_RE_on_formAction.test(key) ? "data-" + key : key;
    }
    function _VirtualDom_noInnerHtmlOrFormAction(key) {
        return key == "innerHTML" || key == "formAction" ? "data-" + key : key;
    }
    function _VirtualDom_noJavaScriptUri(value) {
        return _VirtualDom_RE_js.test(value)
            ? ""
            : value;
    }
    function _VirtualDom_noJavaScriptOrHtmlUri(value) {
        return _VirtualDom_RE_js_html.test(value)
            ? ""
            : value;
    }
    function _VirtualDom_noJavaScriptOrHtmlJson(value) {
        return (typeof _Json_unwrap(value) === "string" && _VirtualDom_RE_js_html.test(_Json_unwrap(value)))
            ? _Json_wrap("") : value;
    }
    var _VirtualDom_mapAttribute_fn = function (func, attr) {
        return (attr.$ === "a0")
            ? _VirtualDom_on_fn(attr.n, _VirtualDom_mapHandler(func, attr.o)) : attr;
    }, _VirtualDom_mapAttribute = F2(_VirtualDom_mapAttribute_fn);
    function _VirtualDom_mapHandler(func, handler) {
        var tag = $elm$virtual_dom$VirtualDom$toHandlerInt(handler);
        return {
            $: handler.$,
            a: !tag
                ? _Json_map1_fn(func, handler.a) : _Json_map2_fn(tag < 3
                ? _VirtualDom_mapEventTuple
                : _VirtualDom_mapEventRecord, $elm$json$Json$Decode$succeed(func), handler.a)
        };
    }
    var _VirtualDom_mapEventTuple_fn = function (func, tuple) {
        return _Utils_Tuple2(func(tuple.a), tuple.b);
    }, _VirtualDom_mapEventTuple = F2(_VirtualDom_mapEventTuple_fn);
    var _VirtualDom_mapEventRecord_fn = function (func, record) {
        return {
            ag: func(record.ag),
            b6: record.b6,
            b0: record.b0
        };
    }, _VirtualDom_mapEventRecord = F2(_VirtualDom_mapEventRecord_fn);
    function _VirtualDom_organizeFacts(factList) {
        for (var facts = {}; factList.b; factList = factList.b) {
            var entry = factList.a;
            var tag = entry.$;
            var key = entry.n;
            var value = entry.o;
            if (tag === "a2") {
                (key === "className")
                    ? _VirtualDom_addClass(facts, key, _Json_unwrap(value))
                    : facts[key] = _Json_unwrap(value);
                continue;
            }
            var subFacts = facts[tag] || (facts[tag] = {});
            (tag === "a3" && key === "class")
                ? _VirtualDom_addClass(subFacts, key, value)
                : subFacts[key] = value;
        }
        return facts;
    }
    function _VirtualDom_addClass(object, key, newClass) {
        var classes = object[key];
        object[key] = classes ? classes + " " + newClass : newClass;
    }
    function _VirtualDom_render(vNode, eventNode) {
        var tag = vNode.$;
        if (tag === 5) {
            return _VirtualDom_render(vNode.k || (vNode.k = vNode.m()), eventNode);
        }
        if (tag === 0) {
            return _VirtualDom_doc.createTextNode(vNode.a);
        }
        if (tag === 4) {
            var subNode = vNode.k;
            var tagger = vNode.j;
            while (subNode.$ === 4) {
                typeof tagger !== "object"
                    ? tagger = [tagger, subNode.j]
                    : tagger.push(subNode.j);
                subNode = subNode.k;
            }
            var subEventRoot = { j: tagger, p: eventNode };
            var domNode = _VirtualDom_render(subNode, subEventRoot);
            domNode.elm_event_node_ref = subEventRoot;
            return domNode;
        }
        if (tag === 3) {
            var domNode = vNode.h(vNode.g);
            _VirtualDom_applyFacts(domNode, eventNode, vNode.d);
            return domNode;
        }
        var domNode = vNode.f
            ? _VirtualDom_doc.createElementNS(vNode.f, vNode.c)
            : _VirtualDom_doc.createElement(vNode.c);
        if (_VirtualDom_divertHrefToApp && vNode.c == "a") {
            domNode.addEventListener("click", _VirtualDom_divertHrefToApp(domNode));
        }
        _VirtualDom_applyFacts(domNode, eventNode, vNode.d);
        for (var kids = vNode.e, i = 0; i < kids.length; i++) {
            _VirtualDom_appendChild(domNode, _VirtualDom_render(tag === 1 ? kids[i] : kids[i].b, eventNode));
        }
        return domNode;
    }
    function _VirtualDom_applyFacts(domNode, eventNode, facts) {
        for (var key in facts) {
            var value = facts[key];
            key === "a1"
                ? _VirtualDom_applyStyles(domNode, value)
                :
                    key === "a0"
                        ? _VirtualDom_applyEvents(domNode, eventNode, value)
                        :
                            key === "a3"
                                ? _VirtualDom_applyAttrs(domNode, value)
                                :
                                    key === "a4"
                                        ? _VirtualDom_applyAttrsNS(domNode, value)
                                        :
                                            ((key !== "value" && key !== "checked") || domNode[key] !== value) && (domNode[key] = value);
        }
    }
    function _VirtualDom_applyStyles(domNode, styles) {
        var domNodeStyle = domNode.style;
        for (var key in styles) {
            domNodeStyle[key] = styles[key];
        }
    }
    function _VirtualDom_applyAttrs(domNode, attrs) {
        for (var key in attrs) {
            var value = attrs[key];
            typeof value !== "undefined"
                ? domNode.setAttribute(key, value)
                : domNode.removeAttribute(key);
        }
    }
    function _VirtualDom_applyAttrsNS(domNode, nsAttrs) {
        for (var key in nsAttrs) {
            var pair = nsAttrs[key];
            var namespace = pair.f;
            var value = pair.o;
            typeof value !== "undefined"
                ? domNode.setAttributeNS(namespace, key, value)
                : domNode.removeAttributeNS(namespace, key);
        }
    }
    function _VirtualDom_applyEvents(domNode, eventNode, events) {
        var allCallbacks = domNode.elmFs || (domNode.elmFs = {});
        for (var key in events) {
            var newHandler = events[key];
            var oldCallback = allCallbacks[key];
            if (!newHandler) {
                domNode.removeEventListener(key, oldCallback);
                allCallbacks[key] = undefined;
                continue;
            }
            if (oldCallback) {
                var oldHandler = oldCallback.q;
                if (oldHandler.$ === newHandler.$) {
                    oldCallback.q = newHandler;
                    continue;
                }
                domNode.removeEventListener(key, oldCallback);
            }
            oldCallback = _VirtualDom_makeCallback(eventNode, newHandler);
            domNode.addEventListener(key, oldCallback, _VirtualDom_passiveSupported
                && { passive: $elm$virtual_dom$VirtualDom$toHandlerInt(newHandler) < 2 });
            allCallbacks[key] = oldCallback;
        }
    }
    var _VirtualDom_passiveSupported;
    try {
        window.addEventListener("t", null, Object.defineProperty({}, "passive", {
            get: function () { _VirtualDom_passiveSupported = true; }
        }));
    }
    catch (e) { }
    function _VirtualDom_makeCallback(eventNode, initialHandler) {
        function callback(event) {
            var handler = callback.q;
            var result = _Json_runHelp(handler.a, event);
            if (!$elm$core$Result$isOk(result)) {
                return;
            }
            var tag = $elm$virtual_dom$VirtualDom$toHandlerInt(handler);
            var value = result.a;
            var message = !tag ? value : tag < 3 ? value.a : value.ag;
            var stopPropagation = tag == 1 ? value.b : tag == 3 && value.b6;
            var currentEventNode = (stopPropagation && event.stopPropagation(),
                (tag == 2 ? value.b : tag == 3 && value.b0) && event.preventDefault(),
                eventNode);
            var tagger;
            var i;
            while (tagger = currentEventNode.j) {
                if (typeof tagger == "function") {
                    message = tagger(message);
                }
                else {
                    for (var i = tagger.length; i--;) {
                        message = tagger[i](message);
                    }
                }
                currentEventNode = currentEventNode.p;
            }
            currentEventNode(message, stopPropagation);
        }
        callback.q = initialHandler;
        return callback;
    }
    function _VirtualDom_equalEvents(x, y) {
        return x.$ == y.$ && _Json_equality(x.a, y.a);
    }
    function _VirtualDom_diff(x, y) {
        var patches = [];
        _VirtualDom_diffHelp(x, y, patches, 0);
        return patches;
    }
    function _VirtualDom_pushPatch(patches, type, index, data) {
        var patch = {
            $: type,
            r: index,
            s: data,
            t: undefined,
            u: undefined
        };
        patches.push(patch);
        return patch;
    }
    function _VirtualDom_diffHelp(x, y, patches, index) {
        if (x === y) {
            return;
        }
        var xType = x.$;
        var yType = y.$;
        if (xType !== yType) {
            if (xType === 1 && yType === 2) {
                y = _VirtualDom_dekey(y);
                yType = 1;
            }
            else {
                _VirtualDom_pushPatch(patches, 0, index, y);
                return;
            }
        }
        switch (yType) {
            case 5:
                var xRefs = x.l;
                var yRefs = y.l;
                var i = xRefs.length;
                var same = i === yRefs.length;
                while (same && i--) {
                    same = xRefs[i] === yRefs[i];
                }
                if (same) {
                    y.k = x.k;
                    return;
                }
                y.k = y.m();
                var subPatches = [];
                _VirtualDom_diffHelp(x.k, y.k, subPatches, 0);
                subPatches.length > 0 && _VirtualDom_pushPatch(patches, 1, index, subPatches);
                return;
            case 4:
                var xTaggers = x.j;
                var yTaggers = y.j;
                var nesting = false;
                var xSubNode = x.k;
                while (xSubNode.$ === 4) {
                    nesting = true;
                    typeof xTaggers !== "object"
                        ? xTaggers = [xTaggers, xSubNode.j]
                        : xTaggers.push(xSubNode.j);
                    xSubNode = xSubNode.k;
                }
                var ySubNode = y.k;
                while (ySubNode.$ === 4) {
                    nesting = true;
                    typeof yTaggers !== "object"
                        ? yTaggers = [yTaggers, ySubNode.j]
                        : yTaggers.push(ySubNode.j);
                    ySubNode = ySubNode.k;
                }
                if (nesting && xTaggers.length !== yTaggers.length) {
                    _VirtualDom_pushPatch(patches, 0, index, y);
                    return;
                }
                if (nesting ? !_VirtualDom_pairwiseRefEqual(xTaggers, yTaggers) : xTaggers !== yTaggers) {
                    _VirtualDom_pushPatch(patches, 2, index, yTaggers);
                }
                _VirtualDom_diffHelp(xSubNode, ySubNode, patches, index + 1);
                return;
            case 0:
                if (x.a !== y.a) {
                    _VirtualDom_pushPatch(patches, 3, index, y.a);
                }
                return;
            case 1:
                _VirtualDom_diffNodes(x, y, patches, index, _VirtualDom_diffKids);
                return;
            case 2:
                _VirtualDom_diffNodes(x, y, patches, index, _VirtualDom_diffKeyedKids);
                return;
            case 3:
                if (x.h !== y.h) {
                    _VirtualDom_pushPatch(patches, 0, index, y);
                    return;
                }
                var factsDiff = _VirtualDom_diffFacts(x.d, y.d);
                factsDiff && _VirtualDom_pushPatch(patches, 4, index, factsDiff);
                var patch = y.i(x.g, y.g);
                patch && _VirtualDom_pushPatch(patches, 5, index, patch);
                return;
        }
    }
    function _VirtualDom_pairwiseRefEqual(as, bs) {
        for (var i = 0; i < as.length; i++) {
            if (as[i] !== bs[i]) {
                return false;
            }
        }
        return true;
    }
    function _VirtualDom_diffNodes(x, y, patches, index, diffKids) {
        if (x.c !== y.c || x.f !== y.f) {
            _VirtualDom_pushPatch(patches, 0, index, y);
            return;
        }
        var factsDiff = _VirtualDom_diffFacts(x.d, y.d);
        factsDiff && _VirtualDom_pushPatch(patches, 4, index, factsDiff);
        diffKids(x, y, patches, index);
    }
    function _VirtualDom_diffFacts(x, y, category) {
        var diff;
        for (var xKey in x) {
            if (xKey === "a1" || xKey === "a0" || xKey === "a3" || xKey === "a4") {
                var subDiff = _VirtualDom_diffFacts(x[xKey], y[xKey] || {}, xKey);
                if (subDiff) {
                    diff = diff || {};
                    diff[xKey] = subDiff;
                }
                continue;
            }
            if (!(xKey in y)) {
                diff = diff || {};
                diff[xKey] =
                    !category
                        ? (typeof x[xKey] === "string" ? "" : null)
                        :
                            (category === "a1")
                                ? ""
                                :
                                    (category === "a0" || category === "a3")
                                        ? undefined
                                        :
                                            { f: x[xKey].f, o: undefined };
                continue;
            }
            var xValue = x[xKey];
            var yValue = y[xKey];
            if (xValue === yValue && xKey !== "value" && xKey !== "checked"
                || category === "a0" && _VirtualDom_equalEvents(xValue, yValue)) {
                continue;
            }
            diff = diff || {};
            diff[xKey] = yValue;
        }
        for (var yKey in y) {
            if (!(yKey in x)) {
                diff = diff || {};
                diff[yKey] = y[yKey];
            }
        }
        return diff;
    }
    function _VirtualDom_diffKids(xParent, yParent, patches, index) {
        var xKids = xParent.e;
        var yKids = yParent.e;
        var xLen = xKids.length;
        var yLen = yKids.length;
        if (xLen > yLen) {
            _VirtualDom_pushPatch(patches, 6, index, {
                v: yLen,
                i: xLen - yLen
            });
        }
        else if (xLen < yLen) {
            _VirtualDom_pushPatch(patches, 7, index, {
                v: xLen,
                e: yKids
            });
        }
        for (var minLen = xLen < yLen ? xLen : yLen, i = 0; i < minLen; i++) {
            var xKid = xKids[i];
            _VirtualDom_diffHelp(xKid, yKids[i], patches, ++index);
            index += xKid.b || 0;
        }
    }
    function _VirtualDom_diffKeyedKids(xParent, yParent, patches, rootIndex) {
        var localPatches = [];
        var changes = {};
        var inserts = [];
        var xKids = xParent.e;
        var yKids = yParent.e;
        var xLen = xKids.length;
        var yLen = yKids.length;
        var xIndex = 0;
        var yIndex = 0;
        var index = rootIndex;
        while (xIndex < xLen && yIndex < yLen) {
            var x = xKids[xIndex];
            var y = yKids[yIndex];
            var xKey = x.a;
            var yKey = y.a;
            var xNode = x.b;
            var yNode = y.b;
            var newMatch = undefined;
            var oldMatch = undefined;
            if (xKey === yKey) {
                index++;
                _VirtualDom_diffHelp(xNode, yNode, localPatches, index);
                index += xNode.b || 0;
                xIndex++;
                yIndex++;
                continue;
            }
            var xNext = xKids[xIndex + 1];
            var yNext = yKids[yIndex + 1];
            if (xNext) {
                var xNextKey = xNext.a;
                var xNextNode = xNext.b;
                oldMatch = yKey === xNextKey;
            }
            if (yNext) {
                var yNextKey = yNext.a;
                var yNextNode = yNext.b;
                newMatch = xKey === yNextKey;
            }
            if (newMatch && oldMatch) {
                index++;
                _VirtualDom_diffHelp(xNode, yNextNode, localPatches, index);
                _VirtualDom_insertNode(changes, localPatches, xKey, yNode, yIndex, inserts);
                index += xNode.b || 0;
                index++;
                _VirtualDom_removeNode(changes, localPatches, xKey, xNextNode, index);
                index += xNextNode.b || 0;
                xIndex += 2;
                yIndex += 2;
                continue;
            }
            if (newMatch) {
                index++;
                _VirtualDom_insertNode(changes, localPatches, yKey, yNode, yIndex, inserts);
                _VirtualDom_diffHelp(xNode, yNextNode, localPatches, index);
                index += xNode.b || 0;
                xIndex += 1;
                yIndex += 2;
                continue;
            }
            if (oldMatch) {
                index++;
                _VirtualDom_removeNode(changes, localPatches, xKey, xNode, index);
                index += xNode.b || 0;
                index++;
                _VirtualDom_diffHelp(xNextNode, yNode, localPatches, index);
                index += xNextNode.b || 0;
                xIndex += 2;
                yIndex += 1;
                continue;
            }
            if (xNext && xNextKey === yNextKey) {
                index++;
                _VirtualDom_removeNode(changes, localPatches, xKey, xNode, index);
                _VirtualDom_insertNode(changes, localPatches, yKey, yNode, yIndex, inserts);
                index += xNode.b || 0;
                index++;
                _VirtualDom_diffHelp(xNextNode, yNextNode, localPatches, index);
                index += xNextNode.b || 0;
                xIndex += 2;
                yIndex += 2;
                continue;
            }
            break;
        }
        while (xIndex < xLen) {
            index++;
            var x = xKids[xIndex];
            var xNode = x.b;
            _VirtualDom_removeNode(changes, localPatches, x.a, xNode, index);
            index += xNode.b || 0;
            xIndex++;
        }
        while (yIndex < yLen) {
            var endInserts = endInserts || [];
            var y = yKids[yIndex];
            _VirtualDom_insertNode(changes, localPatches, y.a, y.b, undefined, endInserts);
            yIndex++;
        }
        if (localPatches.length > 0 || inserts.length > 0 || endInserts) {
            _VirtualDom_pushPatch(patches, 8, rootIndex, {
                w: localPatches,
                x: inserts,
                y: endInserts
            });
        }
    }
    var _VirtualDom_POSTFIX = "_elmW6BL";
    function _VirtualDom_insertNode(changes, localPatches, key, vnode, yIndex, inserts) {
        var entry = changes[key];
        if (!entry) {
            entry = {
                c: 0,
                z: vnode,
                r: yIndex,
                s: undefined
            };
            inserts.push({ r: yIndex, A: entry });
            changes[key] = entry;
            return;
        }
        if (entry.c === 1) {
            inserts.push({ r: yIndex, A: entry });
            entry.c = 2;
            var subPatches = [];
            _VirtualDom_diffHelp(entry.z, vnode, subPatches, entry.r);
            entry.r = yIndex;
            entry.s.s = {
                w: subPatches,
                A: entry
            };
            return;
        }
        _VirtualDom_insertNode(changes, localPatches, key + _VirtualDom_POSTFIX, vnode, yIndex, inserts);
    }
    function _VirtualDom_removeNode(changes, localPatches, key, vnode, index) {
        var entry = changes[key];
        if (!entry) {
            var patch = _VirtualDom_pushPatch(localPatches, 9, index, undefined);
            changes[key] = {
                c: 1,
                z: vnode,
                r: index,
                s: patch
            };
            return;
        }
        if (entry.c === 0) {
            entry.c = 2;
            var subPatches = [];
            _VirtualDom_diffHelp(vnode, entry.z, subPatches, index);
            _VirtualDom_pushPatch(localPatches, 9, index, {
                w: subPatches,
                A: entry
            });
            return;
        }
        _VirtualDom_removeNode(changes, localPatches, key + _VirtualDom_POSTFIX, vnode, index);
    }
    function _VirtualDom_addDomNodes(domNode, vNode, patches, eventNode) {
        _VirtualDom_addDomNodesHelp(domNode, vNode, patches, 0, 0, vNode.b, eventNode);
    }
    function _VirtualDom_addDomNodesHelp(domNode, vNode, patches, i, low, high, eventNode) {
        var patch = patches[i];
        var index = patch.r;
        while (index === low) {
            var patchType = patch.$;
            if (patchType === 1) {
                _VirtualDom_addDomNodes(domNode, vNode.k, patch.s, eventNode);
            }
            else if (patchType === 8) {
                patch.t = domNode;
                patch.u = eventNode;
                var subPatches = patch.s.w;
                if (subPatches.length > 0) {
                    _VirtualDom_addDomNodesHelp(domNode, vNode, subPatches, 0, low, high, eventNode);
                }
            }
            else if (patchType === 9) {
                patch.t = domNode;
                patch.u = eventNode;
                var data = patch.s;
                if (data) {
                    data.A.s = domNode;
                    var subPatches = data.w;
                    if (subPatches.length > 0) {
                        _VirtualDom_addDomNodesHelp(domNode, vNode, subPatches, 0, low, high, eventNode);
                    }
                }
            }
            else {
                patch.t = domNode;
                patch.u = eventNode;
            }
            i++;
            if (!(patch = patches[i]) || (index = patch.r) > high) {
                return i;
            }
        }
        var tag = vNode.$;
        if (tag === 4) {
            var subNode = vNode.k;
            while (subNode.$ === 4) {
                subNode = subNode.k;
            }
            return _VirtualDom_addDomNodesHelp(domNode, subNode, patches, i, low + 1, high, domNode.elm_event_node_ref);
        }
        var vKids = vNode.e;
        var childNodes = domNode.childNodes;
        for (var j = 0; j < vKids.length; j++) {
            low++;
            var vKid = tag === 1 ? vKids[j] : vKids[j].b;
            var nextLow = low + (vKid.b || 0);
            if (low <= index && index <= nextLow) {
                i = _VirtualDom_addDomNodesHelp(childNodes[j], vKid, patches, i, low, nextLow, eventNode);
                if (!(patch = patches[i]) || (index = patch.r) > high) {
                    return i;
                }
            }
            low = nextLow;
        }
        return i;
    }
    function _VirtualDom_applyPatches(rootDomNode, oldVirtualNode, patches, eventNode) {
        if (patches.length === 0) {
            return rootDomNode;
        }
        _VirtualDom_addDomNodes(rootDomNode, oldVirtualNode, patches, eventNode);
        return _VirtualDom_applyPatchesHelp(rootDomNode, patches);
    }
    function _VirtualDom_applyPatchesHelp(rootDomNode, patches) {
        for (var i = 0; i < patches.length; i++) {
            var patch = patches[i];
            var localDomNode = patch.t;
            var newNode = _VirtualDom_applyPatch(localDomNode, patch);
            if (localDomNode === rootDomNode) {
                rootDomNode = newNode;
            }
        }
        return rootDomNode;
    }
    function _VirtualDom_applyPatch(domNode, patch) {
        switch (patch.$) {
            case 0:
                return _VirtualDom_applyPatchRedraw(domNode, patch.s, patch.u);
            case 4:
                _VirtualDom_applyFacts(domNode, patch.u, patch.s);
                return domNode;
            case 3:
                domNode.replaceData(0, domNode.length, patch.s);
                return domNode;
            case 1:
                return _VirtualDom_applyPatchesHelp(domNode, patch.s);
            case 2:
                if (domNode.elm_event_node_ref) {
                    domNode.elm_event_node_ref.j = patch.s;
                }
                else {
                    domNode.elm_event_node_ref = { j: patch.s, p: patch.u };
                }
                return domNode;
            case 6:
                var data = patch.s;
                for (var i = 0; i < data.i; i++) {
                    domNode.removeChild(domNode.childNodes[data.v]);
                }
                return domNode;
            case 7:
                var data = patch.s;
                var kids = data.e;
                var i = data.v;
                var theEnd = domNode.childNodes[i];
                for (; i < kids.length; i++) {
                    domNode.insertBefore(_VirtualDom_render(kids[i], patch.u), theEnd);
                }
                return domNode;
            case 9:
                var data = patch.s;
                if (!data) {
                    domNode.parentNode.removeChild(domNode);
                    return domNode;
                }
                var entry = data.A;
                if (typeof entry.r !== "undefined") {
                    domNode.parentNode.removeChild(domNode);
                }
                entry.s = _VirtualDom_applyPatchesHelp(domNode, data.w);
                return domNode;
            case 8:
                return _VirtualDom_applyPatchReorder(domNode, patch);
            case 5:
                return patch.s(domNode);
            default:
                _Debug_crash(10);
        }
    }
    function _VirtualDom_applyPatchRedraw(domNode, vNode, eventNode) {
        var parentNode = domNode.parentNode;
        var newNode = _VirtualDom_render(vNode, eventNode);
        if (!newNode.elm_event_node_ref) {
            newNode.elm_event_node_ref = domNode.elm_event_node_ref;
        }
        if (parentNode && newNode !== domNode) {
            parentNode.replaceChild(newNode, domNode);
        }
        return newNode;
    }
    function _VirtualDom_applyPatchReorder(domNode, patch) {
        var data = patch.s;
        var frag = _VirtualDom_applyPatchReorderEndInsertsHelp(data.y, patch);
        domNode = _VirtualDom_applyPatchesHelp(domNode, data.w);
        var inserts = data.x;
        for (var i = 0; i < inserts.length; i++) {
            var insert = inserts[i];
            var entry = insert.A;
            var node = entry.c === 2
                ? entry.s
                : _VirtualDom_render(entry.z, patch.u);
            domNode.insertBefore(node, domNode.childNodes[insert.r]);
        }
        if (frag) {
            _VirtualDom_appendChild(domNode, frag);
        }
        return domNode;
    }
    function _VirtualDom_applyPatchReorderEndInsertsHelp(endInserts, patch) {
        if (!endInserts) {
            return;
        }
        var frag = _VirtualDom_doc.createDocumentFragment();
        for (var i = 0; i < endInserts.length; i++) {
            var insert = endInserts[i];
            var entry = insert.A;
            _VirtualDom_appendChild(frag, entry.c === 2
                ? entry.s
                : _VirtualDom_render(entry.z, patch.u));
        }
        return frag;
    }
    function _VirtualDom_virtualize(node) {
        if (node.nodeType === 3) {
            return _VirtualDom_text(node.textContent);
        }
        if (node.nodeType !== 1) {
            return _VirtualDom_text("");
        }
        var attrList = _List_Nil;
        var attrs = node.attributes;
        for (var i = attrs.length; i--;) {
            var attr = attrs[i];
            var name = attr.name;
            var value = attr.value;
            attrList = _List_Cons(_VirtualDom_attribute_fn(name, value), attrList);
        }
        var tag = node.tagName.toLowerCase();
        var kidList = _List_Nil;
        var kids = node.childNodes;
        for (var i = kids.length; i--;) {
            kidList = _List_Cons(_VirtualDom_virtualize(kids[i]), kidList);
        }
        return A3(_VirtualDom_node, tag, attrList, kidList);
    }
    function _VirtualDom_dekey(keyedNode) {
        var keyedKids = keyedNode.e;
        var len = keyedKids.length;
        var kids = new Array(len);
        for (var i = 0; i < len; i++) {
            kids[i] = keyedKids[i].b;
        }
        return {
            $: 1,
            c: keyedNode.c,
            d: keyedNode.d,
            e: kids,
            f: keyedNode.f,
            b: keyedNode.b
        };
    }
    var _Debugger_element;
    var _Browser_element = _Debugger_element || F4(function (impl, flagDecoder, debugMetadata, args) {
        return _Platform_initialize(flagDecoder, args, impl.et, impl.fx, impl.fd, function (sendToApp, initialModel) {
            var view = impl.fy;
            var domNode = args["node"];
            var currNode = _VirtualDom_virtualize(domNode);
            return _Browser_makeAnimator(initialModel, function (model) {
                var nextNode = view(model);
                var patches = _VirtualDom_diff(currNode, nextNode);
                domNode = _VirtualDom_applyPatches(domNode, currNode, patches, sendToApp);
                currNode = nextNode;
            });
        });
    });
    var _Debugger_document;
    var _Browser_document = _Debugger_document || F4(function (impl, flagDecoder, debugMetadata, args) {
        return _Platform_initialize(flagDecoder, args, impl.et, impl.fx, impl.fd, function (sendToApp, initialModel) {
            var divertHrefToApp = impl.b4 && impl.b4(sendToApp);
            var view = impl.fy;
            var title = _VirtualDom_doc.title;
            var bodyNode = _VirtualDom_doc.body;
            var currNode = _VirtualDom_virtualize(bodyNode);
            return _Browser_makeAnimator(initialModel, function (model) {
                _VirtualDom_divertHrefToApp = divertHrefToApp;
                var doc = view(model);
                var nextNode = _VirtualDom_nodeNS_fn(_VirtualDom_node_a0, "body")(_List_Nil)(doc.dI);
                var patches = _VirtualDom_diff(currNode, nextNode);
                bodyNode = _VirtualDom_applyPatches(bodyNode, currNode, patches, sendToApp);
                currNode = nextNode;
                _VirtualDom_divertHrefToApp = 0;
                (title !== doc.fs) && (_VirtualDom_doc.title = title = doc.fs);
            });
        });
    });
    var _Browser_cancelAnimationFrame = typeof cancelAnimationFrame !== "undefined"
        ? cancelAnimationFrame
        : function (id) { clearTimeout(id); };
    var _Browser_requestAnimationFrame = typeof requestAnimationFrame !== "undefined"
        ? requestAnimationFrame
        : function (callback) { return setTimeout(callback, 1000 / 60); };
    function _Browser_makeAnimator(model, draw) {
        draw(model);
        var state = 0;
        function updateIfNeeded() {
            state = state === 1
                ? 0
                : (_Browser_requestAnimationFrame(updateIfNeeded), draw(model), 1);
        }
        return function (nextModel, isSync) {
            model = nextModel;
            isSync
                ? (draw(model),
                    state === 2 && (state = 1))
                : (state === 0 && _Browser_requestAnimationFrame(updateIfNeeded),
                    state = 2);
        };
    }
    function _Browser_application(impl) {
        var onUrlChange = impl.eO;
        var onUrlRequest = impl.eP;
        var key = function () { key.a(onUrlChange(_Browser_getUrl())); };
        return _Browser_document({
            b4: function (sendToApp) {
                key.a = sendToApp;
                _Browser_window.addEventListener("popstate", key);
                _Browser_window.navigator.userAgent.indexOf("Trident") < 0 || _Browser_window.addEventListener("hashchange", key);
                return F2(function (domNode, event) {
                    if (!event.ctrlKey && !event.metaKey && !event.shiftKey && event.button < 1 && !domNode.target && !domNode.hasAttribute("download")) {
                        event.preventDefault();
                        var href = domNode.href;
                        var curr = _Browser_getUrl();
                        var next = $elm$url$Url$fromString(href).a;
                        sendToApp(onUrlRequest((next
                            && curr.cY === next.cY
                            && curr.cx === next.cx
                            && curr.cT.a === next.cT.a)
                            ? $elm$browser$Browser$Internal(next)
                            : $elm$browser$Browser$External(href)));
                    }
                });
            },
            et: function (flags) {
                return A3(impl.et, flags, _Browser_getUrl(), key);
            },
            fy: impl.fy,
            fx: impl.fx,
            fd: impl.fd
        });
    }
    function _Browser_getUrl() {
        return $elm$url$Url$fromString(_VirtualDom_doc.location.href).a || _Debug_crash(1);
    }
    var _Browser_go_fn = function (key, n) {
        return $elm$core$Task$perform_fn($elm$core$Basics$never, _Scheduler_binding(function () {
            n && history.go(n);
            key();
        }));
    }, _Browser_go = F2(_Browser_go_fn);
    var _Browser_pushUrl_fn = function (key, url) {
        return $elm$core$Task$perform_fn($elm$core$Basics$never, _Scheduler_binding(function () {
            history.pushState({}, "", url);
            key();
        }));
    }, _Browser_pushUrl = F2(_Browser_pushUrl_fn);
    var _Browser_replaceUrl_fn = function (key, url) {
        return $elm$core$Task$perform_fn($elm$core$Basics$never, _Scheduler_binding(function () {
            history.replaceState({}, "", url);
            key();
        }));
    }, _Browser_replaceUrl = F2(_Browser_replaceUrl_fn);
    var _Browser_fakeNode = { addEventListener: function () { }, removeEventListener: function () { } };
    var _Browser_doc = typeof document !== "undefined" ? document : _Browser_fakeNode;
    var _Browser_window = typeof window !== "undefined" ? window : _Browser_fakeNode;
    var _Browser_on_fn = function (node, eventName, sendToSelf) {
        return _Scheduler_spawn(_Scheduler_binding(function (callback) {
            function handler(event) { _Scheduler_rawSpawn(sendToSelf(event)); }
            node.addEventListener(eventName, handler, _VirtualDom_passiveSupported && { passive: true });
            return function () { node.removeEventListener(eventName, handler); };
        }));
    }, _Browser_on = F3(_Browser_on_fn);
    var _Browser_decodeEvent_fn = function (decoder, event) {
        var result = _Json_runHelp(decoder, event);
        return $elm$core$Result$isOk(result) ? $elm$core$Maybe$Just(result.a) : $elm$core$Maybe$Nothing;
    }, _Browser_decodeEvent = F2(_Browser_decodeEvent_fn);
    function _Browser_visibilityInfo() {
        return (typeof _VirtualDom_doc.hidden !== "undefined")
            ? { el: "hidden", dV: "visibilitychange" }
            :
                (typeof _VirtualDom_doc.mozHidden !== "undefined")
                    ? { el: "mozHidden", dV: "mozvisibilitychange" }
                    :
                        (typeof _VirtualDom_doc.msHidden !== "undefined")
                            ? { el: "msHidden", dV: "msvisibilitychange" }
                            :
                                (typeof _VirtualDom_doc.webkitHidden !== "undefined")
                                    ? { el: "webkitHidden", dV: "webkitvisibilitychange" }
                                    : { el: "hidden", dV: "visibilitychange" };
    }
    function _Browser_rAF() {
        return _Scheduler_binding(function (callback) {
            var id = _Browser_requestAnimationFrame(function () {
                callback(_Scheduler_succeed(Date.now()));
            });
            return function () {
                _Browser_cancelAnimationFrame(id);
            };
        });
    }
    function _Browser_now() {
        return _Scheduler_binding(function (callback) {
            callback(_Scheduler_succeed(Date.now()));
        });
    }
    function _Browser_withNode(id, doStuff) {
        return _Scheduler_binding(function (callback) {
            _Browser_requestAnimationFrame(function () {
                var node = document.getElementById(id);
                callback(node
                    ? _Scheduler_succeed(doStuff(node))
                    : _Scheduler_fail($elm$browser$Browser$Dom$NotFound(id)));
            });
        });
    }
    function _Browser_withWindow(doStuff) {
        return _Scheduler_binding(function (callback) {
            _Browser_requestAnimationFrame(function () {
                callback(_Scheduler_succeed(doStuff()));
            });
        });
    }
    var _Browser_call_fn = function (functionName, id) {
        return _Browser_withNode(id, function (node) {
            node[functionName]();
            return _Utils_Tuple0;
        });
    }, _Browser_call = F2(_Browser_call_fn);
    function _Browser_getViewport() {
        return {
            c3: _Browser_getScene(),
            dh: {
                dm: _Browser_window.pageXOffset,
                dn: _Browser_window.pageYOffset,
                di: _Browser_doc.documentElement.clientWidth,
                cu: _Browser_doc.documentElement.clientHeight
            }
        };
    }
    function _Browser_getScene() {
        var body = _Browser_doc.body;
        var elem = _Browser_doc.documentElement;
        return {
            di: Math.max(body.scrollWidth, body.offsetWidth, elem.scrollWidth, elem.offsetWidth, elem.clientWidth),
            cu: Math.max(body.scrollHeight, body.offsetHeight, elem.scrollHeight, elem.offsetHeight, elem.clientHeight)
        };
    }
    var _Browser_setViewport_fn = function (x, y) {
        return _Browser_withWindow(function () {
            _Browser_window.scroll(x, y);
            return _Utils_Tuple0;
        });
    }, _Browser_setViewport = F2(_Browser_setViewport_fn);
    function _Browser_getViewportOf(id) {
        return _Browser_withNode(id, function (node) {
            return {
                c3: {
                    di: node.scrollWidth,
                    cu: node.scrollHeight
                },
                dh: {
                    dm: node.scrollLeft,
                    dn: node.scrollTop,
                    di: node.clientWidth,
                    cu: node.clientHeight
                }
            };
        });
    }
    var _Browser_setViewportOf_fn = function (id, x, y) {
        return _Browser_withNode(id, function (node) {
            node.scrollLeft = x;
            node.scrollTop = y;
            return _Utils_Tuple0;
        });
    }, _Browser_setViewportOf = F3(_Browser_setViewportOf_fn);
    function _Browser_getElement(id) {
        return _Browser_withNode(id, function (node) {
            var rect = node.getBoundingClientRect();
            var x = _Browser_window.pageXOffset;
            var y = _Browser_window.pageYOffset;
            return {
                c3: _Browser_getScene(),
                dh: {
                    dm: x,
                    dn: y,
                    di: _Browser_doc.documentElement.clientWidth,
                    cu: _Browser_doc.documentElement.clientHeight
                },
                ea: {
                    dm: x + rect.left,
                    dn: y + rect.top,
                    di: rect.width,
                    cu: rect.height
                }
            };
        });
    }
    function _Browser_reload(skipCache) {
        return $elm$core$Task$perform_fn($elm$core$Basics$never, _Scheduler_binding(function (callback) {
            _VirtualDom_doc.location.reload(skipCache);
        }));
    }
    function _Browser_load(url) {
        return $elm$core$Task$perform_fn($elm$core$Basics$never, _Scheduler_binding(function (callback) {
            try {
                _Browser_window.location = url;
            }
            catch (err) {
                _VirtualDom_doc.location.reload(false);
            }
        }));
    }
    var _Benchmark_getTimestamp = typeof performance !== "undefined"
        ? performance.now.bind(performance)
        : Date.now;
    var _Benchmark_sample_fn = function (n, fn) {
        return _Scheduler_binding(function (callback) {
            var start = _Benchmark_getTimestamp();
            try {
                for (var i = 0; i < n; i++) {
                    fn();
                }
            }
            catch (error) {
                if (error instanceof RangeError) {
                    callback(_Scheduler_fail($elm_explorations$benchmark$Benchmark$LowLevel$StackOverflow));
                }
                else {
                    callback(_Scheduler_fail($elm_explorations$benchmark$Benchmark$LowLevel$UnknownError(error.message)));
                }
                return;
            }
            var end = _Benchmark_getTimestamp();
            callback(_Scheduler_succeed(end - start));
        });
    }, _Benchmark_sample = F2(_Benchmark_sample_fn);
    function _Benchmark_operation(thunk) {
        return thunk;
    }
    var $elm$core$Basics$EQ = 1;
    var $elm$core$Basics$LT = 0;
    var $elm$core$List$cons = _List_cons;
    var $elm$core$Elm$JsArray$foldr = _JsArray_foldr;
    var $elm$core$Array$foldr_fn = function (func, baseCase, _v0) {
        var tree = _v0.c;
        var tail = _v0.d;
        var helper = F2(function (node, acc) {
            if (!node.$) {
                var subTree = node.a;
                return _JsArray_foldr_fn(helper, acc, subTree);
            }
            else {
                var values = node.a;
                return _JsArray_foldr_fn(func, acc, values);
            }
        });
        return _JsArray_foldr_fn(helper, _JsArray_foldr_fn(func, baseCase, tail), tree);
    }, $elm$core$Array$foldr = F3($elm$core$Array$foldr_fn);
    var $elm$core$Array$toList = function (array) {
        return $elm$core$Array$foldr_fn($elm$core$List$cons, _List_Nil, array);
    };
    var $elm$core$Dict$foldr_fn = function (func, acc, t) {
        foldr: while (true) {
            if (t.$ === -2) {
                return acc;
            }
            else {
                var key = t.b;
                var value = t.c;
                var left = t.d;
                var right = t.e;
                var $temp$func = func, $temp$acc = A3(func, key, value, $elm$core$Dict$foldr_fn(func, acc, right)), $temp$t = left;
                func = $temp$func;
                acc = $temp$acc;
                t = $temp$t;
                continue foldr;
            }
        }
    }, $elm$core$Dict$foldr_fn_unwrapped = function (func, acc, t) {
        foldr: while (true) {
            if (t.$ === -2) {
                return acc;
            }
            else {
                var key = t.b;
                var value = t.c;
                var left = t.d;
                var right = t.e;
                var $temp$func = func, $temp$acc = func(key, value, $elm$core$Dict$foldr_fn_unwrapped(func, acc, right)), $temp$t = left;
                func = $temp$func;
                acc = $temp$acc;
                t = $temp$t;
                continue foldr;
            }
        }
    }, $elm$core$Dict$foldr = F3($elm$core$Dict$foldr_fn);
    var $elm$core$Dict$toList = function (dict) {
        return $elm$core$Dict$foldr_fn_unwrapped(function (key, value, list) {
            return _List_Cons(_Utils_Tuple2(key, value), list);
        }, _List_Nil, dict);
    };
    var $elm$core$Dict$keys = function (dict) {
        return $elm$core$Dict$foldr_fn_unwrapped(function (key, value, keyList) {
            return _List_Cons(key, keyList);
        }, _List_Nil, dict);
    };
    var $elm$core$Set$toList = function (_v0) {
        var dict = _v0;
        return $elm$core$Dict$keys(dict);
    };
    var $elm$core$Basics$GT = 2;
    var $elm$core$Basics$always_fn = function (a, _v0) {
        return a;
    }, $elm$core$Basics$always = F2($elm$core$Basics$always_fn);
    var $elm$core$Result$Err = function (a) {
        return { $: 1, a: a };
    };
    var $elm$json$Json$Decode$Failure_fn = function (a, b) {
        return { $: 3, a: a, b: b };
    }, $elm$json$Json$Decode$Failure = F2($elm$json$Json$Decode$Failure_fn);
    var $elm$json$Json$Decode$Field_fn = function (a, b) {
        return { $: 0, a: a, b: b };
    }, $elm$json$Json$Decode$Field = F2($elm$json$Json$Decode$Field_fn);
    var $elm$json$Json$Decode$Index_fn = function (a, b) {
        return { $: 1, a: a, b: b };
    }, $elm$json$Json$Decode$Index = F2($elm$json$Json$Decode$Index_fn);
    var $elm$core$Result$Ok = function (a) {
        return { $: 0, a: a };
    };
    var $elm$json$Json$Decode$OneOf = function (a) {
        return { $: 2, a: a };
    };
    var $elm$core$Basics$False = 1;
    var $elm$core$Basics$add = _Basics_add;
    var $elm$core$Maybe$Just = function (a) { return { $: 0, a: a }; };
    var $elm$core$Maybe$Nothing = { $: 1, a: null };
    var $elm$core$String$all = _String_all;
    var $elm$core$Basics$and = _Basics_and;
    var $elm$core$Basics$append = _Utils_append;
    var $elm$json$Json$Encode$encode = _Json_encode;
    var $elm$core$String$fromInt = _String_fromNumber;
    var $elm$core$String$join_fn = function (sep, chunks) {
        return _String_join_fn(sep, _List_toArray(chunks));
    }, $elm$core$String$join = F2($elm$core$String$join_fn);
    var $elm$core$String$split_fn = function (sep, string) {
        return _List_fromArray(_String_split_fn(sep, string));
    }, $elm$core$String$split = F2($elm$core$String$split_fn);
    var $elm$json$Json$Decode$indent = function (str) {
        return $elm$core$String$join_fn("\n    ", $elm$core$String$split_fn("\n", str));
    };
    var $elm$core$List$foldl_fn = function (func, acc, list) {
        foldl: while (true) {
            if (!list.b) {
                return acc;
            }
            else {
                var x = list.a;
                var xs = list.b;
                var $temp$func = func, $temp$acc = A2(func, x, acc), $temp$list = xs;
                func = $temp$func;
                acc = $temp$acc;
                list = $temp$list;
                continue foldl;
            }
        }
    }, $elm$core$List$foldl_fn_unwrapped = function (func, acc, list) {
        foldl: while (true) {
            if (!list.b) {
                return acc;
            }
            else {
                var x = list.a;
                var xs = list.b;
                var $temp$func = func, $temp$acc = func(x, acc), $temp$list = xs;
                func = $temp$func;
                acc = $temp$acc;
                list = $temp$list;
                continue foldl;
            }
        }
    }, $elm$core$List$foldl = F3($elm$core$List$foldl_fn);
    var $elm$core$List$length = function (xs) {
        return $elm$core$List$foldl_fn_unwrapped(function (_v0, i) {
            return i + 1;
        }, 0, xs);
    };
    var $elm$core$List$map2 = _List_map2;
    var $elm$core$Basics$le = _Utils_le;
    var $elm$core$Basics$sub = _Basics_sub;
    var $elm$core$List$rangeHelp_fn = function (lo, hi, list) {
        rangeHelp: while (true) {
            if (_Utils_cmp(lo, hi) < 1) {
                var $temp$lo = lo, $temp$hi = hi - 1, $temp$list = _List_Cons(hi, list);
                lo = $temp$lo;
                hi = $temp$hi;
                list = $temp$list;
                continue rangeHelp;
            }
            else {
                return list;
            }
        }
    }, $elm$core$List$rangeHelp = F3($elm$core$List$rangeHelp_fn);
    var $elm$core$List$range_fn = function (lo, hi) {
        return $elm$core$List$rangeHelp_fn(lo, hi, _List_Nil);
    }, $elm$core$List$range = F2($elm$core$List$range_fn);
    var $elm$core$List$indexedMap_fn = function (f, xs) {
        var tmp = _List_Cons(undefined, _List_Nil);
        var end = tmp;
        for (var i = 0; xs.b; i++, xs = xs.b) {
            var next = _List_Cons(A2(f, i, xs.a), _List_Nil);
            end.b = next;
            end = next;
        }
        return tmp.b;
    }, $elm$core$List$indexedMap_fn_unwrapped = function (f, xs) {
        var tmp = _List_Cons(undefined, _List_Nil);
        var end = tmp;
        for (var i = 0; xs.b; i++, xs = xs.b) {
            var next = _List_Cons(f(i, xs.a), _List_Nil);
            end.b = next;
            end = next;
        }
        return tmp.b;
    }, $elm$core$List$indexedMap = F2($elm$core$List$indexedMap_fn);
    var $elm$core$Char$toCode = _Char_toCode;
    var $elm$core$Char$isLower = function (_char) {
        var code = $elm$core$Char$toCode(_char);
        return (97 <= code) && (code <= 122);
    };
    var $elm$core$Char$isUpper = function (_char) {
        var code = $elm$core$Char$toCode(_char);
        return (code <= 90) && (65 <= code);
    };
    var $elm$core$Basics$or = _Basics_or;
    var $elm$core$Char$isAlpha = function (_char) {
        return $elm$core$Char$isLower(_char) || $elm$core$Char$isUpper(_char);
    };
    var $elm$core$Char$isDigit = function (_char) {
        var code = $elm$core$Char$toCode(_char);
        return (code <= 57) && (48 <= code);
    };
    var $elm$core$Char$isAlphaNum = function (_char) {
        return $elm$core$Char$isLower(_char) || ($elm$core$Char$isUpper(_char) || $elm$core$Char$isDigit(_char));
    };
    var $elm$core$List$reverse = function (list) {
        return $elm$core$List$foldl_fn($elm$core$List$cons, _List_Nil, list);
    };
    var $elm$core$String$uncons = _String_uncons;
    var $elm$json$Json$Decode$errorOneOf_fn = function (i, error) {
        return "\n\n(" + ($elm$core$String$fromInt(i + 1) + (") " + $elm$json$Json$Decode$indent($elm$json$Json$Decode$errorToString(error))));
    }, $elm$json$Json$Decode$errorOneOf = F2($elm$json$Json$Decode$errorOneOf_fn);
    var $elm$json$Json$Decode$errorToString = function (error) {
        return $elm$json$Json$Decode$errorToStringHelp_fn(error, _List_Nil);
    };
    var $elm$json$Json$Decode$errorToStringHelp_fn = function (error, context) {
        errorToStringHelp: while (true) {
            switch (error.$) {
                case 0:
                    var f = error.a;
                    var err = error.b;
                    var isSimple = function () {
                        var _v1 = $elm$core$String$uncons(f);
                        if (_v1.$ === 1) {
                            return false;
                        }
                        else {
                            var _v2 = _v1.a;
                            var _char = _v2.a;
                            var rest = _v2.b;
                            return $elm$core$Char$isAlpha(_char) && _String_all_fn($elm$core$Char$isAlphaNum, rest);
                        }
                    }();
                    var fieldName = isSimple ? ("." + f) : ("['" + (f + "']"));
                    var $temp$error = err, $temp$context = _List_Cons(fieldName, context);
                    error = $temp$error;
                    context = $temp$context;
                    continue errorToStringHelp;
                case 1:
                    var i = error.a;
                    var err = error.b;
                    var indexName = "[" + ($elm$core$String$fromInt(i) + "]");
                    var $temp$error = err, $temp$context = _List_Cons(indexName, context);
                    error = $temp$error;
                    context = $temp$context;
                    continue errorToStringHelp;
                case 2:
                    var errors = error.a;
                    if (!errors.b) {
                        return "Ran into a Json.Decode.oneOf with no possibilities" + function () {
                            if (!context.b) {
                                return "!";
                            }
                            else {
                                return " at json" + $elm$core$String$join_fn("", $elm$core$List$reverse(context));
                            }
                        }();
                    }
                    else {
                        if (!errors.b.b) {
                            var err = errors.a;
                            var $temp$error = err, $temp$context = context;
                            error = $temp$error;
                            context = $temp$context;
                            continue errorToStringHelp;
                        }
                        else {
                            var starter = function () {
                                if (!context.b) {
                                    return "Json.Decode.oneOf";
                                }
                                else {
                                    return "The Json.Decode.oneOf at json" + $elm$core$String$join_fn("", $elm$core$List$reverse(context));
                                }
                            }();
                            var introduction = starter + (" failed in the following " + ($elm$core$String$fromInt($elm$core$List$length(errors)) + " ways:"));
                            return $elm$core$String$join_fn("\n\n", _List_Cons(introduction, $elm$core$List$indexedMap_fn($elm$json$Json$Decode$errorOneOf, errors)));
                        }
                    }
                default:
                    var msg = error.a;
                    var json = error.b;
                    var introduction = function () {
                        if (!context.b) {
                            return "Problem with the given value:\n\n";
                        }
                        else {
                            return "Problem with the value at json" + ($elm$core$String$join_fn("", $elm$core$List$reverse(context)) + ":\n\n    ");
                        }
                    }();
                    return introduction + ($elm$json$Json$Decode$indent(_Json_encode_fn(4, json)) + ("\n\n" + msg));
            }
        }
    }, $elm$json$Json$Decode$errorToStringHelp = F2($elm$json$Json$Decode$errorToStringHelp_fn);
    var $elm$core$Array$branchFactor = 32;
    var $elm$core$Array$Array_elm_builtin_fn = function (a, b, c, d) {
        return { $: 0, a: a, b: b, c: c, d: d };
    }, $elm$core$Array$Array_elm_builtin = F4($elm$core$Array$Array_elm_builtin_fn);
    var $elm$core$Elm$JsArray$empty = _JsArray_empty;
    var $elm$core$Basics$ceiling = _Basics_ceiling;
    var $elm$core$Basics$fdiv = _Basics_fdiv;
    var $elm$core$Basics$logBase_fn = function (base, number) {
        return _Basics_log(number) / _Basics_log(base);
    }, $elm$core$Basics$logBase = F2($elm$core$Basics$logBase_fn);
    var $elm$core$Basics$toFloat = _Basics_toFloat;
    var $elm$core$Array$shiftStep = $elm$core$Basics$ceiling($elm$core$Basics$logBase_fn(2, $elm$core$Array$branchFactor));
    var $elm$core$Array$empty = $elm$core$Array$Array_elm_builtin_fn(0, $elm$core$Array$shiftStep, $elm$core$Elm$JsArray$empty, $elm$core$Elm$JsArray$empty);
    var $elm$core$Elm$JsArray$initialize = _JsArray_initialize;
    var $elm$core$Array$Leaf = function (a) {
        return { $: 1, a: a };
    };
    var $elm$core$Basics$apL_fn = function (f, x) {
        return f(x);
    }, $elm$core$Basics$apL = F2($elm$core$Basics$apL_fn);
    var $elm$core$Basics$apR_fn = function (x, f) {
        return f(x);
    }, $elm$core$Basics$apR = F2($elm$core$Basics$apR_fn);
    var $elm$core$Basics$eq = _Utils_equal;
    var $elm$core$Basics$floor = _Basics_floor;
    var $elm$core$Elm$JsArray$length = _JsArray_length;
    var $elm$core$Basics$gt = _Utils_gt;
    var $elm$core$Basics$max_fn = function (x, y) {
        return (_Utils_cmp(x, y) > 0) ? x : y;
    }, $elm$core$Basics$max = F2($elm$core$Basics$max_fn);
    var $elm$core$Basics$mul = _Basics_mul;
    var $elm$core$Array$SubTree = function (a) {
        return { $: 0, a: a };
    };
    var $elm$core$Elm$JsArray$initializeFromList = _JsArray_initializeFromList;
    var $elm$core$Array$compressNodes_fn = function (nodes, acc) {
        compressNodes: while (true) {
            var _v0 = _JsArray_initializeFromList_fn($elm$core$Array$branchFactor, nodes);
            var node = _v0.a;
            var remainingNodes = _v0.b;
            var newAcc = _List_Cons($elm$core$Array$SubTree(node), acc);
            if (!remainingNodes.b) {
                return $elm$core$List$reverse(newAcc);
            }
            else {
                var $temp$nodes = remainingNodes, $temp$acc = newAcc;
                nodes = $temp$nodes;
                acc = $temp$acc;
                continue compressNodes;
            }
        }
    }, $elm$core$Array$compressNodes = F2($elm$core$Array$compressNodes_fn);
    var $elm$core$Tuple$first = function (_v0) {
        var x = _v0.a;
        return x;
    };
    var $elm$core$Array$treeFromBuilder_fn = function (nodeList, nodeListSize) {
        treeFromBuilder: while (true) {
            var newNodeSize = $elm$core$Basics$ceiling(nodeListSize / $elm$core$Array$branchFactor);
            if (newNodeSize === 1) {
                return _JsArray_initializeFromList_fn($elm$core$Array$branchFactor, nodeList).a;
            }
            else {
                var $temp$nodeList = $elm$core$Array$compressNodes_fn(nodeList, _List_Nil), $temp$nodeListSize = newNodeSize;
                nodeList = $temp$nodeList;
                nodeListSize = $temp$nodeListSize;
                continue treeFromBuilder;
            }
        }
    }, $elm$core$Array$treeFromBuilder = F2($elm$core$Array$treeFromBuilder_fn);
    var $elm$core$Array$builderToArray_fn = function (reverseNodeList, builder) {
        if (!builder.t) {
            return $elm$core$Array$Array_elm_builtin_fn($elm$core$Elm$JsArray$length(builder.w), $elm$core$Array$shiftStep, $elm$core$Elm$JsArray$empty, builder.w);
        }
        else {
            var treeLen = builder.t * $elm$core$Array$branchFactor;
            var depth = $elm$core$Basics$floor($elm$core$Basics$logBase_fn($elm$core$Array$branchFactor, treeLen - 1));
            var correctNodeList = reverseNodeList ? $elm$core$List$reverse(builder.x) : builder.x;
            var tree = $elm$core$Array$treeFromBuilder_fn(correctNodeList, builder.t);
            return $elm$core$Array$Array_elm_builtin_fn($elm$core$Elm$JsArray$length(builder.w) + treeLen, $elm$core$Basics$max_fn(5, depth * $elm$core$Array$shiftStep), tree, builder.w);
        }
    }, $elm$core$Array$builderToArray = F2($elm$core$Array$builderToArray_fn);
    var $elm$core$Basics$idiv = _Basics_idiv;
    var $elm$core$Basics$lt = _Utils_lt;
    var $elm$core$Array$initializeHelp_fn = function (fn, fromIndex, len, nodeList, tail) {
        initializeHelp: while (true) {
            if (fromIndex < 0) {
                return $elm$core$Array$builderToArray_fn(false, { x: nodeList, t: (len / $elm$core$Array$branchFactor) | 0, w: tail });
            }
            else {
                var leaf = $elm$core$Array$Leaf(_JsArray_initialize_fn($elm$core$Array$branchFactor, fromIndex, fn));
                var $temp$fn = fn, $temp$fromIndex = fromIndex - $elm$core$Array$branchFactor, $temp$len = len, $temp$nodeList = _List_Cons(leaf, nodeList), $temp$tail = tail;
                fn = $temp$fn;
                fromIndex = $temp$fromIndex;
                len = $temp$len;
                nodeList = $temp$nodeList;
                tail = $temp$tail;
                continue initializeHelp;
            }
        }
    }, $elm$core$Array$initializeHelp = F5($elm$core$Array$initializeHelp_fn);
    var $elm$core$Basics$remainderBy = _Basics_remainderBy;
    var $elm$core$Array$initialize_fn = function (len, fn) {
        if (len <= 0) {
            return $elm$core$Array$empty;
        }
        else {
            var tailLen = len % $elm$core$Array$branchFactor;
            var tail = _JsArray_initialize_fn(tailLen, len - tailLen, fn);
            var initialFromIndex = (len - tailLen) - $elm$core$Array$branchFactor;
            return $elm$core$Array$initializeHelp_fn(fn, initialFromIndex, len, _List_Nil, tail);
        }
    }, $elm$core$Array$initialize = F2($elm$core$Array$initialize_fn);
    var $elm$core$Basics$True = 0;
    var $elm$core$Result$isOk = function (result) {
        if (!result.$) {
            return true;
        }
        else {
            return false;
        }
    };
    var $elm$json$Json$Decode$map = _Json_map1;
    var $elm$json$Json$Decode$map2 = _Json_map2;
    var $elm$json$Json$Decode$succeed = _Json_succeed;
    var $elm$virtual_dom$VirtualDom$toHandlerInt = function (handler) {
        switch (handler.$) {
            case 0:
                return 0;
            case 1:
                return 1;
            case 2:
                return 2;
            default:
                return 3;
        }
    };
    var $elm$browser$Browser$External = function (a) {
        return { $: 1, a: a };
    };
    var $elm$browser$Browser$Internal = function (a) {
        return { $: 0, a: a };
    };
    var $elm$core$Basics$identity = function (x) {
        return x;
    };
    var $elm$browser$Browser$Dom$NotFound = $elm$core$Basics$identity;
    var $elm$url$Url$Http = 0;
    var $elm$url$Url$Https = 1;
    var $elm$url$Url$Url_fn = function (protocol, host, port_, path, query, fragment) {
        return { cs: fragment, cx: host, cQ: path, cT: port_, cY: protocol, cZ: query };
    }, $elm$url$Url$Url = F6($elm$url$Url$Url_fn);
    var $elm$core$String$contains = _String_contains;
    var $elm$core$String$length = _String_length;
    var $elm$core$String$slice = _String_slice;
    var $elm$core$String$dropLeft_fn = function (n, string) {
        return (n < 1) ? string : _String_slice_fn(n, $elm$core$String$length(string), string);
    }, $elm$core$String$dropLeft = F2($elm$core$String$dropLeft_fn);
    var $elm$core$String$indexes = _String_indexes;
    var $elm$core$String$isEmpty = function (string) {
        return string === "";
    };
    var $elm$core$String$left_fn = function (n, string) {
        return (n < 1) ? "" : _String_slice_fn(0, n, string);
    }, $elm$core$String$left = F2($elm$core$String$left_fn);
    var $elm$core$String$toInt = _String_toInt;
    var $elm$url$Url$chompBeforePath_fn = function (protocol, path, params, frag, str) {
        if ($elm$core$String$isEmpty(str) || _String_contains_fn("@", str)) {
            return $elm$core$Maybe$Nothing;
        }
        else {
            var _v0 = _String_indexes_fn(":", str);
            if (!_v0.b) {
                return $elm$core$Maybe$Just($elm$url$Url$Url_fn(protocol, str, $elm$core$Maybe$Nothing, path, params, frag));
            }
            else {
                if (!_v0.b.b) {
                    var i = _v0.a;
                    var _v1 = $elm$core$String$toInt($elm$core$String$dropLeft_fn(i + 1, str));
                    if (_v1.$ === 1) {
                        return $elm$core$Maybe$Nothing;
                    }
                    else {
                        var port_ = _v1;
                        return $elm$core$Maybe$Just($elm$url$Url$Url_fn(protocol, $elm$core$String$left_fn(i, str), port_, path, params, frag));
                    }
                }
                else {
                    return $elm$core$Maybe$Nothing;
                }
            }
        }
    }, $elm$url$Url$chompBeforePath = F5($elm$url$Url$chompBeforePath_fn);
    var $elm$url$Url$chompBeforeQuery_fn = function (protocol, params, frag, str) {
        if ($elm$core$String$isEmpty(str)) {
            return $elm$core$Maybe$Nothing;
        }
        else {
            var _v0 = _String_indexes_fn("/", str);
            if (!_v0.b) {
                return $elm$url$Url$chompBeforePath_fn(protocol, "/", params, frag, str);
            }
            else {
                var i = _v0.a;
                return $elm$url$Url$chompBeforePath_fn(protocol, $elm$core$String$dropLeft_fn(i, str), params, frag, $elm$core$String$left_fn(i, str));
            }
        }
    }, $elm$url$Url$chompBeforeQuery = F4($elm$url$Url$chompBeforeQuery_fn);
    var $elm$url$Url$chompBeforeFragment_fn = function (protocol, frag, str) {
        if ($elm$core$String$isEmpty(str)) {
            return $elm$core$Maybe$Nothing;
        }
        else {
            var _v0 = _String_indexes_fn("?", str);
            if (!_v0.b) {
                return $elm$url$Url$chompBeforeQuery_fn(protocol, $elm$core$Maybe$Nothing, frag, str);
            }
            else {
                var i = _v0.a;
                return $elm$url$Url$chompBeforeQuery_fn(protocol, $elm$core$Maybe$Just($elm$core$String$dropLeft_fn(i + 1, str)), frag, $elm$core$String$left_fn(i, str));
            }
        }
    }, $elm$url$Url$chompBeforeFragment = F3($elm$url$Url$chompBeforeFragment_fn);
    var $elm$url$Url$chompAfterProtocol_fn = function (protocol, str) {
        if ($elm$core$String$isEmpty(str)) {
            return $elm$core$Maybe$Nothing;
        }
        else {
            var _v0 = _String_indexes_fn("#", str);
            if (!_v0.b) {
                return $elm$url$Url$chompBeforeFragment_fn(protocol, $elm$core$Maybe$Nothing, str);
            }
            else {
                var i = _v0.a;
                return $elm$url$Url$chompBeforeFragment_fn(protocol, $elm$core$Maybe$Just($elm$core$String$dropLeft_fn(i + 1, str)), $elm$core$String$left_fn(i, str));
            }
        }
    }, $elm$url$Url$chompAfterProtocol = F2($elm$url$Url$chompAfterProtocol_fn);
    var $elm$core$String$startsWith = _String_startsWith;
    var $elm$url$Url$fromString = function (str) {
        return _String_startsWith_fn("http://", str) ? $elm$url$Url$chompAfterProtocol_fn(0, $elm$core$String$dropLeft_fn(7, str)) : (_String_startsWith_fn("https://", str) ? $elm$url$Url$chompAfterProtocol_fn(1, $elm$core$String$dropLeft_fn(8, str)) : $elm$core$Maybe$Nothing);
    };
    var $elm$core$Basics$never = function (_v0) {
        never: while (true) {
            var nvr = _v0;
            var $temp$_v0 = nvr;
            _v0 = $temp$_v0;
            continue never;
        }
    };
    var $elm$core$Task$Perform = $elm$core$Basics$identity;
    var $elm$core$Task$succeed = _Scheduler_succeed;
    var $elm$core$Task$init = $elm$core$Task$succeed(0);
    var $elm$core$List$foldrHelper_fn = function (fn, acc, ctr, ls) {
        if (!ls.b) {
            return acc;
        }
        else {
            var a = ls.a;
            var r1 = ls.b;
            if (!r1.b) {
                return A2(fn, a, acc);
            }
            else {
                var b = r1.a;
                var r2 = r1.b;
                if (!r2.b) {
                    return A2(fn, a, A2(fn, b, acc));
                }
                else {
                    var c = r2.a;
                    var r3 = r2.b;
                    if (!r3.b) {
                        return A2(fn, a, A2(fn, b, A2(fn, c, acc)));
                    }
                    else {
                        var d = r3.a;
                        var r4 = r3.b;
                        var res = (ctr > 500) ? $elm$core$List$foldl_fn(fn, acc, $elm$core$List$reverse(r4)) : $elm$core$List$foldrHelper_fn(fn, acc, ctr + 1, r4);
                        return A2(fn, a, A2(fn, b, A2(fn, c, A2(fn, d, res))));
                    }
                }
            }
        }
    }, $elm$core$List$foldrHelper_fn_unwrapped = function (fn, acc, ctr, ls) {
        if (!ls.b) {
            return acc;
        }
        else {
            var a = ls.a;
            var r1 = ls.b;
            if (!r1.b) {
                return fn(a, acc);
            }
            else {
                var b = r1.a;
                var r2 = r1.b;
                if (!r2.b) {
                    return fn(a, fn(b, acc));
                }
                else {
                    var c = r2.a;
                    var r3 = r2.b;
                    if (!r3.b) {
                        return fn(a, fn(b, fn(c, acc)));
                    }
                    else {
                        var d = r3.a;
                        var r4 = r3.b;
                        var res = (ctr > 500) ? $elm$core$List$foldl_fn_unwrapped(fn, acc, $elm$core$List$reverse(r4)) : $elm$core$List$foldrHelper_fn_unwrapped(fn, acc, ctr + 1, r4);
                        return fn(a, fn(b, fn(c, fn(d, res))));
                    }
                }
            }
        }
    }, $elm$core$List$foldrHelper = F4($elm$core$List$foldrHelper_fn);
    var $elm$core$List$foldr_fn = function (fn, acc, ls) {
        return $elm$core$List$foldrHelper_fn(fn, acc, 0, ls);
    }, $elm$core$List$foldr = F3($elm$core$List$foldr_fn);
    var $elm$core$List$map_fn = function (f, xs) {
        var tmp = _List_Cons(undefined, _List_Nil);
        var end = tmp;
        for (; xs.b; xs
            = xs.b) {
            var next = _List_Cons(f(xs.a), _List_Nil);
            end.b = next;
            end = next;
        }
        return tmp.b;
    }, $elm$core$List$map = F2($elm$core$List$map_fn);
    var $elm$core$Task$andThen = _Scheduler_andThen;
    var $elm$core$Task$map_fn = function (func, taskA) {
        return _Scheduler_andThen_fn(function (a) {
            return $elm$core$Task$succeed(func(a));
        }, taskA);
    }, $elm$core$Task$map = F2($elm$core$Task$map_fn);
    var $elm$core$Task$map2_fn = function (func, taskA, taskB) {
        return _Scheduler_andThen_fn(function (a) {
            return _Scheduler_andThen_fn(function (b) {
                return $elm$core$Task$succeed(A2(func, a, b));
            }, taskB);
        }, taskA);
    }, $elm$core$Task$map2_fn_unwrapped = function (func, taskA, taskB) {
        return _Scheduler_andThen_fn(function (a) {
            return _Scheduler_andThen_fn(function (b) {
                return $elm$core$Task$succeed(func(a, b));
            }, taskB);
        }, taskA);
    }, $elm$core$Task$map2 = F3($elm$core$Task$map2_fn);
    var $elm$core$Task$sequence = function (tasks) {
        return $elm$core$List$foldr_fn($elm$core$Task$map2($elm$core$List$cons), $elm$core$Task$succeed(_List_Nil), tasks);
    };
    var $elm$core$Platform$sendToApp = _Platform_sendToApp;
    var $elm$core$Task$spawnCmd_fn = function (router, _v0) {
        var task = _v0;
        return _Scheduler_spawn(_Scheduler_andThen_fn($elm$core$Platform$sendToApp(router), task));
    }, $elm$core$Task$spawnCmd = F2($elm$core$Task$spawnCmd_fn);
    var $elm$core$Task$onEffects_fn = function (router, commands, state) {
        return $elm$core$Task$map_fn(function (_v0) {
            return 0;
        }, $elm$core$Task$sequence($elm$core$List$map_fn($elm$core$Task$spawnCmd(router), commands)));
    }, $elm$core$Task$onEffects = F3($elm$core$Task$onEffects_fn);
    var $elm$core$Task$onSelfMsg_fn = function (_v0, _v1, _v2) {
        return $elm$core$Task$succeed(0);
    }, $elm$core$Task$onSelfMsg = F3($elm$core$Task$onSelfMsg_fn);
    var $elm$core$Task$cmdMap_fn = function (tagger, _v0) {
        var task = _v0;
        return $elm$core$Task$map_fn(tagger, task);
    }, $elm$core$Task$cmdMap = F2($elm$core$Task$cmdMap_fn);
    _Platform_effectManagers["Task"] = _Platform_createManager($elm$core$Task$init, $elm$core$Task$onEffects, $elm$core$Task$onSelfMsg, $elm$core$Task$cmdMap);
    var $elm$core$Task$command = _Platform_leaf("Task");
    var $elm$core$Task$perform_fn = function (toMessage, task) {
        return $elm$core$Task$command($elm$core$Task$map_fn(toMessage, task));
    }, $elm$core$Task$perform = F2($elm$core$Task$perform_fn);
    var $elm$browser$Browser$element = _Browser_element;
    var $elm$core$Basics$negate = function (n) {
        return -n;
    };
    var $elm$core$Platform$Sub$batch = _Platform_batch;
    var $elm$core$Platform$Sub$none = $elm$core$Platform$Sub$batch(_List_Nil);
    var $author$project$Main$GotSample = $elm$core$Basics$identity;
    var $elm$core$Basics$composeL_fn = function (g, f, x) {
        return g(f(x));
    }, $elm$core$Basics$composeL = F3($elm$core$Basics$composeL_fn);
    var $elm$core$Task$onError = _Scheduler_onError;
    var $elm$core$Task$attempt_fn = function (resultToMessage, task) {
        return $elm$core$Task$command(_Scheduler_onError_fn(A2($elm$core$Basics$composeL, A2($elm$core$Basics$composeL, $elm$core$Task$succeed, resultToMessage), $elm$core$Result$Err), _Scheduler_andThen_fn(A2($elm$core$Basics$composeL, A2($elm$core$Basics$composeL, $elm$core$Task$succeed, resultToMessage), $elm$core$Result$Ok), task)));
    }, $elm$core$Task$attempt = F2($elm$core$Task$attempt_fn);
    var $elm_explorations$benchmark$Benchmark$LowLevel$StackOverflow = { $: 0 };
    var $elm_explorations$benchmark$Benchmark$LowLevel$UnknownError = function (a) {
        return { $: 1, a: a };
    };
    var $elm_explorations$benchmark$Benchmark$LowLevel$operation = function (fn) {
        return _Benchmark_operation(fn);
    };
    var $author$project$Rope$empty = $elm$core$Maybe$Nothing;
    var $author$project$Elm$Syntax$Declaration$AliasDeclaration = function (a) {
        return { $: 1, a: a };
    };
    var $author$project$Elm$Syntax$Declaration$CustomTypeDeclaration = function (a) {
        return { $: 2, a: a };
    };
    var $author$project$Elm$Syntax$Declaration$FunctionDeclaration = function (a) {
        return { $: 0, a: a };
    };
    var $author$project$Elm$Syntax$Node$Node_fn = function (a, b) {
        return { $: 0, a: a, b: b };
    }, $author$project$Elm$Syntax$Node$Node = F2($author$project$Elm$Syntax$Node$Node_fn);
    var $author$project$Elm$Syntax$Declaration$PortDeclaration = function (a) {
        return { $: 3, a: a };
    };
    var $author$project$Elm$Syntax$Signature$Signature_fn = function (name, typeAnnotation) {
        return { q: name, y: typeAnnotation };
    }, $author$project$Elm$Syntax$Signature$Signature = F2($author$project$Elm$Syntax$Signature$Signature_fn);
    var $author$project$Elm$Syntax$Node$combine_fn = function (f, a, b) {
        var start = a.a.bE;
        var end = b.a.cm;
        return $author$project$Elm$Syntax$Node$Node_fn({ cm: end, bE: start }, A2(f, a, b));
    }, $author$project$Elm$Syntax$Node$combine_fn_unwrapped = function (f, a, b) {
        var start = a.a.bE;
        var end = b.a.cm;
        return $author$project$Elm$Syntax$Node$Node_fn({ cm: end, bE: start }, f(a, b));
    }, $author$project$Elm$Syntax$Node$combine = F3($author$project$Elm$Syntax$Node$combine_fn);
    var $author$project$ParserFast$Done = function (a) {
        return { $: 1, a: a };
    };
    var $author$project$ParserFast$Loop = function (a) {
        return { $: 0, a: a };
    };
    var $author$project$ParserFast$Bad_fn = function (a, b) {
        return { $: 1, a: a, b: b };
    }, $author$project$ParserFast$Bad = F2($author$project$ParserFast$Bad_fn);
    var $author$project$ParserFast$ExpectingAnyChar_fn = function (a, b) {
        return { $: 2, a: a, b: b };
    }, $author$project$ParserFast$ExpectingAnyChar = F2($author$project$ParserFast$ExpectingAnyChar_fn);
    var $author$project$ParserFast$Good_fn = function (a, b) {
        return { $: 0, a: a, b: b };
    }, $author$project$ParserFast$Good = F2($author$project$ParserFast$Good_fn);
    var $author$project$ParserFast$Parser = $elm$core$Basics$identity;
    var $elm$core$String$any = _String_any;
    var $elm$core$Basics$isNaN = _Basics_isNaN;
    var $author$project$Char$Extra$isUtf16Surrogate = function (c) {
        return $elm$core$Basics$isNaN($elm$core$Char$toCode(c));
    };
    var $author$project$ParserFast$charStringIsUtf16HighSurrogate = function (charString) {
        return _String_any_fn($author$project$Char$Extra$isUtf16Surrogate, charString);
    };
    var $author$project$ParserFast$charOrEnd_fn = function (offset, string) {
        var actualChar = _String_slice_fn(offset, offset + 1, string);
        switch (actualChar) {
            case "\n":
                return -2;
            case "":
                return -1;
            default:
                return $author$project$ParserFast$charStringIsUtf16HighSurrogate(actualChar) ? (offset + 2) : (offset + 1);
        }
    }, $author$project$ParserFast$charOrEnd = F2($author$project$ParserFast$charOrEnd_fn);
    var $author$project$ParserFast$skipWhileHelp_fn = function (isGood, offset, row, col, src, indent) {
        skipWhileHelp: while (true) {
            var actualChar = _String_slice_fn(offset, offset + 1, src);
            if (_String_any_fn(isGood, actualChar)) {
                if (actualChar === "\n") {
                    var $temp$isGood = isGood, $temp$offset = offset + 1, $temp$row = row + 1, $temp$col = 1, $temp$src = src, $temp$indent = indent;
                    isGood = $temp$isGood;
                    offset = $temp$offset;
                    row = $temp$row;
                    col = $temp$col;
                    src = $temp$src;
                    indent = $temp$indent;
                    continue skipWhileHelp;
                }
                else {
                    var $temp$isGood = isGood, $temp$offset = offset + 1, $temp$row = row, $temp$col = col + 1, $temp$src = src, $temp$indent = indent;
                    isGood = $temp$isGood;
                    offset = $temp$offset;
                    row = $temp$row;
                    col = $temp$col;
                    src = $temp$src;
                    indent = $temp$indent;
                    continue skipWhileHelp;
                }
            }
            else {
                if ($author$project$ParserFast$charStringIsUtf16HighSurrogate(actualChar) && _String_any_fn(isGood, _String_slice_fn(offset, offset + 2, src))) {
                    var $temp$isGood = isGood, $temp$offset = offset + 2, $temp$row = row, $temp$col = col + 1, $temp$src = src, $temp$indent = indent;
                    isGood = $temp$isGood;
                    offset = $temp$offset;
                    row = $temp$row;
                    col = $temp$col;
                    src = $temp$src;
                    indent = $temp$indent;
                    continue skipWhileHelp;
                }
                else {
                    return { a: col, f: indent, b: offset, bz: row, c: src };
                }
            }
        }
    }, $author$project$ParserFast$skipWhileHelp = F6($author$project$ParserFast$skipWhileHelp_fn);
    var $author$project$ParserFast$anyCharFollowedByWhileMap_fn = function (consumedStringToRes, afterFirstIsOkay) {
        return function (s) {
            var firstOffset = $author$project$ParserFast$charOrEnd_fn(s.b, s.c);
            if (firstOffset === -1) {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingAnyChar_fn(s.bz, s.a));
            }
            else {
                var s1 = firstOffset === -2 ? $author$project$ParserFast$skipWhileHelp_fn(afterFirstIsOkay, s.b + 1, s.bz + 1, 1, s.c, s.f) : $author$project$ParserFast$skipWhileHelp_fn(afterFirstIsOkay, firstOffset, s.bz, s.a + 1, s.c, s.f);
                return $author$project$ParserFast$Good_fn(consumedStringToRes(_String_slice_fn(s.b, s1.b, s.c)), s1);
            }
        };
    }, $author$project$ParserFast$anyCharFollowedByWhileMap = F2($author$project$ParserFast$anyCharFollowedByWhileMap_fn);
    var $elm$core$String$cons = _String_cons;
    var $author$project$ParserFast$loopHelp_fn = function (committedSoFar, state, element, reduce, s0) {
        loopHelp: while (true) {
            var parseElement = element;
            var _v0 = parseElement(s0);
            if (!_v0.$) {
                var step = _v0.a;
                var s1 = _v0.b;
                var _v1 = A2(reduce, step, state);
                if (!_v1.$) {
                    var newState = _v1.a;
                    var $temp$committedSoFar = true, $temp$state = newState, $temp$element = element, $temp$reduce = reduce, $temp$s0 = s1;
                    committedSoFar = $temp$committedSoFar;
                    state = $temp$state;
                    element = $temp$element;
                    reduce = $temp$reduce;
                    s0 = $temp$s0;
                    continue loopHelp;
                }
                else {
                    var result = _v1.a;
                    return $author$project$ParserFast$Good_fn(result, s1);
                }
            }
            else {
                var elementCommitted = _v0.a;
                var x = _v0.b;
                return $author$project$ParserFast$Bad_fn(committedSoFar || elementCommitted, x);
            }
        }
    }, $author$project$ParserFast$loopHelp_fn_unwrapped = function (committedSoFar, state, element, reduce, s0) {
        loopHelp: while (true) {
            var parseElement = element;
            var _v0 = parseElement(s0);
            if (!_v0.$) {
                var step = _v0.a;
                var s1 = _v0.b;
                var _v1 = reduce(step, state);
                if (!_v1.$) {
                    var newState = _v1.a;
                    var $temp$committedSoFar = true, $temp$state = newState, $temp$element = element, $temp$reduce = reduce, $temp$s0 = s1;
                    committedSoFar = $temp$committedSoFar;
                    state = $temp$state;
                    element = $temp$element;
                    reduce = $temp$reduce;
                    s0 = $temp$s0;
                    continue loopHelp;
                }
                else {
                    var result = _v1.a;
                    return $author$project$ParserFast$Good_fn(result, s1);
                }
            }
            else {
                var elementCommitted = _v0.a;
                var x = _v0.b;
                return $author$project$ParserFast$Bad_fn(committedSoFar || elementCommitted, x);
            }
        }
    }, $author$project$ParserFast$loopHelp = F5($author$project$ParserFast$loopHelp_fn);
    var $author$project$ParserFast$loop_fn = function (state, element, reduce) {
        return function (s) {
            return $author$project$ParserFast$loopHelp_fn(false, state, element, reduce, s);
        };
    }, $author$project$ParserFast$loop = F3($author$project$ParserFast$loop_fn);
    var $author$project$ParserFast$map2WithRange_fn = function (func, _v0, _v1) {
        var parseA = _v0;
        var parseB = _v1;
        return function (s0) {
            var _v2 = parseA(s0);
            if (_v2.$ === 1) {
                var committed = _v2.a;
                var x = _v2.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v2.a;
                var s1 = _v2.b;
                var _v3 = parseB(s1);
                if (_v3.$ === 1) {
                    var x = _v3.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v3.a;
                    var s2 = _v3.b;
                    return $author$project$ParserFast$Good_fn(A3(func, {
                        cm: { bk: s2.a, bz: s2.bz },
                        bE: { bk: s0.a, bz: s0.bz }
                    }, a, b), s2);
                }
            }
        };
    }, $author$project$ParserFast$map2WithRange_fn_unwrapped = function (func, _v0, _v1) {
        var parseA = _v0;
        var parseB = _v1;
        return function (s0) {
            var _v2 = parseA(s0);
            if (_v2.$ === 1) {
                var committed = _v2.a;
                var x = _v2.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v2.a;
                var s1 = _v2.b;
                var _v3 = parseB(s1);
                if (_v3.$ === 1) {
                    var x = _v3.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v3.a;
                    var s2 = _v3.b;
                    return $author$project$ParserFast$Good_fn(func({
                        cm: { bk: s2.a, bz: s2.bz },
                        bE: { bk: s0.a, bz: s0.bz }
                    }, a, b), s2);
                }
            }
        };
    }, $author$project$ParserFast$map2WithRange = F3($author$project$ParserFast$map2WithRange_fn);
    var $elm$core$Basics$neq = _Utils_notEqual;
    var $elm$core$Basics$not = _Basics_not;
    var $author$project$ParserFast$ExpectingOneOf_fn = function (a, b, c) {
        return { $: 7, a: a, b: b, c: c };
    }, $author$project$ParserFast$ExpectingOneOf = F3($author$project$ParserFast$ExpectingOneOf_fn);
    var $author$project$ParserFast$oneOf2_fn = function (_v0, _v1) {
        var attemptFirst = _v0;
        var attemptSecond = _v1;
        return function (s) {
            var _v2 = attemptFirst(s);
            if (!_v2.$) {
                var firstGood = _v2;
                return firstGood;
            }
            else {
                var firstBad = _v2;
                var firstCommitted = firstBad.a;
                var firstX = firstBad.b;
                if (firstCommitted) {
                    return firstBad;
                }
                else {
                    var _v3 = attemptSecond(s);
                    if (!_v3.$) {
                        var secondGood = _v3;
                        return secondGood;
                    }
                    else {
                        var secondBad = _v3;
                        var secondCommitted = secondBad.a;
                        var secondX = secondBad.b;
                        return secondCommitted ? secondBad : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingOneOf_fn(firstX, secondX, _List_Nil));
                    }
                }
            }
        };
    }, $author$project$ParserFast$oneOf2 = F2($author$project$ParserFast$oneOf2_fn);
    var $author$project$ParserFast$oneOf3_fn = function (_v0, _v1, _v2) {
        var attemptFirst = _v0;
        var attemptSecond = _v1;
        var attemptThird = _v2;
        return function (s) {
            var _v3 = attemptFirst(s);
            if (!_v3.$) {
                var firstGood = _v3;
                return firstGood;
            }
            else {
                var firstBad = _v3;
                var firstCommitted = firstBad.a;
                var firstX = firstBad.b;
                if (firstCommitted) {
                    return firstBad;
                }
                else {
                    var _v4 = attemptSecond(s);
                    if (!_v4.$) {
                        var secondGood = _v4;
                        return secondGood;
                    }
                    else {
                        var secondBad = _v4;
                        var secondCommitted = secondBad.a;
                        var secondX = secondBad.b;
                        if (secondCommitted) {
                            return secondBad;
                        }
                        else {
                            var _v5 = attemptThird(s);
                            if (!_v5.$) {
                                var thirdGood = _v5;
                                return thirdGood;
                            }
                            else {
                                var thirdBad = _v5;
                                var thirdCommitted = thirdBad.a;
                                var thirdX = thirdBad.b;
                                return thirdCommitted ? thirdBad : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingOneOf_fn(firstX, secondX, _List_fromArray([thirdX])));
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$oneOf3 = F3($author$project$ParserFast$oneOf3_fn);
    var $author$project$ParserFast$ExpectingSymbol_fn = function (a, b, c) {
        return { $: 1, a: a, b: b, c: c };
    }, $author$project$ParserFast$ExpectingSymbol = F3($author$project$ParserFast$ExpectingSymbol_fn);
    var $author$project$ParserFast$symbol_fn = function (str, res) {
        var strLength = $elm$core$String$length(str);
        return function (s) {
            var newOffset = s.b + strLength;
            return _Utils_eq(_String_slice_fn(s.b, newOffset, s.c), str + "") ? $author$project$ParserFast$Good_fn(res, { a: s.a + strLength, f: s.f, b: newOffset, bz: s.bz, c: s.c }) : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingSymbol_fn(s.bz, s.a, str));
        };
    }, $author$project$ParserFast$symbol = F2($author$project$ParserFast$symbol_fn);
    var $author$project$ParserFast$pStepCommit = function (pStep) {
        if (!pStep.$) {
            var good = pStep;
            return good;
        }
        else {
            var x = pStep.b;
            return $author$project$ParserFast$Bad_fn(true, x);
        }
    };
    var $author$project$ParserFast$symbolFollowedBy_fn = function (str, _v0) {
        var parseNext = _v0;
        var strLength = $elm$core$String$length(str);
        return function (s) {
            var newOffset = s.b + strLength;
            return _Utils_eq(_String_slice_fn(s.b, newOffset, s.c), str + "") ? $author$project$ParserFast$pStepCommit(parseNext({ a: s.a + strLength, f: s.f, b: newOffset, bz: s.bz, c: s.c })) : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingSymbol_fn(s.bz, s.a, str));
        };
    }, $author$project$ParserFast$symbolFollowedBy = F2($author$project$ParserFast$symbolFollowedBy_fn);
    var $author$project$ParserFast$while = function (isGood) {
        return function (s0) {
            var s1 = $author$project$ParserFast$skipWhileHelp_fn(isGood, s0.b, s0.bz, s0.a, s0.c, s0.f);
            return $author$project$ParserFast$Good_fn(_String_slice_fn(s0.b, s1.b, s0.c), s1);
        };
    };
    var $author$project$ParserFast$nestableMultiCommentMapWithRange_fn = function (rangeContentToRes, _v0, _v1) {
        var openChar = _v0.a;
        var openTail = _v0.b;
        var closeChar = _v1.a;
        var closeTail = _v1.b;
        var open = _String_cons_fn(openChar, openTail);
        var isNotRelevant = function (_char) {
            return (!_Utils_eq(_char, openChar)) && ((!_Utils_eq(_char, closeChar)) && (!$author$project$Char$Extra$isUtf16Surrogate(_char)));
        };
        var close = _String_cons_fn(closeChar, closeTail);
        return $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, afterOpen, contentAfterAfterOpen) {
            return A2(rangeContentToRes, range, _Utils_ap(open, _Utils_ap(afterOpen, _Utils_ap(contentAfterAfterOpen, close))));
        }, $author$project$ParserFast$symbolFollowedBy_fn(open, $author$project$ParserFast$while(isNotRelevant)), $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbol_fn(close, ""), $author$project$ParserFast$loop_fn(_Utils_Tuple2("", 1), $author$project$ParserFast$oneOf3_fn($author$project$ParserFast$symbol_fn(close, _Utils_Tuple2(close, -1)), $author$project$ParserFast$symbol_fn(open, _Utils_Tuple2(open, 1)), $author$project$ParserFast$anyCharFollowedByWhileMap_fn(function (consumed) {
            return _Utils_Tuple2(consumed, 0);
        }, isNotRelevant)), F2(function (_v2, _v3) {
            var toAppend = _v2.a;
            var nestingChange = _v2.b;
            var soFarContent = _v3.a;
            var soFarNesting = _v3.b;
            var newNesting = soFarNesting + nestingChange;
            return (!newNesting) ? $author$project$ParserFast$Done(soFarContent) : $author$project$ParserFast$Loop(_Utils_Tuple2(soFarContent + (toAppend + ""), newNesting));
        }))));
    }, $author$project$ParserFast$nestableMultiCommentMapWithRange_fn_unwrapped = function (rangeContentToRes, _v0, _v1) {
        var openChar = _v0.a;
        var openTail = _v0.b;
        var closeChar = _v1.a;
        var closeTail = _v1.b;
        var open = _String_cons_fn(openChar, openTail);
        var isNotRelevant = function (_char) {
            return (!_Utils_eq(_char, openChar)) && ((!_Utils_eq(_char, closeChar)) && (!$author$project$Char$Extra$isUtf16Surrogate(_char)));
        };
        var close = _String_cons_fn(closeChar, closeTail);
        return $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, afterOpen, contentAfterAfterOpen) {
            return rangeContentToRes(range, _Utils_ap(open, _Utils_ap(afterOpen, _Utils_ap(contentAfterAfterOpen, close))));
        }, $author$project$ParserFast$symbolFollowedBy_fn(open, $author$project$ParserFast$while(isNotRelevant)), $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbol_fn(close, ""), $author$project$ParserFast$loop_fn(_Utils_Tuple2("", 1), $author$project$ParserFast$oneOf3_fn($author$project$ParserFast$symbol_fn(close, _Utils_Tuple2(close, -1)), $author$project$ParserFast$symbol_fn(open, _Utils_Tuple2(open, 1)), $author$project$ParserFast$anyCharFollowedByWhileMap_fn(function (consumed) {
            return _Utils_Tuple2(consumed, 0);
        }, isNotRelevant)), F2(function (_v2, _v3) {
            var toAppend = _v2.a;
            var nestingChange = _v2.b;
            var soFarContent = _v3.a;
            var soFarNesting = _v3.b;
            var newNesting = soFarNesting + nestingChange;
            return (!newNesting) ? $author$project$ParserFast$Done(soFarContent) : $author$project$ParserFast$Loop(_Utils_Tuple2(soFarContent + (toAppend + ""), newNesting));
        }))));
    }, $author$project$ParserFast$nestableMultiCommentMapWithRange = F3($author$project$ParserFast$nestableMultiCommentMapWithRange_fn);
    var $author$project$Elm$Parser$Comments$multiLineCommentNoCheck = $author$project$ParserFast$nestableMultiCommentMapWithRange_fn($author$project$Elm$Syntax$Node$Node, _Utils_Tuple2("{", "-"), _Utils_Tuple2("-", "}"));
    var $author$project$Elm$Parser$Comments$declarationDocumentation = $author$project$Elm$Parser$Comments$multiLineCommentNoCheck;
    var $author$project$Rope$Branch2_fn = function (a, b) {
        return { $: 1, a: a, b: b };
    }, $author$project$Rope$Branch2 = F2($author$project$Rope$Branch2_fn);
    var $author$project$Rope$filledPrependTo_fn = function (right, leftLikelyFilled) {
        if (right.$ === 1) {
            return $elm$core$Maybe$Just(leftLikelyFilled);
        }
        else {
            var rightLikelyFilled = right.a;
            return $elm$core$Maybe$Just($author$project$Rope$Branch2_fn(leftLikelyFilled, rightLikelyFilled));
        }
    }, $author$project$Rope$filledPrependTo = F2($author$project$Rope$filledPrependTo_fn);
    var $author$project$Elm$Parser$Declarations$FunctionDeclarationAfterDocumentation = function (a) {
        return { $: 0, a: a };
    };
    var $author$project$Elm$Syntax$Expression$Application = function (a) {
        return { $: 1, a: a };
    };
    var $author$project$Elm$Syntax$Expression$CaseExpression = function (a) {
        return { $: 16, a: a };
    };
    var $author$project$Elm$Parser$Expression$ExtendRightByOperation = $elm$core$Basics$identity;
    var $author$project$Elm$Parser$Expression$FieldsFirstValue = function (a) {
        return { $: 1, a: a };
    };
    var $author$project$Elm$Syntax$Expression$IfBlock_fn = function (a, b, c) {
        return { $: 4, a: a, b: b, c: c };
    }, $author$project$Elm$Syntax$Expression$IfBlock = F3($author$project$Elm$Syntax$Expression$IfBlock_fn);
    var $author$project$Elm$Syntax$Expression$LambdaExpression = function (a) {
        return { $: 17, a: a };
    };
    var $author$project$Elm$Syntax$Infix$Left = 0;
    var $author$project$Elm$Syntax$Expression$LetDestructuring_fn = function (a, b) {
        return { $: 1, a: a, b: b };
    }, $author$project$Elm$Syntax$Expression$LetDestructuring = F2($author$project$Elm$Syntax$Expression$LetDestructuring_fn);
    var $author$project$Elm$Syntax$Expression$LetExpression = function (a) {
        return { $: 15, a: a };
    };
    var $author$project$Elm$Syntax$Expression$LetFunction = function (a) {
        return { $: 0, a: a };
    };
    var $author$project$Elm$Syntax$Expression$ListExpr = function (a) {
        return { $: 19, a: a };
    };
    var $author$project$Elm$Syntax$Expression$Negation = function (a) {
        return { $: 10, a: a };
    };
    var $author$project$Elm$Syntax$Infix$Non = 2;
    var $author$project$Elm$Syntax$Expression$ParenthesizedExpression = function (a) {
        return { $: 14, a: a };
    };
    var $author$project$Elm$Syntax$Expression$RecordExpr = function (a) {
        return { $: 18, a: a };
    };
    var $author$project$Elm$Syntax$Expression$RecordUpdateExpression_fn = function (a, b) {
        return { $: 22, a: a, b: b };
    }, $author$project$Elm$Syntax$Expression$RecordUpdateExpression = F2($author$project$Elm$Syntax$Expression$RecordUpdateExpression_fn);
    var $author$project$Elm$Parser$Expression$RecordUpdateFirstSetter = function (a) {
        return { $: 0, a: a };
    };
    var $author$project$Elm$Syntax$Infix$Right = 1;
    var $author$project$Elm$Syntax$Expression$TupledExpression = function (a) {
        return { $: 13, a: a };
    };
    var $author$project$Elm$Parser$Expression$TupledParenthesized_fn = function (a, b) {
        return { $: 0, a: a, b: b };
    }, $author$project$Elm$Parser$Expression$TupledParenthesized = F2($author$project$Elm$Parser$Expression$TupledParenthesized_fn);
    var $author$project$Elm$Parser$Expression$TupledTwoOrThree_fn = function (a, b) {
        return { $: 1, a: a, b: b };
    }, $author$project$Elm$Parser$Expression$TupledTwoOrThree = F2($author$project$Elm$Parser$Expression$TupledTwoOrThree_fn);
    var $author$project$Elm$Syntax$Expression$UnitExpr = { $: 0 };
    var $author$project$Elm$Syntax$Expression$PrefixOperator = function (a) {
        return { $: 5, a: a };
    };
    var $author$project$Elm$Parser$Tokens$isAllowedOperatorToken = function (operatorCandidateToValidate) {
        switch (operatorCandidateToValidate) {
            case "==":
                return true;
            case "/=":
                return true;
            case "::":
                return true;
            case "++":
                return true;
            case "+":
                return true;
            case "*":
                return true;
            case "<|":
                return true;
            case "|>":
                return true;
            case "||":
                return true;
            case "<=":
                return true;
            case ">=":
                return true;
            case "|=":
                return true;
            case "|.":
                return true;
            case "//":
                return true;
            case "</>":
                return true;
            case "<?>":
                return true;
            case "^":
                return true;
            case "<<":
                return true;
            case ">>":
                return true;
            case "<":
                return true;
            case ">":
                return true;
            case "/":
                return true;
            case "&&":
                return true;
            case "-":
                return true;
            default:
                return false;
        }
    };
    var $author$project$Elm$Parser$Tokens$isOperatorSymbolCharAsString = function (c) {
        switch (c) {
            case "|":
                return true;
            case "+":
                return true;
            case "<":
                return true;
            case ">":
                return true;
            case "=":
                return true;
            case "*":
                return true;
            case ":":
                return true;
            case "-":
                return true;
            case "/":
                return true;
            case "&":
                return true;
            case ".":
                return true;
            case "?":
                return true;
            case "^":
                return true;
            default:
                return false;
        }
    };
    var $author$project$ParserFast$ExpectingStringSatisfyingPredicate_fn = function (a, b) {
        return { $: 5, a: a, b: b };
    }, $author$project$ParserFast$ExpectingStringSatisfyingPredicate = F2($author$project$ParserFast$ExpectingStringSatisfyingPredicate_fn);
    var $author$project$ParserFast$whileAtMost3WithoutLinebreakAnd2PartUtf16ValidateMapWithRangeBacktrackableFollowedBySymbol_fn = function (whileRangeAndContentToRes, whileCharIsOkay, whileResultIsOkay, mandatoryFinalSymbol) {
        var mandatoryFinalSymbolLength = $elm$core$String$length(mandatoryFinalSymbol);
        return function (s0) {
            var src = s0.c;
            var s0Offset = s0.b;
            var _v0 = whileCharIsOkay(_String_slice_fn(s0Offset, s0Offset + 1, src)) ? (whileCharIsOkay(_String_slice_fn(s0Offset + 1, s0Offset + 2, src)) ? (whileCharIsOkay(_String_slice_fn(s0Offset + 2, s0Offset + 3, src)) ? _Utils_Tuple2(3, _String_slice_fn(s0Offset, s0Offset + 3, src)) : _Utils_Tuple2(2, _String_slice_fn(s0Offset, s0Offset + 2, src))) : _Utils_Tuple2(1, _String_slice_fn(s0Offset, s0Offset + 1, src))) : _Utils_Tuple2(0, "");
            var consumedBeforeFinalSymbolLength = _v0.a;
            var consumedBeforeFinalSymbolString = _v0.b;
            return (_Utils_eq(_String_slice_fn(s0Offset + consumedBeforeFinalSymbolLength, (s0Offset + consumedBeforeFinalSymbolLength) + mandatoryFinalSymbolLength, src), mandatoryFinalSymbol + "") && whileResultIsOkay(consumedBeforeFinalSymbolString)) ? $author$project$ParserFast$Good_fn(A2(whileRangeAndContentToRes, {
                cm: { bk: s0.a + consumedBeforeFinalSymbolLength, bz: s0.bz },
                bE: { bk: s0.a, bz: s0.bz }
            }, consumedBeforeFinalSymbolString), { a: (s0.a + consumedBeforeFinalSymbolLength) + mandatoryFinalSymbolLength, f: s0.f, b: (s0Offset + consumedBeforeFinalSymbolLength) + mandatoryFinalSymbolLength, bz: s0.bz, c: src }) : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingStringSatisfyingPredicate_fn(s0.bz, s0.a));
        };
    }, $author$project$ParserFast$whileAtMost3WithoutLinebreakAnd2PartUtf16ValidateMapWithRangeBacktrackableFollowedBySymbol_fn_unwrapped = function (whileRangeAndContentToRes, whileCharIsOkay, whileResultIsOkay, mandatoryFinalSymbol) {
        var mandatoryFinalSymbolLength = $elm$core$String$length(mandatoryFinalSymbol);
        return function (s0) {
            var src = s0.c;
            var s0Offset = s0.b;
            var _v0 = whileCharIsOkay(_String_slice_fn(s0Offset, s0Offset + 1, src)) ? (whileCharIsOkay(_String_slice_fn(s0Offset + 1, s0Offset + 2, src)) ? (whileCharIsOkay(_String_slice_fn(s0Offset + 2, s0Offset + 3, src)) ? _Utils_Tuple2(3, _String_slice_fn(s0Offset, s0Offset + 3, src)) : _Utils_Tuple2(2, _String_slice_fn(s0Offset, s0Offset + 2, src))) : _Utils_Tuple2(1, _String_slice_fn(s0Offset, s0Offset + 1, src))) : _Utils_Tuple2(0, "");
            var consumedBeforeFinalSymbolLength = _v0.a;
            var consumedBeforeFinalSymbolString = _v0.b;
            return (_Utils_eq(_String_slice_fn(s0Offset + consumedBeforeFinalSymbolLength, (s0Offset + consumedBeforeFinalSymbolLength) + mandatoryFinalSymbolLength, src), mandatoryFinalSymbol + "") && whileResultIsOkay(consumedBeforeFinalSymbolString)) ? $author$project$ParserFast$Good_fn(whileRangeAndContentToRes({
                cm: { bk: s0.a + consumedBeforeFinalSymbolLength, bz: s0.bz },
                bE: { bk: s0.a, bz: s0.bz }
            }, consumedBeforeFinalSymbolString), { a: (s0.a + consumedBeforeFinalSymbolLength) + mandatoryFinalSymbolLength, f: s0.f, b: (s0Offset + consumedBeforeFinalSymbolLength) + mandatoryFinalSymbolLength, bz: s0.bz, c: src }) : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingStringSatisfyingPredicate_fn(s0.bz, s0.a));
        };
    }, $author$project$ParserFast$whileAtMost3WithoutLinebreakAnd2PartUtf16ValidateMapWithRangeBacktrackableFollowedBySymbol = F4($author$project$ParserFast$whileAtMost3WithoutLinebreakAnd2PartUtf16ValidateMapWithRangeBacktrackableFollowedBySymbol_fn);
    var $author$project$Elm$Parser$Expression$allowedPrefixOperatorFollowedByClosingParensOneOf = $author$project$ParserFast$whileAtMost3WithoutLinebreakAnd2PartUtf16ValidateMapWithRangeBacktrackableFollowedBySymbol_fn_unwrapped(function (operatorRange, operator) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn({
                cm: { bk: operatorRange.cm.bk + 1, bz: operatorRange.cm.bz },
                bE: { bk: operatorRange.bE.bk - 1, bz: operatorRange.bE.bz }
            }, $author$project$Elm$Syntax$Expression$PrefixOperator(operator))
        };
    }, $author$project$Elm$Parser$Tokens$isOperatorSymbolCharAsString, $author$project$Elm$Parser$Tokens$isAllowedOperatorToken, ")");
    var $author$project$Elm$Syntax$Expression$OperatorApplication_fn = function (a, b, c, d) {
        return { $: 2, a: a, b: b, c: c, d: d };
    }, $author$project$Elm$Syntax$Expression$OperatorApplication = F4($author$project$Elm$Syntax$Expression$OperatorApplication_fn);
    var $author$project$Elm$Parser$Expression$applyExtensionRight_fn = function (_v0, leftNode) {
        var operation = _v0;
        var leftRange = leftNode.a;
        var rightExpressionNode = operation.V;
        var rightExpressionRange = rightExpressionNode.a;
        return $author$project$Elm$Syntax$Node$Node_fn({ cm: rightExpressionRange.cm, bE: leftRange.bE }, $author$project$Elm$Syntax$Expression$OperatorApplication_fn(operation.T, operation.d6, leftNode, rightExpressionNode));
    }, $author$project$Elm$Parser$Expression$applyExtensionRight = F2($author$project$Elm$Parser$Expression$applyExtensionRight_fn);
    var $author$project$Elm$Syntax$Expression$CharLiteral = function (a) {
        return { $: 12, a: a };
    };
    var $elm$core$String$foldr = _String_foldr;
    var $elm$core$String$toList = function (string) {
        return _String_foldr_fn($elm$core$List$cons, _List_Nil, string);
    };
    var $author$project$ParserFast$anyChar = function (s) {
        var newOffset = $author$project$ParserFast$charOrEnd_fn(s.b, s.c);
        if (newOffset === -1) {
            return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingAnyChar_fn(s.bz, s.a));
        }
        else {
            if (newOffset === -2) {
                return $author$project$ParserFast$Good_fn("\n", { a: 1, f: s.f, b: s.b + 1, bz: s.bz + 1, c: s.c });
            }
            else {
                var _v0 = $elm$core$String$toList(_String_slice_fn(s.b, newOffset, s.c));
                if (!_v0.b) {
                    return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingAnyChar_fn(s.bz, s.a));
                }
                else {
                    var c = _v0.a;
                    return $author$project$ParserFast$Good_fn(c, { a: s.a + 1, f: s.f, b: newOffset, bz: s.bz, c: s.c });
                }
            }
        }
    };
    var $author$project$ParserFast$followedBySymbol_fn = function (str, _v0) {
        var parsePrevious = _v0;
        var strLength = $elm$core$String$length(str);
        return function (s0) {
            var _v1 = parsePrevious(s0);
            if (!_v1.$) {
                var res = _v1.a;
                var s1 = _v1.b;
                var newOffset = s1.b + strLength;
                return _Utils_eq(_String_slice_fn(s1.b, newOffset, s1.c), str + "") ? $author$project$ParserFast$Good_fn(res, { a: s1.a + strLength, f: s1.f, b: newOffset, bz: s1.bz, c: s1.c }) : $author$project$ParserFast$Bad_fn(true, $author$project$ParserFast$ExpectingSymbol_fn(s1.bz, s1.a, str));
            }
            else {
                var bad = _v1;
                return bad;
            }
        };
    }, $author$project$ParserFast$followedBySymbol = F2($author$project$ParserFast$followedBySymbol_fn);
    var $elm$core$Char$fromCode = _Char_fromCode;
    var $author$project$Elm$Parser$Tokens$charToHex = function (c) {
        switch (c) {
            case "0":
                return 0;
            case "1":
                return 1;
            case "2":
                return 2;
            case "3":
                return 3;
            case "4":
                return 4;
            case "5":
                return 5;
            case "6":
                return 6;
            case "7":
                return 7;
            case "8":
                return 8;
            case "9":
                return 9;
            case "a":
                return 10;
            case "b":
                return 11;
            case "c":
                return 12;
            case "d":
                return 13;
            case "e":
                return 14;
            case "f":
                return 15;
            case "A":
                return 10;
            case "B":
                return 11;
            case "C":
                return 12;
            case "D":
                return 13;
            case "E":
                return 14;
            default:
                return 15;
        }
    };
    var $elm$core$Basics$pow = _Basics_pow;
    var $author$project$Elm$Parser$Tokens$hexStringToInt = function (string) {
        return _String_foldr_fn_unwrapped(function (c, soFar) {
            return {
                bq: soFar.bq + 1,
                by: soFar.by + (_Basics_pow_fn(16, soFar.bq) * $author$project$Elm$Parser$Tokens$charToHex(c))
            };
        }, { bq: 0, by: 0 }, string).by;
    };
    var $author$project$ParserFast$ExpectingCharSatisfyingPredicate_fn = function (a, b) {
        return { $: 4, a: a, b: b };
    }, $author$project$ParserFast$ExpectingCharSatisfyingPredicate = F2($author$project$ParserFast$ExpectingCharSatisfyingPredicate_fn);
    var $author$project$ParserFast$isSubCharWithoutLinebreak_fn = function (predicate, offset, string) {
        var actualChar = _String_slice_fn(offset, offset + 1, string);
        return _String_any_fn(predicate, actualChar) ? (offset + 1) : (($author$project$ParserFast$charStringIsUtf16HighSurrogate(actualChar) && _String_any_fn(predicate, _String_slice_fn(offset, offset + 2, string))) ? (offset + 2) : (-1));
    }, $author$project$ParserFast$isSubCharWithoutLinebreak = F3($author$project$ParserFast$isSubCharWithoutLinebreak_fn);
    var $author$project$ParserFast$skipWhileWithoutLinebreakHelp_fn = function (isGood, offset, row, col, src, indent) {
        skipWhileWithoutLinebreakHelp: while (true) {
            var actualChar = _String_slice_fn(offset, offset + 1, src);
            if (_String_any_fn(isGood, actualChar)) {
                var $temp$isGood = isGood, $temp$offset = offset + 1, $temp$row = row, $temp$col = col + 1, $temp$src = src, $temp$indent = indent;
                isGood = $temp$isGood;
                offset = $temp$offset;
                row = $temp$row;
                col = $temp$col;
                src = $temp$src;
                indent = $temp$indent;
                continue skipWhileWithoutLinebreakHelp;
            }
            else {
                if ($author$project$ParserFast$charStringIsUtf16HighSurrogate(actualChar) && _String_any_fn(isGood, _String_slice_fn(offset, offset + 2, src))) {
                    var $temp$isGood = isGood, $temp$offset = offset + 2, $temp$row = row, $temp$col = col + 1, $temp$src = src, $temp$indent = indent;
                    isGood = $temp$isGood;
                    offset = $temp$offset;
                    row = $temp$row;
                    col = $temp$col;
                    src = $temp$src;
                    indent = $temp$indent;
                    continue skipWhileWithoutLinebreakHelp;
                }
                else {
                    return { a: col, f: indent, b: offset, bz: row, c: src };
                }
            }
        }
    }, $author$project$ParserFast$skipWhileWithoutLinebreakHelp = F6($author$project$ParserFast$skipWhileWithoutLinebreakHelp_fn);
    var $author$project$ParserFast$ifFollowedByWhileMapWithoutLinebreak_fn = function (consumedStringToRes, firstIsOkay, afterFirstIsOkay) {
        return function (s0) {
            var firstOffset = $author$project$ParserFast$isSubCharWithoutLinebreak_fn(firstIsOkay, s0.b, s0.c);
            if (firstOffset === -1) {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingCharSatisfyingPredicate_fn(s0.bz, s0.a));
            }
            else {
                var s1 = $author$project$ParserFast$skipWhileWithoutLinebreakHelp_fn(afterFirstIsOkay, firstOffset, s0.bz, s0.a + 1, s0.c, s0.f);
                return $author$project$ParserFast$Good_fn(consumedStringToRes(_String_slice_fn(s0.b, s1.b, s0.c)), s1);
            }
        };
    }, $author$project$ParserFast$ifFollowedByWhileMapWithoutLinebreak = F3($author$project$ParserFast$ifFollowedByWhileMapWithoutLinebreak_fn);
    var $elm$core$Char$isHexDigit = function (_char) {
        var code = $elm$core$Char$toCode(_char);
        return ((48 <= code) && (code <= 57)) || (((65 <= code) && (code <= 70)) || ((97 <= code) && (code <= 102)));
    };
    var $author$project$ParserFast$oneOf7_fn = function (_v0, _v1, _v2, _v3, _v4, _v5, _v6) {
        var attempt0 = _v0;
        var attempt1 = _v1;
        var attempt2 = _v2;
        var attempt3 = _v3;
        var attempt4 = _v4;
        var attempt5 = _v5;
        var attempt6 = _v6;
        return function (s) {
            var _v7 = attempt0(s);
            if (!_v7.$) {
                var good = _v7;
                return good;
            }
            else {
                var bad0 = _v7;
                var committed0 = bad0.a;
                var x0 = bad0.b;
                if (committed0) {
                    return bad0;
                }
                else {
                    var _v8 = attempt1(s);
                    if (!_v8.$) {
                        var good = _v8;
                        return good;
                    }
                    else {
                        var bad1 = _v8;
                        var committed1 = bad1.a;
                        var x1 = bad1.b;
                        if (committed1) {
                            return bad1;
                        }
                        else {
                            var _v9 = attempt2(s);
                            if (!_v9.$) {
                                var good = _v9;
                                return good;
                            }
                            else {
                                var bad2 = _v9;
                                var committed2 = bad2.a;
                                var x2 = bad2.b;
                                if (committed2) {
                                    return bad2;
                                }
                                else {
                                    var _v10 = attempt3(s);
                                    if (!_v10.$) {
                                        var good = _v10;
                                        return good;
                                    }
                                    else {
                                        var bad3 = _v10;
                                        var committed3 = bad3.a;
                                        var x3 = bad3.b;
                                        if (committed3) {
                                            return bad3;
                                        }
                                        else {
                                            var _v11 = attempt4(s);
                                            if (!_v11.$) {
                                                var good = _v11;
                                                return good;
                                            }
                                            else {
                                                var bad4 = _v11;
                                                var committed4 = bad4.a;
                                                var x4 = bad4.b;
                                                if (committed4) {
                                                    return bad4;
                                                }
                                                else {
                                                    var _v12 = attempt5(s);
                                                    if (!_v12.$) {
                                                        var good = _v12;
                                                        return good;
                                                    }
                                                    else {
                                                        var bad5 = _v12;
                                                        var committed5 = bad5.a;
                                                        var x5 = bad5.b;
                                                        if (committed5) {
                                                            return bad5;
                                                        }
                                                        else {
                                                            var _v13 = attempt6(s);
                                                            if (!_v13.$) {
                                                                var good = _v13;
                                                                return good;
                                                            }
                                                            else {
                                                                var bad6 = _v13;
                                                                var committed6 = bad6.a;
                                                                var x6 = bad6.b;
                                                                return committed6 ? bad6 : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingOneOf_fn(x0, x1, _List_fromArray([x2, x3, x4, x5, x6])));
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$oneOf7 = F7($author$project$ParserFast$oneOf7_fn);
    var $author$project$Elm$Parser$Tokens$escapedCharValueMap = function (charToRes) {
        return $author$project$ParserFast$oneOf7_fn($author$project$ParserFast$symbol_fn("'", charToRes("'")), $author$project$ParserFast$symbol_fn("\"", charToRes("\"")), $author$project$ParserFast$symbol_fn("n", charToRes("\n")), $author$project$ParserFast$symbol_fn("t", charToRes("\t")), $author$project$ParserFast$symbol_fn("r", charToRes("\r")), $author$project$ParserFast$symbol_fn("\\", charToRes("\\")), $author$project$ParserFast$symbolFollowedBy_fn("u{", $author$project$ParserFast$followedBySymbol_fn("}", $author$project$ParserFast$ifFollowedByWhileMapWithoutLinebreak_fn(function (hex) {
            return charToRes($elm$core$Char$fromCode($author$project$Elm$Parser$Tokens$hexStringToInt(hex)));
        }, $elm$core$Char$isHexDigit, $elm$core$Char$isHexDigit))));
    };
    var $author$project$ParserFast$oneOf2MapWithStartRowColumnAndEndRowColumn_fn = function (firstToChoice, _v0, secondToChoice, _v1) {
        var attemptFirst = _v0;
        var attemptSecond = _v1;
        return function (s) {
            var _v2 = attemptFirst(s);
            if (!_v2.$) {
                var first = _v2.a;
                var s1 = _v2.b;
                return $author$project$ParserFast$Good_fn(A5(firstToChoice, s.bz, s.a, first, s1.bz, s1.a), s1);
            }
            else {
                var firstCommitted = _v2.a;
                var firstX = _v2.b;
                if (firstCommitted) {
                    return $author$project$ParserFast$Bad_fn(firstCommitted, firstX);
                }
                else {
                    var _v3 = attemptSecond(s);
                    if (!_v3.$) {
                        var second = _v3.a;
                        var s1 = _v3.b;
                        return $author$project$ParserFast$Good_fn(A5(secondToChoice, s.bz, s.a, second, s1.bz, s1.a), s1);
                    }
                    else {
                        var secondCommitted = _v3.a;
                        var secondX = _v3.b;
                        return secondCommitted ? $author$project$ParserFast$Bad_fn(secondCommitted, secondX) : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingOneOf_fn(firstX, secondX, _List_Nil));
                    }
                }
            }
        };
    }, $author$project$ParserFast$oneOf2MapWithStartRowColumnAndEndRowColumn = F4($author$project$ParserFast$oneOf2MapWithStartRowColumnAndEndRowColumn_fn);
    var $author$project$Elm$Parser$Tokens$characterLiteralMapWithRange = function (rangeAndCharToRes) {
        return $author$project$ParserFast$symbolFollowedBy_fn("'", $author$project$ParserFast$followedBySymbol_fn("'", $author$project$ParserFast$oneOf2MapWithStartRowColumnAndEndRowColumn_fn(F5(function (startRow, startColumn, _char, endRow, endColumn) {
            return A2(rangeAndCharToRes, {
                cm: { bk: endColumn + 1, bz: endRow },
                bE: { bk: startColumn - 1, bz: startRow }
            }, _char);
        }), $author$project$ParserFast$symbolFollowedBy_fn("\\", $author$project$Elm$Parser$Tokens$escapedCharValueMap($elm$core$Basics$identity)), F5(function (startRow, startColumn, _char, endRow, endColumn) {
            return A2(rangeAndCharToRes, {
                cm: { bk: endColumn + 1, bz: endRow },
                bE: { bk: startColumn - 1, bz: startRow }
            }, _char);
        }), $author$project$ParserFast$anyChar)));
    }, $author$project$Elm$Parser$Tokens$characterLiteralMapWithRange_unwrapped = function (rangeAndCharToRes) {
        return $author$project$ParserFast$symbolFollowedBy_fn("'", $author$project$ParserFast$followedBySymbol_fn("'", $author$project$ParserFast$oneOf2MapWithStartRowColumnAndEndRowColumn_fn(F5(function (startRow, startColumn, _char, endRow, endColumn) {
            return rangeAndCharToRes({
                cm: { bk: endColumn + 1, bz: endRow },
                bE: { bk: startColumn - 1, bz: startRow }
            }, _char);
        }), $author$project$ParserFast$symbolFollowedBy_fn("\\", $author$project$Elm$Parser$Tokens$escapedCharValueMap($elm$core$Basics$identity)), F5(function (startRow, startColumn, _char, endRow, endColumn) {
            return rangeAndCharToRes({
                cm: { bk: endColumn + 1, bz: endRow },
                bE: { bk: startColumn - 1, bz: startRow }
            }, _char);
        }), $author$project$ParserFast$anyChar)));
    };
    var $author$project$Elm$Parser$Expression$charLiteralExpression = $author$project$Elm$Parser$Tokens$characterLiteralMapWithRange_unwrapped(function (range, _char) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Expression$CharLiteral(_char))
        };
    });
    var $author$project$ParserFast$map2_fn = function (func, _v0, _v1) {
        var parseA = _v0;
        var parseB = _v1;
        return function (s0) {
            var _v2 = parseA(s0);
            if (_v2.$ === 1) {
                var committed = _v2.a;
                var x = _v2.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v2.a;
                var s1 = _v2.b;
                var _v3 = parseB(s1);
                if (_v3.$ === 1) {
                    var x = _v3.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v3.a;
                    var s2 = _v3.b;
                    return $author$project$ParserFast$Good_fn(A2(func, a, b), s2);
                }
            }
        };
    }, $author$project$ParserFast$map2_fn_unwrapped = function (func, _v0, _v1) {
        var parseA = _v0;
        var parseB = _v1;
        return function (s0) {
            var _v2 = parseA(s0);
            if (_v2.$ === 1) {
                var committed = _v2.a;
                var x = _v2.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v2.a;
                var s1 = _v2.b;
                var _v3 = parseB(s1);
                if (_v3.$ === 1) {
                    var x = _v3.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v3.a;
                    var s2 = _v3.b;
                    return $author$project$ParserFast$Good_fn(func(a, b), s2);
                }
            }
        };
    }, $author$project$ParserFast$map2 = F3($author$project$ParserFast$map2_fn);
    var $author$project$ParserFast$skipWhileWhitespaceHelp_fn = function (offset, row, col, src, indent) {
        skipWhileWhitespaceHelp: while (true) {
            var _v0 = _String_slice_fn(offset, offset + 1, src);
            switch (_v0) {
                case " ":
                    var $temp$offset = offset + 1, $temp$row = row, $temp$col = col + 1, $temp$src = src, $temp$indent = indent;
                    offset = $temp$offset;
                    row = $temp$row;
                    col = $temp$col;
                    src = $temp$src;
                    indent = $temp$indent;
                    continue skipWhileWhitespaceHelp;
                case "\n":
                    var $temp$offset = offset + 1, $temp$row = row + 1, $temp$col = 1, $temp$src = src, $temp$indent = indent;
                    offset = $temp$offset;
                    row = $temp$row;
                    col = $temp$col;
                    src = $temp$src;
                    indent = $temp$indent;
                    continue skipWhileWhitespaceHelp;
                case "\r":
                    var $temp$offset = offset + 1, $temp$row = row, $temp$col = col + 1, $temp$src = src, $temp$indent = indent;
                    offset = $temp$offset;
                    row = $temp$row;
                    col = $temp$col;
                    src = $temp$src;
                    indent = $temp$indent;
                    continue skipWhileWhitespaceHelp;
                default:
                    return { a: col, f: indent, b: offset, bz: row, c: src };
            }
        }
    }, $author$project$ParserFast$skipWhileWhitespaceHelp = F5($author$project$ParserFast$skipWhileWhitespaceHelp_fn);
    var $author$project$ParserFast$followedBySkipWhileWhitespace = function (_v0) {
        var parseBefore = _v0;
        return function (s0) {
            var _v1 = parseBefore(s0);
            if (!_v1.$) {
                var res = _v1.a;
                var s1 = _v1.b;
                var s2 = $author$project$ParserFast$skipWhileWhitespaceHelp_fn(s1.b, s1.bz, s1.a, s1.c, s1.f);
                return $author$project$ParserFast$Good_fn(res, s2);
            }
            else {
                var bad = _v1;
                return bad;
            }
        };
    };
    var $author$project$ParserFast$map2OrSucceed_fn = function (func, _v0, _v1, fallback) {
        var parseA = _v0;
        var parseB = _v1;
        return function (s0) {
            var _v2 = parseA(s0);
            if (_v2.$ === 1) {
                var c1 = _v2.a;
                var x = _v2.b;
                return c1 ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(fallback, s0);
            }
            else {
                var a = _v2.a;
                var s1 = _v2.b;
                var _v3 = parseB(s1);
                if (_v3.$ === 1) {
                    var x = _v3.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v3.a;
                    var s2 = _v3.b;
                    return $author$project$ParserFast$Good_fn(A2(func, a, b), s2);
                }
            }
        };
    }, $author$project$ParserFast$map2OrSucceed_fn_unwrapped = function (func, _v0, _v1, fallback) {
        var parseA = _v0;
        var parseB = _v1;
        return function (s0) {
            var _v2 = parseA(s0);
            if (_v2.$ === 1) {
                var c1 = _v2.a;
                var x = _v2.b;
                return c1 ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(fallback, s0);
            }
            else {
                var a = _v2.a;
                var s1 = _v2.b;
                var _v3 = parseB(s1);
                if (_v3.$ === 1) {
                    var x = _v3.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v3.a;
                    var s2 = _v3.b;
                    return $author$project$ParserFast$Good_fn(func(a, b), s2);
                }
            }
        };
    }, $author$project$ParserFast$map2OrSucceed = F4($author$project$ParserFast$map2OrSucceed_fn);
    var $author$project$ParserFast$offsetSourceAndThen = function (callback) {
        return function (s) {
            var _v0 = A2(callback, s.b, s.c);
            var parse = _v0;
            return parse(s);
        };
    }, $author$project$ParserFast$offsetSourceAndThen_unwrapped = function (callback) {
        return function (s) {
            var _v0 = callback(s.b, s.c);
            var parse = _v0;
            return parse(s);
        };
    };
    var $author$project$ParserFast$ExpectingCustom_fn = function (a, b, c) {
        return { $: 6, a: a, b: b, c: c };
    }, $author$project$ParserFast$ExpectingCustom = F3($author$project$ParserFast$ExpectingCustom_fn);
    var $author$project$ParserFast$problem = function (msg) {
        return function (s) {
            return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingCustom_fn(s.bz, s.a, msg));
        };
    };
    var $author$project$Elm$Parser$Comments$problemUnexpectedDocumentation = $author$project$ParserFast$problem("unexpected documentation comment");
    var $author$project$Elm$Parser$Comments$multilineComment = $author$project$ParserFast$offsetSourceAndThen_unwrapped(function (offset, source) {
        var _v0 = _String_slice_fn(offset + 2, offset + 3, source);
        if (_v0 === "|") {
            return $author$project$Elm$Parser$Comments$problemUnexpectedDocumentation;
        }
        else {
            return $author$project$Elm$Parser$Comments$multiLineCommentNoCheck;
        }
    });
    var $author$project$Rope$Leaf_fn = function (a, b) {
        return { $: 0, a: a, b: b };
    }, $author$project$Rope$Leaf = F2($author$project$Rope$Leaf_fn);
    var $author$project$Rope$one = function (onlyElement) {
        return $author$project$Rope$Leaf_fn(onlyElement, 0);
    };
    var $author$project$ParserFast$loopWhileSucceedsHelp_fn = function (element, soFar, reduce, foldedToRes, s0) {
        loopWhileSucceedsHelp: while (true) {
            var parseElement = element;
            var _v0 = parseElement(s0);
            if (!_v0.$) {
                var elementResult = _v0.a;
                var s1 = _v0.b;
                var $temp$element = element, $temp$soFar = A2(reduce, elementResult, soFar), $temp$reduce = reduce, $temp$foldedToRes = foldedToRes, $temp$s0 = s1;
                element = $temp$element;
                soFar = $temp$soFar;
                reduce = $temp$reduce;
                foldedToRes = $temp$foldedToRes;
                s0 = $temp$s0;
                continue loopWhileSucceedsHelp;
            }
            else {
                var elementCommitted = _v0.a;
                var x = _v0.b;
                return elementCommitted ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(foldedToRes(soFar), s0);
            }
        }
    }, $author$project$ParserFast$loopWhileSucceedsHelp_fn_unwrapped = function (element, soFar, reduce, foldedToRes, s0) {
        loopWhileSucceedsHelp: while (true) {
            var parseElement = element;
            var _v0 = parseElement(s0);
            if (!_v0.$) {
                var elementResult = _v0.a;
                var s1 = _v0.b;
                var $temp$element = element, $temp$soFar = reduce(elementResult, soFar), $temp$reduce = reduce, $temp$foldedToRes = foldedToRes, $temp$s0 = s1;
                element = $temp$element;
                soFar = $temp$soFar;
                reduce = $temp$reduce;
                foldedToRes = $temp$foldedToRes;
                s0 = $temp$s0;
                continue loopWhileSucceedsHelp;
            }
            else {
                var elementCommitted = _v0.a;
                var x = _v0.b;
                return elementCommitted ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(foldedToRes(soFar), s0);
            }
        }
    }, $author$project$ParserFast$loopWhileSucceedsHelp = F5($author$project$ParserFast$loopWhileSucceedsHelp_fn);
    var $author$project$ParserFast$loopWhileSucceeds_fn = function (element, initialFolded, reduce, foldedToRes) {
        return function (s) {
            return $author$project$ParserFast$loopWhileSucceedsHelp_fn(element, initialFolded, reduce, foldedToRes, s);
        };
    }, $author$project$ParserFast$loopWhileSucceeds = F4($author$project$ParserFast$loopWhileSucceeds_fn);
    var $author$project$Rope$prependToFilled_fn = function (rightLikelyFilled, left) {
        if (left.$ === 1) {
            return $elm$core$Maybe$Just(rightLikelyFilled);
        }
        else {
            var leftLikelyFilled = left.a;
            return $elm$core$Maybe$Just($author$project$Rope$Branch2_fn(leftLikelyFilled, rightLikelyFilled));
        }
    }, $author$project$Rope$prependToFilled = F2($author$project$Rope$prependToFilled_fn);
    var $author$project$ParserFast$whileMapWithRange_fn = function (isGood, rangeAndConsumedStringToRes) {
        return function (s0) {
            var s1 = $author$project$ParserFast$skipWhileHelp_fn(isGood, s0.b, s0.bz, s0.a, s0.c, s0.f);
            return $author$project$ParserFast$Good_fn(A2(rangeAndConsumedStringToRes, {
                cm: { bk: s1.a, bz: s1.bz },
                bE: { bk: s0.a, bz: s0.bz }
            }, _String_slice_fn(s0.b, s1.b, s0.c)), s1);
        };
    }, $author$project$ParserFast$whileMapWithRange_fn_unwrapped = function (isGood, rangeAndConsumedStringToRes) {
        return function (s0) {
            var s1 = $author$project$ParserFast$skipWhileHelp_fn(isGood, s0.b, s0.bz, s0.a, s0.c, s0.f);
            return $author$project$ParserFast$Good_fn(rangeAndConsumedStringToRes({
                cm: { bk: s1.a, bz: s1.bz },
                bE: { bk: s0.a, bz: s0.bz }
            }, _String_slice_fn(s0.b, s1.b, s0.c)), s1);
        };
    }, $author$project$ParserFast$whileMapWithRange = F2($author$project$ParserFast$whileMapWithRange_fn);
    var $author$project$Elm$Parser$Comments$singleLineComment = $author$project$ParserFast$symbolFollowedBy_fn("--", $author$project$ParserFast$whileMapWithRange_fn_unwrapped(function (c) {
        return (c !== "\r") && ((c !== "\n") && (!$author$project$Char$Extra$isUtf16Surrogate(c)));
    }, function (range, content) {
        return $author$project$Elm$Syntax$Node$Node_fn({
            cm: { bk: range.cm.bk, bz: range.bE.bz },
            bE: { bk: range.bE.bk - 2, bz: range.bE.bz }
        }, "--" + content);
    }));
    var $author$project$Elm$Parser$Layout$whitespaceAndCommentsOrEmptyLoop = $author$project$ParserFast$loopWhileSucceeds_fn($author$project$ParserFast$followedBySkipWhileWhitespace($author$project$ParserFast$oneOf2_fn($author$project$Elm$Parser$Comments$singleLineComment, $author$project$Elm$Parser$Comments$multilineComment)), $author$project$Rope$empty, F2(function (right, soFar) {
        return $author$project$Rope$prependToFilled_fn($author$project$Rope$one(right), soFar);
    }), $elm$core$Basics$identity);
    var $author$project$Elm$Parser$Layout$fromMultilineCommentNodeOrEmptyOnProblem = $author$project$ParserFast$map2OrSucceed_fn_unwrapped(function (comment, commentsAfter) {
        return $author$project$Rope$filledPrependTo_fn(commentsAfter, $author$project$Rope$one(comment));
    }, $author$project$ParserFast$followedBySkipWhileWhitespace($author$project$Elm$Parser$Comments$multilineComment), $author$project$Elm$Parser$Layout$whitespaceAndCommentsOrEmptyLoop, $author$project$Rope$empty);
    var $author$project$Elm$Parser$Layout$fromSingleLineCommentNode = $author$project$ParserFast$map2_fn_unwrapped(function (content, commentsAfter) {
        return $author$project$Rope$filledPrependTo_fn(commentsAfter, $author$project$Rope$one(content));
    }, $author$project$ParserFast$followedBySkipWhileWhitespace($author$project$Elm$Parser$Comments$singleLineComment), $author$project$Elm$Parser$Layout$whitespaceAndCommentsOrEmptyLoop);
    var $author$project$ParserFast$offsetSourceAndThenOrSucceed_fn = function (callback, fallback) {
        return function (s) {
            var _v0 = A2(callback, s.b, s.c);
            if (_v0.$ === 1) {
                return $author$project$ParserFast$Good_fn(fallback, s);
            }
            else {
                var parse = _v0.a;
                return parse(s);
            }
        };
    }, $author$project$ParserFast$offsetSourceAndThenOrSucceed_fn_unwrapped = function (callback, fallback) {
        return function (s) {
            var _v0 = callback(s.b, s.c);
            if (_v0.$ === 1) {
                return $author$project$ParserFast$Good_fn(fallback, s);
            }
            else {
                var parse = _v0.a;
                return parse(s);
            }
        };
    }, $author$project$ParserFast$offsetSourceAndThenOrSucceed = F2($author$project$ParserFast$offsetSourceAndThenOrSucceed_fn);
    var $author$project$ParserFast$skipWhileWhitespaceFollowedBy = function (_v0) {
        var parseNext = _v0;
        return function (s0) {
            var s1 = $author$project$ParserFast$skipWhileWhitespaceHelp_fn(s0.b, s0.bz, s0.a, s0.c, s0.f);
            return $author$project$ParserFast$pStepCommit(parseNext(s1));
        };
    };
    var $author$project$Elm$Parser$Layout$whitespaceAndCommentsOrEmpty = $author$project$ParserFast$skipWhileWhitespaceFollowedBy($author$project$ParserFast$offsetSourceAndThenOrSucceed_fn_unwrapped(function (offset, source) {
        var _v0 = _String_slice_fn(offset, offset + 2, source);
        switch (_v0) {
            case "--":
                return $elm$core$Maybe$Just($author$project$Elm$Parser$Layout$fromSingleLineCommentNode);
            case "{-":
                return $elm$core$Maybe$Just($author$project$Elm$Parser$Layout$fromMultilineCommentNodeOrEmptyOnProblem);
            default:
                return $elm$core$Maybe$Nothing;
        }
    }, $author$project$Rope$empty));
    var $author$project$Elm$Parser$Layout$optimisticLayout = $author$project$Elm$Parser$Layout$whitespaceAndCommentsOrEmpty;
    var $author$project$Rope$prependTo_fn = function (right, left) {
        if (left.$ === 1) {
            return right;
        }
        else {
            var leftLikelyFilled = left.a;
            if (right.$ === 1) {
                return left;
            }
            else {
                var rightLikelyFilled = right.a;
                return $elm$core$Maybe$Just($author$project$Rope$Branch2_fn(leftLikelyFilled, rightLikelyFilled));
            }
        }
    }, $author$project$Rope$prependTo = F2($author$project$Rope$prependTo_fn);
    var $author$project$Elm$Parser$Expression$followedByOptimisticLayout = function (parser) {
        return $author$project$ParserFast$map2_fn_unwrapped(function (result, commentsAfter) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfter, result.e),
                d: result.d
            };
        }, parser, $author$project$Elm$Parser$Layout$optimisticLayout);
    };
    var $author$project$Elm$Parser$Expression$charLiteralExpressionOptimisticLayout = $author$project$Elm$Parser$Expression$followedByOptimisticLayout($author$project$Elm$Parser$Expression$charLiteralExpression);
    var $author$project$Elm$Parser$Expression$errUnknownInfixOperator = $elm$core$Result$Err("unknown infix operator");
    var $author$project$Elm$Syntax$Expression$RecordAccess_fn = function (a, b) {
        return { $: 20, a: a, b: b };
    }, $author$project$Elm$Syntax$Expression$RecordAccess = F2($author$project$Elm$Syntax$Expression$RecordAccess_fn);
    var $author$project$ParserFast$ifFollowedByWhileValidateMapWithRangeWithoutLinebreak_fn = function (toResult, firstIsOkay, afterFirstIsOkay, resultIsOkay) {
        return function (s0) {
            var firstOffset = $author$project$ParserFast$isSubCharWithoutLinebreak_fn(firstIsOkay, s0.b, s0.c);
            if (firstOffset === -1) {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingCharSatisfyingPredicate_fn(s0.bz, s0.a));
            }
            else {
                var s1 = $author$project$ParserFast$skipWhileWithoutLinebreakHelp_fn(afterFirstIsOkay, firstOffset, s0.bz, s0.a + 1, s0.c, s0.f);
                var name = _String_slice_fn(s0.b, s1.b, s0.c);
                return resultIsOkay(name) ? $author$project$ParserFast$Good_fn(A2(toResult, {
                    cm: { bk: s1.a, bz: s1.bz },
                    bE: { bk: s0.a, bz: s0.bz }
                }, name), s1) : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingStringSatisfyingPredicate_fn(s0.bz, s0.a + 1));
            }
        };
    }, $author$project$ParserFast$ifFollowedByWhileValidateMapWithRangeWithoutLinebreak_fn_unwrapped = function (toResult, firstIsOkay, afterFirstIsOkay, resultIsOkay) {
        return function (s0) {
            var firstOffset = $author$project$ParserFast$isSubCharWithoutLinebreak_fn(firstIsOkay, s0.b, s0.c);
            if (firstOffset === -1) {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingCharSatisfyingPredicate_fn(s0.bz, s0.a));
            }
            else {
                var s1 = $author$project$ParserFast$skipWhileWithoutLinebreakHelp_fn(afterFirstIsOkay, firstOffset, s0.bz, s0.a + 1, s0.c, s0.f);
                var name = _String_slice_fn(s0.b, s1.b, s0.c);
                return resultIsOkay(name) ? $author$project$ParserFast$Good_fn(toResult({
                    cm: { bk: s1.a, bz: s1.bz },
                    bE: { bk: s0.a, bz: s0.bz }
                }, name), s1) : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingStringSatisfyingPredicate_fn(s0.bz, s0.a + 1));
            }
        };
    }, $author$project$ParserFast$ifFollowedByWhileValidateMapWithRangeWithoutLinebreak = F4($author$project$ParserFast$ifFollowedByWhileValidateMapWithRangeWithoutLinebreak_fn);
    var $author$project$Elm$Parser$Tokens$isNotReserved = function (name) {
        switch (name) {
            case "module":
                return false;
            case "exposing":
                return false;
            case "import":
                return false;
            case "as":
                return false;
            case "if":
                return false;
            case "then":
                return false;
            case "else":
                return false;
            case "let":
                return false;
            case "in":
                return false;
            case "case":
                return false;
            case "of":
                return false;
            case "port":
                return false;
            case "type":
                return false;
            case "where":
                return false;
            default:
                return true;
        }
    };
    var $author$project$Char$Extra$charCodeIsDigit = function (code) {
        return (code <= 57) && (48 <= code);
    };
    var $author$project$Char$Extra$charCodeIsLower = function (code) {
        return (97 <= code) && (code <= 122);
    };
    var $author$project$Char$Extra$charCodeIsUpper = function (code) {
        return (code <= 90) && (65 <= code);
    };
    var $elm$core$Basics$modBy = _Basics_modBy;
    var $author$project$Char$Extra$unicodeIsAlphaNumOrUnderscoreFast = function (c) {
        var code = $elm$core$Char$toCode(c);
        return $author$project$Char$Extra$charCodeIsLower(code) || ($author$project$Char$Extra$charCodeIsUpper(code) || ($author$project$Char$Extra$charCodeIsDigit(code) || ((code === 95) || (((code !== 32) && (code !== 10)) && ((code < 256) ? (((48 <= code) && (code <= 57)) || (((65 <= code) && (code <= 90)) || (((97 <= code) && (code <= 122)) || ((code === 170) || (((178 <= code) && (code <= 179)) || ((code === 181) || (((185 <= code) && (code <= 186)) || (((188 <= code) && (code <= 190)) || (((192 <= code) && (code <= 214)) || (((216 <= code) && (code <= 246)) || ((248 <= code) && (code <= 255)))))))))))) : ((code < 43700) ? ((code < 4347) ? ((code < 2868) ? ((code < 2364) ? ((code < 1648) ? ((code < 930) ? (((256 <= code) && (code <= 705)) || (((710 <= code) && (code <= 721)) || (((736 <= code) && (code <= 740)) || (((880 <= code) && (code <= 884)) || (((886 <= code) && (code <= 887)) || (((890 <= code) && (code <= 893)) || ((code === 895) || ((code === 902) || (((904 <= code) && (code <= 906)) || ((code === 908) || (((910 <= code) && (code <= 929)) || ((!_Basics_modBy_fn(2, code)) && ((748 <= code) && (code <= 750)))))))))))))) : (((931 <= code) && (code <= 1013)) || (((1015 <= code) && (code <= 1153)) || (((1162 <= code) && (code <= 1327)) || (((1329 <= code) && (code <= 1366)) || ((code === 1369) || (((1376 <= code) && (code <= 1416)) || (((1488 <= code) && (code <= 1514)) || (((1519 <= code) && (code <= 1522)) || (((1568 <= code) && (code <= 1610)) || (((1632 <= code) && (code <= 1641)) || ((1646 <= code) && (code <= 1647))))))))))))) : ((code < 2041) ? (((1649 <= code) && (code <= 1747)) || ((code === 1749) || (((1765 <= code) && (code <= 1766)) || (((1774 <= code) && (code <= 1788)) || ((code === 1791) || ((code === 1808) || (((1810 <= code) && (code <= 1839)) || (((1869 <= code) && (code <= 1957)) || ((code === 1969) || (((1984 <= code) && (code <= 2026)) || ((2036 <= code) && (code <= 2037)))))))))))) : ((code === 2042) || (((2048 <= code) && (code <= 2069)) || ((code === 2074) || ((code === 2084) || ((code === 2088) || (((2112 <= code) && (code <= 2136)) || (((2144 <= code) && (code <= 2154)) || (((2160 <= code) && (code <= 2183)) || (((2185 <= code) && (code <= 2190)) || (((2208 <= code) && (code <= 2249)) || ((2308 <= code) && (code <= 2361)))))))))))))) : ((code < 2609) ? ((code < 2492) ? ((code === 2365) || ((code === 2384) || (((2392 <= code) && (code <= 2401)) || (((2406 <= code) && (code <= 2415)) || (((2417 <= code) && (code <= 2432)) || (((2437 <= code) && (code <= 2444)) || (((2447 <= code) && (code <= 2448)) || (((2451 <= code) && (code <= 2472)) || (((2474 <= code) && (code <= 2480)) || ((code === 2482) || ((2486 <= code) && (code <= 2489)))))))))))) : ((code === 2493) || ((code === 2510) || (((2524 <= code) && (code <= 2525)) || (((2527 <= code) && (code <= 2529)) || (((2534 <= code) && (code <= 2545)) || (((2548 <= code) && (code <= 2553)) || ((code === 2556) || (((2565 <= code) && (code <= 2570)) || (((2575 <= code) && (code <= 2576)) || (((2579 <= code) && (code <= 2600)) || ((2602 <= code) && (code <= 2608))))))))))))) : ((code < 2737) ? (((2610 <= code) && (code <= 2611)) || (((2613 <= code) && (code <= 2614)) || (((2616 <= code) && (code <= 2617)) || (((2649 <= code) && (code <= 2652)) || ((code === 2654) || (((2662 <= code) && (code <= 2671)) || (((2674 <= code) && (code <= 2676)) || (((2693 <= code) && (code <= 2701)) || (((2703 <= code) && (code <= 2705)) || (((2707 <= code) && (code <= 2728)) || ((2730 <= code) && (code <= 2736)))))))))))) : (((2738 <= code) && (code <= 2739)) || (((2741 <= code) && (code <= 2745)) || ((code === 2749) || ((code === 2768) || (((2784 <= code) && (code <= 2785)) || (((2790 <= code) && (code <= 2799)) || ((code === 2809) || (((2821 <= code) && (code <= 2828)) || (((2831 <= code) && (code <= 2832)) || (((2835 <= code) && (code <= 2856)) || (((2858 <= code) && (code <= 2864)) || ((2866 <= code) && (code <= 2867)))))))))))))))) : ((code < 3411) ? ((code < 3132) ? ((code < 2971) ? (((2869 <= code) && (code <= 2873)) || ((code === 2877) || (((2908 <= code) && (code <= 2909)) || (((2911 <= code) && (code <= 2913)) || (((2918 <= code) && (code <= 2927)) || (((2929 <= code) && (code <= 2935)) || ((code === 2947) || (((2949 <= code) && (code <= 2954)) || (((2958 <= code) && (code <= 2960)) || (((2962 <= code) && (code <= 2965)) || ((2969 <= code) && (code <= 2970)))))))))))) : ((code === 2972) || (((2974 <= code) && (code <= 2975)) || (((2979 <= code) && (code <= 2980)) || (((2984 <= code) && (code <= 2986)) || (((2990 <= code) && (code <= 3001)) || ((code === 3024) || (((3046 <= code) && (code <= 3058)) || (((3077 <= code) && (code <= 3084)) || (((3086 <= code) && (code <= 3088)) || (((3090 <= code) && (code <= 3112)) || ((3114 <= code) && (code <= 3129))))))))))))) : ((code < 3252) ? ((code === 3133) || (((3160 <= code) && (code <= 3162)) || ((code === 3165) || (((3168 <= code) && (code <= 3169)) || (((3174 <= code) && (code <= 3183)) || (((3192 <= code) && (code <= 3198)) || ((code === 3200) || (((3205 <= code) && (code <= 3212)) || (((3214 <= code) && (code <= 3216)) || (((3218 <= code) && (code <= 3240)) || ((3242 <= code) && (code <= 3251)))))))))))) : (((3253 <= code) && (code <= 3257)) || ((code === 3261) || (((3293 <= code) && (code <= 3294)) || (((3296 <= code) && (code <= 3297)) || (((3302 <= code) && (code <= 3311)) || (((3313 <= code) && (code <= 3314)) || (((3332 <= code) && (code <= 3340)) || (((3342 <= code) && (code <= 3344)) || (((3346 <= code) && (code <= 3386)) || ((code === 3389) || (code === 3406))))))))))))) : ((code < 3775) ? ((code < 3633) ? (((3412 <= code) && (code <= 3414)) || (((3416 <= code) && (code <= 3425)) || (((3430 <= code) && (code <= 3448)) || (((3450 <= code) && (code <= 3455)) || (((3461 <= code) && (code <= 3478)) || (((3482 <= code) && (code <= 3505)) || (((3507 <= code) && (code <= 3515)) || ((code === 3517) || (((3520 <= code) && (code <= 3526)) || (((3558 <= code) && (code <= 3567)) || ((3585 <= code) && (code <= 3632)))))))))))) : (((3634 <= code) && (code <= 3635)) || (((3648 <= code) && (code <= 3654)) || (((3664 <= code) && (code <= 3673)) || (((3713 <= code) && (code <= 3714)) || ((code === 3716) || (((3718 <= code) && (code <= 3722)) || (((3724 <= code) && (code <= 3747)) || ((code === 3749) || (((3751 <= code) && (code <= 3760)) || (((3762 <= code) && (code <= 3763)) || (code === 3773)))))))))))) : ((code < 4175) ? (((3776 <= code) && (code <= 3780)) || ((code === 3782) || (((3792 <= code) && (code <= 3801)) || (((3804 <= code) && (code <= 3807)) || ((code === 3840) || (((3872 <= code) && (code <= 3891)) || (((3904 <= code) && (code <= 3911)) || (((3913 <= code) && (code <= 3948)) || (((3976 <= code) && (code <= 3980)) || (((4096 <= code) && (code <= 4138)) || ((4159 <= code) && (code <= 4169)))))))))))) : (((4176 <= code) && (code <= 4181)) || (((4186 <= code) && (code <= 4189)) || ((code === 4193) || (((4197 <= code) && (code <= 4198)) || (((4206 <= code) && (code <= 4208)) || (((4213 <= code) && (code <= 4225)) || ((code === 4238) || (((4240 <= code) && (code <= 4249)) || (((4256 <= code) && (code <= 4293)) || ((code === 4295) || ((code === 4301) || ((4304 <= code) && (code <= 4346))))))))))))))))) : ((code < 8454) ? ((code < 6527) ? ((code < 5760) ? ((code < 4801) ? (((4348 <= code) && (code <= 4680)) || (((4682 <= code) && (code <= 4685)) || (((4688 <= code) && (code <= 4694)) || ((code === 4696) || (((4698 <= code) && (code <= 4701)) || (((4704 <= code) && (code <= 4744)) || (((4746 <= code) && (code <= 4749)) || (((4752 <= code) && (code <= 4784)) || (((4786 <= code) && (code <= 4789)) || (((4792 <= code) && (code <= 4798)) || (code === 4800))))))))))) : (((4802 <= code) && (code <= 4805)) || (((4808 <= code) && (code <= 4822)) || (((4824 <= code) && (code <= 4880)) || (((4882 <= code) && (code <= 4885)) || (((4888 <= code) && (code <= 4954)) || (((4969 <= code) && (code <= 4988)) || (((4992 <= code) && (code <= 5007)) || (((5024 <= code) && (code <= 5109)) || (((5112 <= code) && (code <= 5117)) || (((5121 <= code) && (code <= 5740)) || ((5743 <= code) && (code <= 5759))))))))))))) : ((code < 6111) ? (((5761 <= code) && (code <= 5786)) || (((5792 <= code) && (code <= 5866)) || (((5870 <= code) && (code <= 5880)) || (((5888 <= code) && (code <= 5905)) || (((5919 <= code) && (code <= 5937)) || (((5952 <= code) && (code <= 5969)) || (((5984 <= code) && (code <= 5996)) || (((5998 <= code) && (code <= 6000)) || (((6016 <= code) && (code <= 6067)) || ((code === 6103) || (code === 6108))))))))))) : (((6112 <= code) && (code <= 6121)) || (((6128 <= code) && (code <= 6137)) || (((6160 <= code) && (code <= 6169)) || (((6176 <= code) && (code <= 6264)) || (((6272 <= code) && (code <= 6276)) || (((6279 <= code) && (code <= 6312)) || ((code === 6314) || (((6320 <= code) && (code <= 6389)) || (((6400 <= code) && (code <= 6430)) || (((6470 <= code) && (code <= 6509)) || ((6512 <= code) && (code <= 6516)))))))))))))) : ((code < 7417) ? ((code < 7042) ? (((6528 <= code) && (code <= 6571)) || (((6576 <= code) && (code <= 6601)) || (((6608 <= code) && (code <= 6618)) || (((6656 <= code) && (code <= 6678)) || (((6688 <= code) && (code <= 6740)) || (((6784 <= code) && (code <= 6793)) || (((6800 <= code) && (code <= 6809)) || ((code === 6823) || (((6917 <= code) && (code <= 6963)) || (((6981 <= code) && (code <= 6988)) || ((6992 <= code) && (code <= 7001)))))))))))) : (((7043 <= code) && (code <= 7072)) || (((7086 <= code) && (code <= 7141)) || (((7168 <= code) && (code <= 7203)) || (((7232 <= code) && (code <= 7241)) || (((7245 <= code) && (code <= 7293)) || (((7296 <= code) && (code <= 7304)) || (((7312 <= code) && (code <= 7354)) || (((7357 <= code) && (code <= 7359)) || (((7401 <= code) && (code <= 7404)) || (((7406 <= code) && (code <= 7411)) || ((7413 <= code) && (code <= 7414))))))))))))) : ((code < 8129) ? ((code === 7418) || (((7424 <= code) && (code <= 7615)) || (((7680 <= code) && (code <= 7957)) || (((7960 <= code) && (code <= 7965)) || (((7968 <= code) && (code <= 8005)) || (((8008 <= code) && (code <= 8013)) || (((8016 <= code) && (code <= 8023)) || (((8032 <= code) && (code <= 8061)) || (((8064 <= code) && (code <= 8116)) || (((8118 <= code) && (code <= 8124)) || ((code === 8126) || ((_Basics_modBy_fn(2, code) === 1) && ((8025 <= code) && (code <= 8031)))))))))))))) : (((8130 <= code) && (code <= 8132)) || (((8134 <= code) && (code <= 8140)) || (((8144 <= code) && (code <= 8147)) || (((8150 <= code) && (code <= 8155)) || (((8160 <= code) && (code <= 8172)) || (((8178 <= code) && (code <= 8180)) || (((8182 <= code) && (code <= 8188)) || (((8304 <= code) && (code <= 8305)) || (((8308 <= code) && (code <= 8313)) || (((8319 <= code) && (code <= 8329)) || (((8336 <= code) && (code <= 8348)) || (code === 8450))))))))))))))) : ((code < 12783) ? ((code < 11647) ? ((code < 9449) ? ((code === 8455) || (((8458 <= code) && (code <= 8467)) || ((code === 8469) || (((8473 <= code) && (code <= 8477)) || (((8490 <= code) && (code <= 8493)) || (((8495 <= code) && (code <= 8505)) || (((8508 <= code) && (code <= 8511)) || (((8517 <= code) && (code <= 8521)) || ((code === 8526) || (((8528 <= code) && (code <= 8585)) || (((9312 <= code) && (code <= 9371)) || ((!_Basics_modBy_fn(2, code)) && ((8484 <= code) && (code <= 8488)))))))))))))) : (((9450 <= code) && (code <= 9471)) || (((10102 <= code) && (code <= 10131)) || (((11264 <= code) && (code <= 11492)) || (((11499 <= code) && (code <= 11502)) || (((11506 <= code) && (code <= 11507)) || ((code === 11517) || (((11520 <= code) && (code <= 11557)) || ((code === 11559) || ((code === 11565) || (((11568 <= code) && (code <= 11623)) || (code === 11631)))))))))))) : ((code < 12320) ? (((11648 <= code) && (code <= 11670)) || (((11680 <= code) && (code <= 11686)) || (((11688 <= code) && (code <= 11694)) || (((11696 <= code) && (code <= 11702)) || (((11704 <= code) && (code <= 11710)) || (((11712 <= code) && (code <= 11718)) || (((11720 <= code) && (code <= 11726)) || (((11728 <= code) && (code <= 11734)) || (((11736 <= code) && (code <= 11742)) || ((code === 11823) || ((12293 <= code) && (code <= 12295)))))))))))) : (((12321 <= code) && (code <= 12329)) || (((12337 <= code) && (code <= 12341)) || (((12344 <= code) && (code <= 12348)) || (((12353 <= code) && (code <= 12438)) || (((12445 <= code) && (code <= 12447)) || (((12449 <= code) && (code <= 12538)) || (((12540 <= code) && (code <= 12543)) || (((12549 <= code) && (code <= 12591)) || (((12593 <= code) && (code <= 12686)) || (((12690 <= code) && (code <= 12693)) || ((12704 <= code) && (code <= 12735)))))))))))))) : ((code < 43019) ? ((code < 42559) ? (((12784 <= code) && (code <= 12799)) || (((12832 <= code) && (code <= 12841)) || (((12872 <= code) && (code <= 12879)) || (((12881 <= code) && (code <= 12895)) || (((12928 <= code) && (code <= 12937)) || (((12977 <= code) && (code <= 12991)) || (((13312 <= code) && (code <= 19903)) || (((19968 <= code) && (code <= 42124)) || (((42192 <= code) && (code <= 42237)) || (((42240 <= code) && (code <= 42508)) || ((42512 <= code) && (code <= 42539)))))))))))) : (((42560 <= code) && (code <= 42606)) || (((42623 <= code) && (code <= 42653)) || (((42656 <= code) && (code <= 42735)) || (((42775 <= code) && (code <= 42783)) || (((42786 <= code) && (code <= 42888)) || (((42891 <= code) && (code <= 42954)) || (((42960 <= code) && (code <= 42961)) || (((42966 <= code) && (code <= 42969)) || (((42994 <= code) && (code <= 43009)) || (((43011 <= code) && (code <= 43013)) || (((43015 <= code) && (code <= 43018)) || ((_Basics_modBy_fn(2, code) === 1) && ((42963 <= code) && (code <= 42965))))))))))))))) : ((code < 43395) ? (((43020 <= code) && (code <= 43042)) || (((43056 <= code) && (code <= 43061)) || (((43072 <= code) && (code <= 43123)) || (((43138 <= code) && (code <= 43187)) || (((43216 <= code) && (code <= 43225)) || (((43250 <= code) && (code <= 43255)) || ((code === 43259) || (((43261 <= code) && (code <= 43262)) || (((43264 <= code) && (code <= 43301)) || (((43312 <= code) && (code <= 43334)) || ((43360 <= code) && (code <= 43388)))))))))))) : (((43396 <= code) && (code <= 43442)) || (((43471 <= code) && (code <= 43481)) || (((43488 <= code) && (code <= 43492)) || (((43494 <= code) && (code <= 43518)) || (((43520 <= code) && (code <= 43560)) || (((43584 <= code) && (code <= 43586)) || (((43588 <= code) && (code <= 43595)) || (((43600 <= code) && (code <= 43609)) || (((43616 <= code) && (code <= 43638)) || ((code === 43642) || (((43646 <= code) && (code <= 43695)) || (code === 43697))))))))))))))))) : ((code < 71351) ? ((code < 67671) ? ((code < 65548) ? ((code < 64286) ? ((code < 43867) ? (((43701 <= code) && (code <= 43702)) || (((43705 <= code) && (code <= 43709)) || (((43739 <= code) && (code <= 43741)) || (((43744 <= code) && (code <= 43754)) || (((43762 <= code) && (code <= 43764)) || (((43777 <= code) && (code <= 43782)) || (((43785 <= code) && (code <= 43790)) || (((43793 <= code) && (code <= 43798)) || (((43808 <= code) && (code <= 43814)) || (((43816 <= code) && (code <= 43822)) || (((43824 <= code) && (code <= 43866)) || ((!_Basics_modBy_fn(2, code)) && ((43712 <= code) && (code <= 43714)))))))))))))) : (((43868 <= code) && (code <= 43881)) || (((43888 <= code) && (code <= 44002)) || (((44016 <= code) && (code <= 44025)) || (((44032 <= code) && (code <= 55203)) || (((55216 <= code) && (code <= 55238)) || (((55243 <= code) && (code <= 55291)) || (((63744 <= code) && (code <= 64109)) || (((64112 <= code) && (code <= 64217)) || (((64256 <= code) && (code <= 64262)) || (((64275 <= code) && (code <= 64279)) || (code === 64285)))))))))))) : ((code < 65135) ? (((64287 <= code) && (code <= 64296)) || (((64298 <= code) && (code <= 64310)) || (((64312 <= code) && (code <= 64316)) || ((code === 64318) || (((64320 <= code) && (code <= 64321)) || (((64323 <= code) && (code <= 64324)) || (((64326 <= code) && (code <= 64433)) || (((64467 <= code) && (code <= 64829)) || (((64848 <= code) && (code <= 64911)) || (((64914 <= code) && (code <= 64967)) || ((65008 <= code) && (code <= 65019)))))))))))) : (((65136 <= code) && (code <= 65140)) || (((65142 <= code) && (code <= 65276)) || (((65296 <= code) && (code <= 65305)) || (((65313 <= code) && (code <= 65338)) || (((65345 <= code) && (code <= 65370)) || (((65382 <= code) && (code <= 65470)) || (((65474 <= code) && (code <= 65479)) || (((65482 <= code) && (code <= 65487)) || (((65490 <= code) && (code <= 65495)) || (((65498 <= code) && (code <= 65500)) || ((65536 <= code) && (code <= 65547)))))))))))))) : ((code < 66775) ? ((code < 66272) ? (((65549 <= code) && (code <= 65574)) || (((65576 <= code) && (code <= 65594)) || (((65596 <= code) && (code <= 65597)) || (((65599 <= code) && (code <= 65613)) || (((65616 <= code) && (code <= 65629)) || (((65664 <= code) && (code <= 65786)) || (((65799 <= code) && (code <= 65843)) || (((65856 <= code) && (code <= 65912)) || (((65930 <= code) && (code <= 65931)) || (((66176 <= code) && (code <= 66204)) || ((66208 <= code) && (code <= 66256)))))))))))) : (((66273 <= code) && (code <= 66299)) || (((66304 <= code) && (code <= 66339)) || (((66349 <= code) && (code <= 66378)) || (((66384 <= code) && (code <= 66421)) || (((66432 <= code) && (code <= 66461)) || (((66464 <= code) && (code <= 66499)) || (((66504 <= code) && (code <= 66511)) || (((66513 <= code) && (code <= 66517)) || (((66560 <= code) && (code <= 66717)) || (((66720 <= code) && (code <= 66729)) || ((66736 <= code) && (code <= 66771))))))))))))) : ((code < 67071) ? (((66776 <= code) && (code <= 66811)) || (((66816 <= code) && (code <= 66855)) || (((66864 <= code) && (code <= 66915)) || (((66928 <= code) && (code <= 66938)) || (((66940 <= code) && (code <= 66954)) || (((66956 <= code) && (code <= 66962)) || (((66964 <= code) && (code <= 66965)) || (((66967 <= code) && (code <= 66977)) || (((66979 <= code) && (code <= 66993)) || (((66995 <= code) && (code <= 67001)) || ((67003 <= code) && (code <= 67004)))))))))))) : (((67072 <= code) && (code <= 67382)) || (((67392 <= code) && (code <= 67413)) || (((67424 <= code) && (code <= 67431)) || (((67456 <= code) && (code <= 67461)) || (((67463 <= code) && (code <= 67504)) || (((67506 <= code) && (code <= 67514)) || (((67584 <= code) && (code <= 67589)) || ((code === 67592) || (((67594 <= code) && (code <= 67637)) || (((67639 <= code) && (code <= 67640)) || ((code === 67644) || ((67647 <= code) && (code <= 67669)))))))))))))))) : ((code < 69871) ? ((code < 68471) ? ((code < 68116) ? (((67672 <= code) && (code <= 67702)) || (((67705 <= code) && (code <= 67742)) || (((67751 <= code) && (code <= 67759)) || (((67808 <= code) && (code <= 67826)) || (((67828 <= code) && (code <= 67829)) || (((67835 <= code) && (code <= 67867)) || (((67872 <= code) && (code <= 67897)) || (((67968 <= code) && (code <= 68023)) || (((68028 <= code) && (code <= 68047)) || (((68050 <= code) && (code <= 68096)) || ((68112 <= code) && (code <= 68115)))))))))))) : (((68117 <= code) && (code <= 68119)) || (((68121 <= code) && (code <= 68149)) || (((68160 <= code) && (code <= 68168)) || (((68192 <= code) && (code <= 68222)) || (((68224 <= code) && (code <= 68255)) || (((68288 <= code) && (code <= 68295)) || (((68297 <= code) && (code <= 68324)) || (((68331 <= code) && (code <= 68335)) || (((68352 <= code) && (code <= 68405)) || (((68416 <= code) && (code <= 68437)) || ((68440 <= code) && (code <= 68466))))))))))))) : ((code < 69423) ? (((68472 <= code) && (code <= 68497)) || (((68521 <= code) && (code <= 68527)) || (((68608 <= code) && (code <= 68680)) || (((68736 <= code) && (code <= 68786)) || (((68800 <= code) && (code <= 68850)) || (((68858 <= code) && (code <= 68899)) || (((68912 <= code) && (code <= 68921)) || (((69216 <= code) && (code <= 69246)) || (((69248 <= code) && (code <= 69289)) || (((69296 <= code) && (code <= 69297)) || ((69376 <= code) && (code <= 69415)))))))))))) : (((69424 <= code) && (code <= 69445)) || (((69457 <= code) && (code <= 69460)) || (((69488 <= code) && (code <= 69505)) || (((69552 <= code) && (code <= 69579)) || (((69600 <= code) && (code <= 69622)) || (((69635 <= code) && (code <= 69687)) || (((69714 <= code) && (code <= 69743)) || (((69745 <= code) && (code <= 69746)) || ((code === 69749) || (((69763 <= code) && (code <= 69807)) || ((69840 <= code) && (code <= 69864)))))))))))))) : ((code < 70404) ? ((code < 70112) ? (((69872 <= code) && (code <= 69881)) || (((69891 <= code) && (code <= 69926)) || (((69942 <= code) && (code <= 69951)) || ((code === 69956) || ((code === 69959) || (((69968 <= code) && (code <= 70002)) || ((code === 70006) || (((70019 <= code) && (code <= 70066)) || (((70081 <= code) && (code <= 70084)) || (((70096 <= code) && (code <= 70106)) || (code === 70108))))))))))) : (((70113 <= code) && (code <= 70132)) || (((70144 <= code) && (code <= 70161)) || (((70163 <= code) && (code <= 70187)) || (((70207 <= code) && (code <= 70208)) || (((70272 <= code) && (code <= 70278)) || ((code === 70280) || (((70282 <= code) && (code <= 70285)) || (((70287 <= code) && (code <= 70301)) || (((70303 <= code) && (code <= 70312)) || (((70320 <= code) && (code <= 70366)) || ((70384 <= code) && (code <= 70393))))))))))))) : ((code < 70735) ? (((70405 <= code) && (code <= 70412)) || (((70415 <= code) && (code <= 70416)) || (((70419 <= code) && (code <= 70440)) || (((70442 <= code) && (code <= 70448)) || (((70450 <= code) && (code <= 70451)) || (((70453 <= code) && (code <= 70457)) || ((code === 70461) || ((code === 70480) || (((70493 <= code) && (code <= 70497)) || (((70656 <= code) && (code <= 70708)) || ((70727 <= code) && (code <= 70730)))))))))))) : (((70736 <= code) && (code <= 70745)) || (((70751 <= code) && (code <= 70753)) || (((70784 <= code) && (code <= 70831)) || (((70852 <= code) && (code <= 70853)) || ((code === 70855) || (((70864 <= code) && (code <= 70873)) || (((71040 <= code) && (code <= 71086)) || (((71128 <= code) && (code <= 71131)) || (((71168 <= code) && (code <= 71215)) || ((code === 71236) || (((71248 <= code) && (code <= 71257)) || ((71296 <= code) && (code <= 71338))))))))))))))))) : ((code < 119893) ? ((code < 73727) ? ((code < 72703) ? ((code < 71959) ? ((code === 71352) || (((71360 <= code) && (code <= 71369)) || (((71424 <= code) && (code <= 71450)) || (((71472 <= code) && (code <= 71483)) || (((71488 <= code) && (code <= 71494)) || (((71680 <= code) && (code <= 71723)) || (((71840 <= code) && (code <= 71922)) || (((71935 <= code) && (code <= 71942)) || ((code === 71945) || (((71948 <= code) && (code <= 71955)) || ((71957 <= code) && (code <= 71958)))))))))))) : (((71960 <= code) && (code <= 71983)) || (((72016 <= code) && (code <= 72025)) || (((72096 <= code) && (code <= 72103)) || (((72106 <= code) && (code <= 72144)) || ((code === 72192) || (((72203 <= code) && (code <= 72242)) || ((code === 72250) || ((code === 72272) || (((72284 <= code) && (code <= 72329)) || ((code === 72349) || (((72368 <= code) && (code <= 72440)) || ((_Basics_modBy_fn(2, code) === 1) && (((71999 <= code) && (code <= 72001)) || ((72161 <= code) && (code <= 72163)))))))))))))))) : ((code < 73062) ? (((72704 <= code) && (code <= 72712)) || (((72714 <= code) && (code <= 72750)) || ((code === 72768) || (((72784 <= code) && (code <= 72812)) || (((72818 <= code) && (code <= 72847)) || (((72960 <= code) && (code <= 72966)) || (((72968 <= code) && (code <= 72969)) || (((72971 <= code) && (code <= 73008)) || ((code === 73030) || (((73040 <= code) && (code <= 73049)) || ((73056 <= code) && (code <= 73061)))))))))))) : (((73063 <= code) && (code <= 73064)) || (((73066 <= code) && (code <= 73097)) || ((code === 73112) || (((73120 <= code) && (code <= 73129)) || (((73440 <= code) && (code <= 73458)) || ((code === 73474) || (((73476 <= code) && (code <= 73488)) || (((73490 <= code) && (code <= 73523)) || (((73552 <= code) && (code <= 73561)) || ((code === 73648) || ((73664 <= code) && (code <= 73684)))))))))))))) : ((code < 94098) ? ((code < 92863) ? (((73728 <= code) && (code <= 74649)) || (((74752 <= code) && (code <= 74862)) || (((74880 <= code) && (code <= 75075)) || (((77712 <= code) && (code <= 77808)) || (((77824 <= code) && (code <= 78895)) || (((78913 <= code) && (code <= 78918)) || (((82944 <= code) && (code <= 83526)) || (((92160 <= code) && (code <= 92728)) || (((92736 <= code) && (code <= 92766)) || (((92768 <= code) && (code <= 92777)) || ((92784 <= code) && (code <= 92862)))))))))))) : (((92864 <= code) && (code <= 92873)) || (((92880 <= code) && (code <= 92909)) || (((92928 <= code) && (code <= 92975)) || (((92992 <= code) && (code <= 92995)) || (((93008 <= code) && (code <= 93017)) || (((93019 <= code) && (code <= 93025)) || (((93027 <= code) && (code <= 93047)) || (((93053 <= code) && (code <= 93071)) || (((93760 <= code) && (code <= 93846)) || (((93952 <= code) && (code <= 94026)) || (code === 94032)))))))))))) : ((code < 110927) ? (((94099 <= code) && (code <= 94111)) || (((94176 <= code) && (code <= 94177)) || ((code === 94179) || (((94208 <= code) && (code <= 100343)) || (((100352 <= code) && (code <= 101589)) || (((101632 <= code) && (code <= 101640)) || (((110576 <= code) && (code <= 110579)) || (((110581 <= code) && (code <= 110587)) || (((110589 <= code) && (code <= 110590)) || (((110592 <= code) && (code <= 110882)) || (code === 110898))))))))))) : (((110928 <= code) && (code <= 110930)) || ((code === 110933) || (((110948 <= code) && (code <= 110951)) || (((110960 <= code) && (code <= 111355)) || (((113664 <= code) && (code <= 113770)) || (((113776 <= code) && (code <= 113788)) || (((113792 <= code) && (code <= 113800)) || (((113808 <= code) && (code <= 113817)) || (((119488 <= code) && (code <= 119507)) || (((119520 <= code) && (code <= 119539)) || (((119648 <= code) && (code <= 119672)) || ((119808 <= code) && (code <= 119892)))))))))))))))) : ((code < 124911) ? ((code < 120597) ? ((code < 120085) ? (((119894 <= code) && (code <= 119964)) || (((119966 <= code) && (code <= 119967)) || ((code === 119970) || (((119973 <= code) && (code <= 119974)) || (((119977 <= code) && (code <= 119980)) || (((119982 <= code) && (code <= 119993)) || ((code === 119995) || (((119997 <= code) && (code <= 120003)) || (((120005 <= code) && (code <= 120069)) || (((120071 <= code) && (code <= 120074)) || ((120077 <= code) && (code <= 120084)))))))))))) : (((120086 <= code) && (code <= 120092)) || (((120094 <= code) && (code <= 120121)) || (((120123 <= code) && (code <= 120126)) || (((120128 <= code) && (code <= 120132)) || ((code === 120134) || (((120138 <= code) && (code <= 120144)) || (((120146 <= code) && (code <= 120485)) || (((120488 <= code) && (code <= 120512)) || (((120514 <= code) && (code <= 120538)) || (((120540 <= code) && (code <= 120570)) || ((120572 <= code) && (code <= 120596))))))))))))) : ((code < 123135) ? (((120598 <= code) && (code <= 120628)) || (((120630 <= code) && (code <= 120654)) || (((120656 <= code) && (code <= 120686)) || (((120688 <= code) && (code <= 120712)) || (((120714 <= code) && (code <= 120744)) || (((120746 <= code) && (code <= 120770)) || (((120772 <= code) && (code <= 120779)) || (((120782 <= code) && (code <= 120831)) || (((122624 <= code) && (code <= 122654)) || (((122661 <= code) && (code <= 122666)) || ((122928 <= code) && (code <= 122989)))))))))))) : (((123136 <= code) && (code <= 123180)) || (((123191 <= code) && (code <= 123197)) || (((123200 <= code) && (code <= 123209)) || ((code === 123214) || (((123536 <= code) && (code <= 123565)) || (((123584 <= code) && (code <= 123627)) || (((123632 <= code) && (code <= 123641)) || (((124112 <= code) && (code <= 124139)) || (((124144 <= code) && (code <= 124153)) || (((124896 <= code) && (code <= 124902)) || (((124904 <= code) && (code <= 124907)) || ((124909 <= code) && (code <= 124910))))))))))))))) : ((code < 126560) ? ((code < 126463) ? (((124912 <= code) && (code <= 124926)) || (((124928 <= code) && (code <= 125124)) || (((125127 <= code) && (code <= 125135)) || (((125184 <= code) && (code <= 125251)) || ((code === 125259) || (((125264 <= code) && (code <= 125273)) || (((126065 <= code) && (code <= 126123)) || (((126125 <= code) && (code <= 126127)) || (((126129 <= code) && (code <= 126132)) || (((126209 <= code) && (code <= 126253)) || ((126255 <= code) && (code <= 126269)))))))))))) : (((126464 <= code) && (code <= 126467)) || (((126469 <= code) && (code <= 126495)) || (((126497 <= code) && (code <= 126498)) || ((code === 126500) || ((code === 126503) || (((126505 <= code) && (code <= 126514)) || (((126516 <= code) && (code <= 126519)) || ((code === 126530) || (((126541 <= code) && (code <= 126543)) || (((126545 <= code) && (code <= 126546)) || ((code === 126548) || ((_Basics_modBy_fn(2, code) === 1) && (((126521 <= code) && (code <= 126523)) || (((126535 <= code) && (code <= 126539)) || ((126551 <= code) && (code <= 126559))))))))))))))))) : ((code < 126634) ? (((126561 <= code) && (code <= 126562)) || ((code === 126564) || (((126567 <= code) && (code <= 126570)) || (((126572 <= code) && (code <= 126578)) || (((126580 <= code) && (code <= 126583)) || (((126585 <= code) && (code <= 126588)) || ((code === 126590) || (((126592 <= code) && (code <= 126601)) || (((126603 <= code) && (code <= 126619)) || (((126625 <= code) && (code <= 126627)) || ((126629 <= code) && (code <= 126633)))))))))))) : (((126635 <= code) && (code <= 126651)) || (((127232 <= code) && (code <= 127244)) || (((130032 <= code) && (code <= 130041)) || (((131072 <= code) && (code <= 173791)) || (((173824 <= code) && (code <= 177977)) || (((177984 <= code) && (code <= 178205)) || (((178208 <= code) && (code <= 183969)) || (((183984 <= code) && (code <= 191456)) || (((191472 <= code) && (code <= 192093)) || (((194560 <= code) && (code <= 195101)) || (((196608 <= code) && (code <= 201546)) || ((201552 <= code) && (code <= 205743))))))))))))))))))))))));
    };
    var $elm$core$String$fromChar = function (_char) {
        return _String_cons_fn(_char, "");
    };
    var $elm$core$String$toLower = _String_toLower;
    var $elm$core$String$toUpper = _String_toUpper;
    var $author$project$Char$Extra$unicodeIsLowerFast = function (c) {
        var code = $elm$core$Char$toCode(c);
        var cString = $elm$core$String$fromChar(c);
        return $author$project$Char$Extra$charCodeIsLower(code) || ((_Utils_eq($elm$core$String$toLower(cString), cString + "") && (!_Utils_eq($elm$core$String$toUpper(cString), cString + ""))) ? ((code <= 836) || (((838 <= code) && (code <= 8559)) || (((8576 <= code) && (code <= 9423)) || ((9450 <= code) && (code <= 983040))))) : ((code < 43001) ? ((code < 8457) ? ((code < 590) ? (((311 <= code) && (code <= 312)) || (((396 <= code) && (code <= 397)) || (((409 <= code) && (code <= 411)) || (((426 <= code) && (code <= 427)) || (((441 <= code) && (code <= 442)) || (((445 <= code) && (code <= 447)) || ((code === 545) || ((563 <= code) && (code <= 569))))))))) : (((591 <= code) && (code <= 659)) || (((661 <= code) && (code <= 687)) || (((1019 <= code) && (code <= 1020)) || (((1376 <= code) && (code <= 1416)) || (((7424 <= code) && (code <= 7467)) || (((7531 <= code) && (code <= 7543)) || (((7545 <= code) && (code <= 7578)) || (((7829 <= code) && (code <= 7837)) || (code === 7839)))))))))) : ((code < 11376) ? ((code === 8458) || (((8462 <= code) && (code <= 8463)) || ((code === 8467) || ((code === 8495) || ((code === 8500) || ((code === 8505) || (((8508 <= code) && (code <= 8509)) || ((8518 <= code) && (code <= 8521))))))))) : ((code === 11377) || (((11379 <= code) && (code <= 11380)) || (((11382 <= code) && (code <= 11387)) || (((11491 <= code) && (code <= 11492)) || (((42799 <= code) && (code <= 42801)) || (((42865 <= code) && (code <= 42872)) || ((code === 42894) || (((42899 <= code) && (code <= 42901)) || ((code === 42927) || ((_Basics_modBy_fn(2, code) === 1) && ((42963 <= code) && (code <= 42965)))))))))))))) : ((code < 120353) ? ((code < 119994) ? ((code === 43002) || (((43824 <= code) && (code <= 43866)) || (((43872 <= code) && (code <= 43880)) || (((119834 <= code) && (code <= 119859)) || (((119886 <= code) && (code <= 119892)) || (((119894 <= code) && (code <= 119911)) || (((119938 <= code) && (code <= 119963)) || ((119990 <= code) && (code <= 119993))))))))) : ((code === 119995) || (((119997 <= code) && (code <= 120003)) || (((120005 <= code) && (code <= 120015)) || (((120042 <= code) && (code <= 120067)) || (((120094 <= code) && (code <= 120119)) || (((120146 <= code) && (code <= 120171)) || (((120198 <= code) && (code <= 120223)) || (((120250 <= code) && (code <= 120275)) || ((120302 <= code) && (code <= 120327))))))))))) : ((code < 120655) ? (((120354 <= code) && (code <= 120379)) || (((120406 <= code) && (code <= 120431)) || (((120458 <= code) && (code <= 120485)) || (((120514 <= code) && (code <= 120538)) || (((120540 <= code) && (code <= 120545)) || (((120572 <= code) && (code <= 120596)) || (((120598 <= code) && (code <= 120603)) || ((120630 <= code) && (code <= 120654))))))))) : (((120656 <= code) && (code <= 120661)) || (((120688 <= code) && (code <= 120712)) || (((120714 <= code) && (code <= 120719)) || (((120746 <= code) && (code <= 120770)) || (((120772 <= code) && (code <= 120777)) || ((code === 120779) || (((122624 <= code) && (code <= 122633)) || (((122635 <= code) && (code <= 122654)) || ((122661 <= code) && (code <= 122666))))))))))))));
    };
    var $author$project$Elm$Parser$Tokens$functionNameNode = $author$project$ParserFast$ifFollowedByWhileValidateMapWithRangeWithoutLinebreak_fn($author$project$Elm$Syntax$Node$Node, $author$project$Char$Extra$unicodeIsLowerFast, $author$project$Char$Extra$unicodeIsAlphaNumOrUnderscoreFast, $author$project$Elm$Parser$Tokens$isNotReserved);
    var $author$project$ParserFast$loopWhileSucceedsOntoResultFromParser_fn = function (element, _v0, reduce, foldedToRes) {
        var parseInitialFolded = _v0;
        return function (s0) {
            var _v1 = parseInitialFolded(s0);
            if (!_v1.$) {
                var initialFolded = _v1.a;
                var s1 = _v1.b;
                return $author$project$ParserFast$loopWhileSucceedsHelp_fn(element, initialFolded, reduce, foldedToRes, s1);
            }
            else {
                var committed = _v1.a;
                var x = _v1.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
        };
    }, $author$project$ParserFast$loopWhileSucceedsOntoResultFromParser = F4($author$project$ParserFast$loopWhileSucceedsOntoResultFromParser_fn);
    var $author$project$Elm$Parser$Expression$followedByMultiRecordAccess = function (beforeRecordAccesses) {
        return $author$project$ParserFast$loopWhileSucceedsOntoResultFromParser_fn($author$project$ParserFast$symbolFollowedBy_fn(".", $author$project$Elm$Parser$Tokens$functionNameNode), beforeRecordAccesses, F2(function (fieldNode, leftResult) {
            var fieldRange = fieldNode.a;
            var leftNode = leftResult.d;
            var leftRange = leftNode.a;
            return {
                e: leftResult.e,
                d: $author$project$Elm$Syntax$Node$Node_fn({ cm: fieldRange.cm, bE: leftRange.bE }, $author$project$Elm$Syntax$Expression$RecordAccess_fn(leftNode, fieldNode))
            };
        }), $elm$core$Basics$identity);
    };
    var $elm$core$Basics$ge = _Utils_ge;
    var $author$project$Elm$Syntax$Expression$GLSLExpression = function (a) {
        return { $: 23, a: a };
    };
    var $author$project$ParserFast$loopUntilHelp_fn = function (endParser, element, soFar, reduce, foldedToRes, s0) {
        loopUntilHelp: while (true) {
            var parseEnd = endParser;
            var parseElement = element;
            var _v0 = parseEnd(s0);
            if (!_v0.$) {
                var s1 = _v0.b;
                return $author$project$ParserFast$Good_fn(foldedToRes(soFar), s1);
            }
            else {
                var endCommitted = _v0.a;
                var endX = _v0.b;
                if (endCommitted) {
                    return $author$project$ParserFast$Bad_fn(true, endX);
                }
                else {
                    var _v1 = parseElement(s0);
                    if (!_v1.$) {
                        var elementResult = _v1.a;
                        var s1 = _v1.b;
                        var $temp$endParser = endParser, $temp$element = element, $temp$soFar = A2(reduce, elementResult, soFar), $temp$reduce = reduce, $temp$foldedToRes = foldedToRes, $temp$s0 = s1;
                        endParser = $temp$endParser;
                        element = $temp$element;
                        soFar = $temp$soFar;
                        reduce = $temp$reduce;
                        foldedToRes = $temp$foldedToRes;
                        s0 = $temp$s0;
                        continue loopUntilHelp;
                    }
                    else {
                        var x = _v1.b;
                        return $author$project$ParserFast$Bad_fn(true, $author$project$ParserFast$ExpectingOneOf_fn(x, endX, _List_Nil));
                    }
                }
            }
        }
    }, $author$project$ParserFast$loopUntilHelp_fn_unwrapped = function (endParser, element, soFar, reduce, foldedToRes, s0) {
        loopUntilHelp: while (true) {
            var parseEnd = endParser;
            var parseElement = element;
            var _v0 = parseEnd(s0);
            if (!_v0.$) {
                var s1 = _v0.b;
                return $author$project$ParserFast$Good_fn(foldedToRes(soFar), s1);
            }
            else {
                var endCommitted = _v0.a;
                var endX = _v0.b;
                if (endCommitted) {
                    return $author$project$ParserFast$Bad_fn(true, endX);
                }
                else {
                    var _v1 = parseElement(s0);
                    if (!_v1.$) {
                        var elementResult = _v1.a;
                        var s1 = _v1.b;
                        var $temp$endParser = endParser, $temp$element = element, $temp$soFar = reduce(elementResult, soFar), $temp$reduce = reduce, $temp$foldedToRes = foldedToRes, $temp$s0 = s1;
                        endParser = $temp$endParser;
                        element = $temp$element;
                        soFar = $temp$soFar;
                        reduce = $temp$reduce;
                        foldedToRes = $temp$foldedToRes;
                        s0 = $temp$s0;
                        continue loopUntilHelp;
                    }
                    else {
                        var x = _v1.b;
                        return $author$project$ParserFast$Bad_fn(true, $author$project$ParserFast$ExpectingOneOf_fn(x, endX, _List_Nil));
                    }
                }
            }
        }
    }, $author$project$ParserFast$loopUntilHelp = F6($author$project$ParserFast$loopUntilHelp_fn);
    var $author$project$ParserFast$loopUntil_fn = function (endParser, element, initialFolded, reduce, foldedToRes) {
        return function (s) {
            return $author$project$ParserFast$loopUntilHelp_fn(endParser, element, initialFolded, reduce, foldedToRes, s);
        };
    }, $author$project$ParserFast$loopUntil = F5($author$project$ParserFast$loopUntil_fn);
    var $author$project$ParserFast$mapWithRange_fn = function (combineStartAndResult, _v0) {
        var parse = _v0;
        return function (s0) {
            var _v1 = parse(s0);
            if (!_v1.$) {
                var a = _v1.a;
                var s1 = _v1.b;
                return $author$project$ParserFast$Good_fn(A2(combineStartAndResult, {
                    cm: { bk: s1.a, bz: s1.bz },
                    bE: { bk: s0.a, bz: s0.bz }
                }, a), s1);
            }
            else {
                var committed = _v1.a;
                var x = _v1.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
        };
    }, $author$project$ParserFast$mapWithRange_fn_unwrapped = function (combineStartAndResult, _v0) {
        var parse = _v0;
        return function (s0) {
            var _v1 = parse(s0);
            if (!_v1.$) {
                var a = _v1.a;
                var s1 = _v1.b;
                return $author$project$ParserFast$Good_fn(combineStartAndResult({
                    cm: { bk: s1.a, bz: s1.bz },
                    bE: { bk: s0.a, bz: s0.bz }
                }, a), s1);
            }
            else {
                var committed = _v1.a;
                var x = _v1.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
        };
    }, $author$project$ParserFast$mapWithRange = F2($author$project$ParserFast$mapWithRange_fn);
    var $author$project$Elm$Parser$Expression$glslExpressionAfterOpeningSquareBracket = $author$project$ParserFast$symbolFollowedBy_fn("glsl|", $author$project$ParserFast$mapWithRange_fn_unwrapped(function (range, s) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn({
                cm: { bk: range.cm.bk + 2, bz: range.cm.bz },
                bE: { bk: range.bE.bk - 6, bz: range.bE.bz }
            }, $author$project$Elm$Syntax$Expression$GLSLExpression(s))
        };
    }, $author$project$ParserFast$loopUntil_fn($author$project$ParserFast$symbol_fn("|]", 0), $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbol_fn("|", "|"), $author$project$ParserFast$while(function (c) {
        return c !== "|";
    })), "", F2(function (extension, soFar) {
        return soFar + (extension + "");
    }), $elm$core$Basics$identity)));
    var $author$project$ParserFast$ExpectingKeyword_fn = function (a, b, c) {
        return { $: 3, a: a, b: b, c: c };
    }, $author$project$ParserFast$ExpectingKeyword = F3($author$project$ParserFast$ExpectingKeyword_fn);
    var $author$project$Char$Extra$isLatinAlphaNumOrUnderscoreFast = function (c) {
        var code = $elm$core$Char$toCode(c);
        return $author$project$Char$Extra$charCodeIsLower(code) || ($author$project$Char$Extra$charCodeIsUpper(code) || ($author$project$Char$Extra$charCodeIsDigit(code) || (code === 95)));
    };
    var $author$project$ParserFast$isSubCharAlphaNumOrUnderscore_fn = function (offset, string) {
        return _String_any_fn($author$project$Char$Extra$isLatinAlphaNumOrUnderscoreFast, _String_slice_fn(offset, offset + 1, string));
    }, $author$project$ParserFast$isSubCharAlphaNumOrUnderscore = F2($author$project$ParserFast$isSubCharAlphaNumOrUnderscore_fn);
    var $author$project$ParserFast$keyword_fn = function (kwd, res) {
        var kwdLength = $elm$core$String$length(kwd);
        return function (s) {
            var newOffset = s.b + kwdLength;
            return (_Utils_eq(_String_slice_fn(s.b, newOffset, s.c), kwd + "") && (!$author$project$ParserFast$isSubCharAlphaNumOrUnderscore_fn(newOffset, s.c))) ? $author$project$ParserFast$Good_fn(res, { a: s.a + kwdLength, f: s.f, b: newOffset, bz: s.bz, c: s.c }) : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingKeyword_fn(s.bz, s.a, kwd));
        };
    }, $author$project$ParserFast$keyword = F2($author$project$ParserFast$keyword_fn);
    var $author$project$Elm$Parser$Tokens$inToken = $author$project$ParserFast$keyword_fn("in", 0);
    var $author$project$ParserFast$keywordFollowedBy_fn = function (kwd, _v0) {
        var parseNext = _v0;
        var kwdLength = $elm$core$String$length(kwd);
        return function (s) {
            var newOffset = s.b + kwdLength;
            return (_Utils_eq(_String_slice_fn(s.b, newOffset, s.c), kwd + "") && (!$author$project$ParserFast$isSubCharAlphaNumOrUnderscore_fn(newOffset, s.c))) ? $author$project$ParserFast$pStepCommit(parseNext({ a: s.a + kwdLength, f: s.f, b: newOffset, bz: s.bz, c: s.c })) : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingKeyword_fn(s.bz, s.a, kwd));
        };
    }, $author$project$ParserFast$keywordFollowedBy = F2($author$project$ParserFast$keywordFollowedBy_fn);
    var $author$project$ParserFast$columnIndentAndThen = function (callback) {
        return function (s) {
            var _v0 = A2(callback, s.a, s.f);
            var parse = _v0;
            return parse(s);
        };
    }, $author$project$ParserFast$columnIndentAndThen_unwrapped = function (callback) {
        return function (s) {
            var _v0 = callback(s.a, s.f);
            var parse = _v0;
            return parse(s);
        };
    };
    var $author$project$Elm$Parser$Layout$problemTopIndentation = $author$project$ParserFast$problem("must be on top indentation");
    var $author$project$Elm$Parser$Layout$onTopIndentationFollowedBy = function (nextParser) {
        return $author$project$ParserFast$columnIndentAndThen_unwrapped(function (column, indent) {
            return (!(column - indent)) ? nextParser : $author$project$Elm$Parser$Layout$problemTopIndentation;
        });
    };
    var $author$project$Elm$Parser$Layout$layoutStrictFollowedBy = function (nextParser) {
        return $author$project$ParserFast$map2_fn_unwrapped(function (commentsBefore, after) {
            return { e: commentsBefore, d: after };
        }, $author$project$Elm$Parser$Layout$optimisticLayout, $author$project$Elm$Parser$Layout$onTopIndentationFollowedBy(nextParser));
    };
    var $author$project$ParserFast$lazy = function (thunk) {
        return function (s) {
            var _v0 = thunk(0);
            var parse = _v0;
            return parse(s);
        };
    };
    var $author$project$Elm$Syntax$Expression$Literal = function (a) {
        return { $: 11, a: a };
    };
    var $author$project$ParserFast$whileWithoutLinebreak = function (isGood) {
        return function (s0) {
            var s1 = $author$project$ParserFast$skipWhileWithoutLinebreakHelp_fn(isGood, s0.b, s0.bz, s0.a, s0.c, s0.f);
            return $author$project$ParserFast$Good_fn(_String_slice_fn(s0.b, s1.b, s0.c), s1);
        };
    };
    var $author$project$Elm$Parser$Tokens$singleQuotedStringLiteralAfterDoubleQuote = $author$project$ParserFast$loopUntil_fn($author$project$ParserFast$symbol_fn("\"", 0), $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbolFollowedBy_fn("\\", $author$project$Elm$Parser$Tokens$escapedCharValueMap($elm$core$String$fromChar)), $author$project$ParserFast$whileWithoutLinebreak(function (c) {
        return (c !== "\"") && ((c !== "\\") && (!$author$project$Char$Extra$isUtf16Surrogate(c)));
    })), "", F2(function (extension, soFar) {
        return soFar + (extension + "");
    }), $elm$core$Basics$identity);
    var $author$project$Elm$Parser$Tokens$tripleQuotedStringLiteralOfterTripleDoubleQuote = $author$project$ParserFast$loopUntil_fn($author$project$ParserFast$symbol_fn("\"\"\"", 0), $author$project$ParserFast$oneOf3_fn($author$project$ParserFast$symbol_fn("\"", "\""), $author$project$ParserFast$symbolFollowedBy_fn("\\", $author$project$Elm$Parser$Tokens$escapedCharValueMap($elm$core$String$fromChar)), $author$project$ParserFast$while(function (c) {
        return (c !== "\"") && ((c !== "\\") && (!$author$project$Char$Extra$isUtf16Surrogate(c)));
    })), "", F2(function (extension, soFar) {
        return soFar + (extension + "");
    }), $elm$core$Basics$identity);
    var $author$project$Elm$Parser$Tokens$singleOrTripleQuotedStringLiteralMapWithRange = function (rangeAndStringToRes) {
        return $author$project$ParserFast$symbolFollowedBy_fn("\"", $author$project$ParserFast$oneOf2MapWithStartRowColumnAndEndRowColumn_fn(F5(function (startRow, startColumn, string, endRow, endColumn) {
            return A2(rangeAndStringToRes, {
                cm: { bk: endColumn, bz: endRow },
                bE: { bk: startColumn - 1, bz: startRow }
            }, string);
        }), $author$project$ParserFast$symbolFollowedBy_fn("\"\"", $author$project$Elm$Parser$Tokens$tripleQuotedStringLiteralOfterTripleDoubleQuote), F5(function (startRow, startColumn, string, endRow, endColumn) {
            return A2(rangeAndStringToRes, {
                cm: { bk: endColumn, bz: endRow },
                bE: { bk: startColumn - 1, bz: startRow }
            }, string);
        }), $author$project$Elm$Parser$Tokens$singleQuotedStringLiteralAfterDoubleQuote));
    }, $author$project$Elm$Parser$Tokens$singleOrTripleQuotedStringLiteralMapWithRange_unwrapped = function (rangeAndStringToRes) {
        return $author$project$ParserFast$symbolFollowedBy_fn("\"", $author$project$ParserFast$oneOf2MapWithStartRowColumnAndEndRowColumn_fn(F5(function (startRow, startColumn, string, endRow, endColumn) {
            return rangeAndStringToRes({
                cm: { bk: endColumn, bz: endRow },
                bE: { bk: startColumn - 1, bz: startRow }
            }, string);
        }), $author$project$ParserFast$symbolFollowedBy_fn("\"\"", $author$project$Elm$Parser$Tokens$tripleQuotedStringLiteralOfterTripleDoubleQuote), F5(function (startRow, startColumn, string, endRow, endColumn) {
            return rangeAndStringToRes({
                cm: { bk: endColumn, bz: endRow },
                bE: { bk: startColumn - 1, bz: startRow }
            }, string);
        }), $author$project$Elm$Parser$Tokens$singleQuotedStringLiteralAfterDoubleQuote));
    };
    var $author$project$Elm$Parser$Expression$literalExpression = $author$project$Elm$Parser$Tokens$singleOrTripleQuotedStringLiteralMapWithRange_unwrapped(function (range, string) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Expression$Literal(string))
        };
    });
    var $author$project$Elm$Parser$Expression$literalExpressionOptimisticLayout = $author$project$Elm$Parser$Expression$followedByOptimisticLayout($author$project$Elm$Parser$Expression$literalExpression);
    var $author$project$ParserWithComments$many = function (p) {
        return $author$project$ParserFast$loopWhileSucceeds_fn(p, _Utils_Tuple2($author$project$Rope$empty, _List_Nil), F2(function (pResult, _v0) {
            var commentsSoFar = _v0.a;
            var itemsSoFar = _v0.b;
            return _Utils_Tuple2($author$project$Rope$prependTo_fn(pResult.e, commentsSoFar), _List_Cons(pResult.d, itemsSoFar));
        }), function (_v1) {
            var commentsSoFar = _v1.a;
            var itemsSoFar = _v1.b;
            return {
                e: commentsSoFar,
                d: $elm$core$List$reverse(itemsSoFar)
            };
        });
    };
    var $author$project$ParserWithComments$manyWithoutReverse = function (p) {
        return $author$project$ParserFast$loopWhileSucceeds_fn(p, _Utils_Tuple2($author$project$Rope$empty, _List_Nil), F2(function (pResult, _v0) {
            var commentsSoFar = _v0.a;
            var itemsSoFar = _v0.b;
            return _Utils_Tuple2($author$project$Rope$prependTo_fn(pResult.e, commentsSoFar), _List_Cons(pResult.d, itemsSoFar));
        }), function (_v1) {
            var commentsSoFar = _v1.a;
            var itemsSoFar = _v1.b;
            return { e: commentsSoFar, d: itemsSoFar };
        });
    };
    var $author$project$ParserFast$map_fn = function (func, _v0) {
        var parse = _v0;
        return function (s0) {
            var _v1 = parse(s0);
            if (!_v1.$) {
                var a = _v1.a;
                var s1 = _v1.b;
                return $author$project$ParserFast$Good_fn(func(a), s1);
            }
            else {
                var committed = _v1.a;
                var x = _v1.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
        };
    }, $author$project$ParserFast$map = F2($author$project$ParserFast$map_fn);
    var $author$project$ParserFast$map3_fn = function (func, _v0, _v1, _v2) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        return function (s0) {
            var _v3 = parseA(s0);
            if (_v3.$ === 1) {
                var committed = _v3.a;
                var x = _v3.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v3.a;
                var s1 = _v3.b;
                var _v4 = parseB(s1);
                if (_v4.$ === 1) {
                    var x = _v4.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v4.a;
                    var s2 = _v4.b;
                    var _v5 = parseC(s2);
                    if (_v5.$ === 1) {
                        var x = _v5.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v5.a;
                        var s3 = _v5.b;
                        return $author$project$ParserFast$Good_fn(A3(func, a, b, c), s3);
                    }
                }
            }
        };
    }, $author$project$ParserFast$map3_fn_unwrapped = function (func, _v0, _v1, _v2) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        return function (s0) {
            var _v3 = parseA(s0);
            if (_v3.$ === 1) {
                var committed = _v3.a;
                var x = _v3.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v3.a;
                var s1 = _v3.b;
                var _v4 = parseB(s1);
                if (_v4.$ === 1) {
                    var x = _v4.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v4.a;
                    var s2 = _v4.b;
                    var _v5 = parseC(s2);
                    if (_v5.$ === 1) {
                        var x = _v5.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v5.a;
                        var s3 = _v5.b;
                        return $author$project$ParserFast$Good_fn(func(a, b, c), s3);
                    }
                }
            }
        };
    }, $author$project$ParserFast$map3 = F4($author$project$ParserFast$map3_fn);
    var $author$project$ParserFast$map3WithStartLocation_fn = function (func, _v0, _v1, _v2) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        return function (s0) {
            var _v3 = parseA(s0);
            if (_v3.$ === 1) {
                var committed = _v3.a;
                var x = _v3.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v3.a;
                var s1 = _v3.b;
                var _v4 = parseB(s1);
                if (_v4.$ === 1) {
                    var x = _v4.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v4.a;
                    var s2 = _v4.b;
                    var _v5 = parseC(s2);
                    if (_v5.$ === 1) {
                        var x = _v5.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v5.a;
                        var s3 = _v5.b;
                        return $author$project$ParserFast$Good_fn(A4(func, { bk: s0.a, bz: s0.bz }, a, b, c), s3);
                    }
                }
            }
        };
    }, $author$project$ParserFast$map3WithStartLocation_fn_unwrapped = function (func, _v0, _v1, _v2) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        return function (s0) {
            var _v3 = parseA(s0);
            if (_v3.$ === 1) {
                var committed = _v3.a;
                var x = _v3.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v3.a;
                var s1 = _v3.b;
                var _v4 = parseB(s1);
                if (_v4.$ === 1) {
                    var x = _v4.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v4.a;
                    var s2 = _v4.b;
                    var _v5 = parseC(s2);
                    if (_v5.$ === 1) {
                        var x = _v5.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v5.a;
                        var s3 = _v5.b;
                        return $author$project$ParserFast$Good_fn(func({ bk: s0.a, bz: s0.bz }, a, b, c), s3);
                    }
                }
            }
        };
    }, $author$project$ParserFast$map3WithStartLocation = F4($author$project$ParserFast$map3WithStartLocation_fn);
    var $author$project$ParserFast$map4_fn = function (func, _v0, _v1, _v2, _v3) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        return function (s0) {
            var _v4 = parseA(s0);
            if (_v4.$ === 1) {
                var committed = _v4.a;
                var x = _v4.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v4.a;
                var s1 = _v4.b;
                var _v5 = parseB(s1);
                if (_v5.$ === 1) {
                    var x = _v5.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v5.a;
                    var s2 = _v5.b;
                    var _v6 = parseC(s2);
                    if (_v6.$ === 1) {
                        var x = _v6.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v6.a;
                        var s3 = _v6.b;
                        var _v7 = parseD(s3);
                        if (_v7.$ === 1) {
                            var x = _v7.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v7.a;
                            var s4 = _v7.b;
                            return $author$project$ParserFast$Good_fn(A4(func, a, b, c, d), s4);
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map4_fn_unwrapped = function (func, _v0, _v1, _v2, _v3) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        return function (s0) {
            var _v4 = parseA(s0);
            if (_v4.$ === 1) {
                var committed = _v4.a;
                var x = _v4.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v4.a;
                var s1 = _v4.b;
                var _v5 = parseB(s1);
                if (_v5.$ === 1) {
                    var x = _v5.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v5.a;
                    var s2 = _v5.b;
                    var _v6 = parseC(s2);
                    if (_v6.$ === 1) {
                        var x = _v6.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v6.a;
                        var s3 = _v6.b;
                        var _v7 = parseD(s3);
                        if (_v7.$ === 1) {
                            var x = _v7.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v7.a;
                            var s4 = _v7.b;
                            return $author$project$ParserFast$Good_fn(func(a, b, c, d), s4);
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map4 = F5($author$project$ParserFast$map4_fn);
    var $author$project$ParserFast$map4OrSucceed_fn = function (func, _v0, _v1, _v2, _v3, fallback) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        return function (s0) {
            var _v4 = parseA(s0);
            if (_v4.$ === 1) {
                var c1 = _v4.a;
                var x = _v4.b;
                return c1 ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(fallback, s0);
            }
            else {
                var a = _v4.a;
                var s1 = _v4.b;
                var _v5 = parseB(s1);
                if (_v5.$ === 1) {
                    var x = _v5.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v5.a;
                    var s2 = _v5.b;
                    var _v6 = parseC(s2);
                    if (_v6.$ === 1) {
                        var x = _v6.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v6.a;
                        var s3 = _v6.b;
                        var _v7 = parseD(s3);
                        if (_v7.$ === 1) {
                            var x = _v7.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v7.a;
                            var s4 = _v7.b;
                            return $author$project$ParserFast$Good_fn(A4(func, a, b, c, d), s4);
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map4OrSucceed_fn_unwrapped = function (func, _v0, _v1, _v2, _v3, fallback) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        return function (s0) {
            var _v4 = parseA(s0);
            if (_v4.$ === 1) {
                var c1 = _v4.a;
                var x = _v4.b;
                return c1 ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(fallback, s0);
            }
            else {
                var a = _v4.a;
                var s1 = _v4.b;
                var _v5 = parseB(s1);
                if (_v5.$ === 1) {
                    var x = _v5.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v5.a;
                    var s2 = _v5.b;
                    var _v6 = parseC(s2);
                    if (_v6.$ === 1) {
                        var x = _v6.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v6.a;
                        var s3 = _v6.b;
                        var _v7 = parseD(s3);
                        if (_v7.$ === 1) {
                            var x = _v7.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v7.a;
                            var s4 = _v7.b;
                            return $author$project$ParserFast$Good_fn(func(a, b, c, d), s4);
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map4OrSucceed = F6($author$project$ParserFast$map4OrSucceed_fn);
    var $author$project$ParserFast$map4WithRange_fn = function (func, _v0, _v1, _v2, _v3) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        return function (s0) {
            var _v4 = parseA(s0);
            if (_v4.$ === 1) {
                var committed = _v4.a;
                var x = _v4.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v4.a;
                var s1 = _v4.b;
                var _v5 = parseB(s1);
                if (_v5.$ === 1) {
                    var x = _v5.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v5.a;
                    var s2 = _v5.b;
                    var _v6 = parseC(s2);
                    if (_v6.$ === 1) {
                        var x = _v6.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v6.a;
                        var s3 = _v6.b;
                        var _v7 = parseD(s3);
                        if (_v7.$ === 1) {
                            var x = _v7.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v7.a;
                            var s4 = _v7.b;
                            return $author$project$ParserFast$Good_fn(A5(func, {
                                cm: { bk: s4.a, bz: s4.bz },
                                bE: { bk: s0.a, bz: s0.bz }
                            }, a, b, c, d), s4);
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map4WithRange_fn_unwrapped = function (func, _v0, _v1, _v2, _v3) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        return function (s0) {
            var _v4 = parseA(s0);
            if (_v4.$ === 1) {
                var committed = _v4.a;
                var x = _v4.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v4.a;
                var s1 = _v4.b;
                var _v5 = parseB(s1);
                if (_v5.$ === 1) {
                    var x = _v5.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v5.a;
                    var s2 = _v5.b;
                    var _v6 = parseC(s2);
                    if (_v6.$ === 1) {
                        var x = _v6.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v6.a;
                        var s3 = _v6.b;
                        var _v7 = parseD(s3);
                        if (_v7.$ === 1) {
                            var x = _v7.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v7.a;
                            var s4 = _v7.b;
                            return $author$project$ParserFast$Good_fn(func({
                                cm: { bk: s4.a, bz: s4.bz },
                                bE: { bk: s0.a, bz: s0.bz }
                            }, a, b, c, d), s4);
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map4WithRange = F5($author$project$ParserFast$map4WithRange_fn);
    var $author$project$ParserFast$map5_fn = function (func, _v0, _v1, _v2, _v3, _v4) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        return function (s0) {
            var _v5 = parseA(s0);
            if (_v5.$ === 1) {
                var committed = _v5.a;
                var x = _v5.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v5.a;
                var s1 = _v5.b;
                var _v6 = parseB(s1);
                if (_v6.$ === 1) {
                    var x = _v6.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v6.a;
                    var s2 = _v6.b;
                    var _v7 = parseC(s2);
                    if (_v7.$ === 1) {
                        var x = _v7.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v7.a;
                        var s3 = _v7.b;
                        var _v8 = parseD(s3);
                        if (_v8.$ === 1) {
                            var x = _v8.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v8.a;
                            var s4 = _v8.b;
                            var _v9 = parseE(s4);
                            if (_v9.$ === 1) {
                                var x = _v9.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v9.a;
                                var s5 = _v9.b;
                                return $author$project$ParserFast$Good_fn(A5(func, a, b, c, d, e), s5);
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map5_fn_unwrapped = function (func, _v0, _v1, _v2, _v3, _v4) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        return function (s0) {
            var _v5 = parseA(s0);
            if (_v5.$ === 1) {
                var committed = _v5.a;
                var x = _v5.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v5.a;
                var s1 = _v5.b;
                var _v6 = parseB(s1);
                if (_v6.$ === 1) {
                    var x = _v6.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v6.a;
                    var s2 = _v6.b;
                    var _v7 = parseC(s2);
                    if (_v7.$ === 1) {
                        var x = _v7.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v7.a;
                        var s3 = _v7.b;
                        var _v8 = parseD(s3);
                        if (_v8.$ === 1) {
                            var x = _v8.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v8.a;
                            var s4 = _v8.b;
                            var _v9 = parseE(s4);
                            if (_v9.$ === 1) {
                                var x = _v9.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v9.a;
                                var s5 = _v9.b;
                                return $author$project$ParserFast$Good_fn(func(a, b, c, d, e), s5);
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map5 = F6($author$project$ParserFast$map5_fn);
    var $author$project$ParserFast$map5WithRange_fn = function (func, _v0, _v1, _v2, _v3, _v4) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        return function (s0) {
            var _v5 = parseA(s0);
            if (_v5.$ === 1) {
                var committed = _v5.a;
                var x = _v5.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v5.a;
                var s1 = _v5.b;
                var _v6 = parseB(s1);
                if (_v6.$ === 1) {
                    var x = _v6.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v6.a;
                    var s2 = _v6.b;
                    var _v7 = parseC(s2);
                    if (_v7.$ === 1) {
                        var x = _v7.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v7.a;
                        var s3 = _v7.b;
                        var _v8 = parseD(s3);
                        if (_v8.$ === 1) {
                            var x = _v8.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v8.a;
                            var s4 = _v8.b;
                            var _v9 = parseE(s4);
                            if (_v9.$ === 1) {
                                var x = _v9.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v9.a;
                                var s5 = _v9.b;
                                return $author$project$ParserFast$Good_fn(A6(func, {
                                    cm: { bk: s5.a, bz: s5.bz },
                                    bE: { bk: s0.a, bz: s0.bz }
                                }, a, b, c, d, e), s5);
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map5WithRange_fn_unwrapped = function (func, _v0, _v1, _v2, _v3, _v4) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        return function (s0) {
            var _v5 = parseA(s0);
            if (_v5.$ === 1) {
                var committed = _v5.a;
                var x = _v5.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v5.a;
                var s1 = _v5.b;
                var _v6 = parseB(s1);
                if (_v6.$ === 1) {
                    var x = _v6.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v6.a;
                    var s2 = _v6.b;
                    var _v7 = parseC(s2);
                    if (_v7.$ === 1) {
                        var x = _v7.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v7.a;
                        var s3 = _v7.b;
                        var _v8 = parseD(s3);
                        if (_v8.$ === 1) {
                            var x = _v8.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v8.a;
                            var s4 = _v8.b;
                            var _v9 = parseE(s4);
                            if (_v9.$ === 1) {
                                var x = _v9.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v9.a;
                                var s5 = _v9.b;
                                return $author$project$ParserFast$Good_fn(func({
                                    cm: { bk: s5.a, bz: s5.bz },
                                    bE: { bk: s0.a, bz: s0.bz }
                                }, a, b, c, d, e), s5);
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map5WithRange = F6($author$project$ParserFast$map5WithRange_fn);
    var $author$project$ParserFast$map5WithStartLocation_fn = function (func, _v0, _v1, _v2, _v3, _v4) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        return function (s0) {
            var _v5 = parseA(s0);
            if (_v5.$ === 1) {
                var committed = _v5.a;
                var x = _v5.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v5.a;
                var s1 = _v5.b;
                var _v6 = parseB(s1);
                if (_v6.$ === 1) {
                    var x = _v6.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v6.a;
                    var s2 = _v6.b;
                    var _v7 = parseC(s2);
                    if (_v7.$ === 1) {
                        var x = _v7.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v7.a;
                        var s3 = _v7.b;
                        var _v8 = parseD(s3);
                        if (_v8.$ === 1) {
                            var x = _v8.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v8.a;
                            var s4 = _v8.b;
                            var _v9 = parseE(s4);
                            if (_v9.$ === 1) {
                                var x = _v9.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v9.a;
                                var s5 = _v9.b;
                                return $author$project$ParserFast$Good_fn(A6(func, { bk: s0.a, bz: s0.bz }, a, b, c, d, e), s5);
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map5WithStartLocation_fn_unwrapped = function (func, _v0, _v1, _v2, _v3, _v4) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        return function (s0) {
            var _v5 = parseA(s0);
            if (_v5.$ === 1) {
                var committed = _v5.a;
                var x = _v5.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v5.a;
                var s1 = _v5.b;
                var _v6 = parseB(s1);
                if (_v6.$ === 1) {
                    var x = _v6.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v6.a;
                    var s2 = _v6.b;
                    var _v7 = parseC(s2);
                    if (_v7.$ === 1) {
                        var x = _v7.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v7.a;
                        var s3 = _v7.b;
                        var _v8 = parseD(s3);
                        if (_v8.$ === 1) {
                            var x = _v8.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v8.a;
                            var s4 = _v8.b;
                            var _v9 = parseE(s4);
                            if (_v9.$ === 1) {
                                var x = _v9.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v9.a;
                                var s5 = _v9.b;
                                return $author$project$ParserFast$Good_fn(func({ bk: s0.a, bz: s0.bz }, a, b, c, d, e), s5);
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map5WithStartLocation = F6($author$project$ParserFast$map5WithStartLocation_fn);
    var $author$project$ParserFast$map6WithStartLocation_fn = function (func, _v0, _v1, _v2, _v3, _v4, _v5) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        var parseF = _v5;
        return function (s0) {
            var _v6 = parseA(s0);
            if (_v6.$ === 1) {
                var committed = _v6.a;
                var x = _v6.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v6.a;
                var s1 = _v6.b;
                var _v7 = parseB(s1);
                if (_v7.$ === 1) {
                    var x = _v7.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v7.a;
                    var s2 = _v7.b;
                    var _v8 = parseC(s2);
                    if (_v8.$ === 1) {
                        var x = _v8.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v8.a;
                        var s3 = _v8.b;
                        var _v9 = parseD(s3);
                        if (_v9.$ === 1) {
                            var x = _v9.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v9.a;
                            var s4 = _v9.b;
                            var _v10 = parseE(s4);
                            if (_v10.$ === 1) {
                                var x = _v10.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v10.a;
                                var s5 = _v10.b;
                                var _v11 = parseF(s5);
                                if (_v11.$ === 1) {
                                    var x = _v11.b;
                                    return $author$project$ParserFast$Bad_fn(true, x);
                                }
                                else {
                                    var f = _v11.a;
                                    var s6 = _v11.b;
                                    return $author$project$ParserFast$Good_fn(A7(func, { bk: s0.a, bz: s0.bz }, a, b, c, d, e, f), s6);
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map6WithStartLocation_fn_unwrapped = function (func, _v0, _v1, _v2, _v3, _v4, _v5) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        var parseF = _v5;
        return function (s0) {
            var _v6 = parseA(s0);
            if (_v6.$ === 1) {
                var committed = _v6.a;
                var x = _v6.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v6.a;
                var s1 = _v6.b;
                var _v7 = parseB(s1);
                if (_v7.$ === 1) {
                    var x = _v7.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v7.a;
                    var s2 = _v7.b;
                    var _v8 = parseC(s2);
                    if (_v8.$ === 1) {
                        var x = _v8.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v8.a;
                        var s3 = _v8.b;
                        var _v9 = parseD(s3);
                        if (_v9.$ === 1) {
                            var x = _v9.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v9.a;
                            var s4 = _v9.b;
                            var _v10 = parseE(s4);
                            if (_v10.$ === 1) {
                                var x = _v10.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v10.a;
                                var s5 = _v10.b;
                                var _v11 = parseF(s5);
                                if (_v11.$ === 1) {
                                    var x = _v11.b;
                                    return $author$project$ParserFast$Bad_fn(true, x);
                                }
                                else {
                                    var f = _v11.a;
                                    var s6 = _v11.b;
                                    return $author$project$ParserFast$Good_fn(func({ bk: s0.a, bz: s0.bz }, a, b, c, d, e, f), s6);
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map6WithStartLocation = F7($author$project$ParserFast$map6WithStartLocation_fn);
    var $author$project$ParserFast$map8WithStartLocation_fn = function (func, _v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        var parseF = _v5;
        var parseG = _v6;
        var parseH = _v7;
        return function (s0) {
            var _v8 = parseA(s0);
            if (_v8.$ === 1) {
                var committed = _v8.a;
                var x = _v8.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v8.a;
                var s1 = _v8.b;
                var _v9 = parseB(s1);
                if (_v9.$ === 1) {
                    var x = _v9.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v9.a;
                    var s2 = _v9.b;
                    var _v10 = parseC(s2);
                    if (_v10.$ === 1) {
                        var x = _v10.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v10.a;
                        var s3 = _v10.b;
                        var _v11 = parseD(s3);
                        if (_v11.$ === 1) {
                            var x = _v11.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v11.a;
                            var s4 = _v11.b;
                            var _v12 = parseE(s4);
                            if (_v12.$ === 1) {
                                var x = _v12.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v12.a;
                                var s5 = _v12.b;
                                var _v13 = parseF(s5);
                                if (_v13.$ === 1) {
                                    var x = _v13.b;
                                    return $author$project$ParserFast$Bad_fn(true, x);
                                }
                                else {
                                    var f = _v13.a;
                                    var s6 = _v13.b;
                                    var _v14 = parseG(s6);
                                    if (_v14.$ === 1) {
                                        var x = _v14.b;
                                        return $author$project$ParserFast$Bad_fn(true, x);
                                    }
                                    else {
                                        var g = _v14.a;
                                        var s7 = _v14.b;
                                        var _v15 = parseH(s7);
                                        if (_v15.$ === 1) {
                                            var x = _v15.b;
                                            return $author$project$ParserFast$Bad_fn(true, x);
                                        }
                                        else {
                                            var h = _v15.a;
                                            var s8 = _v15.b;
                                            return $author$project$ParserFast$Good_fn(A9(func, { bk: s0.a, bz: s0.bz }, a, b, c, d, e, f, g, h), s8);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map8WithStartLocation_fn_unwrapped = function (func, _v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        var parseF = _v5;
        var parseG = _v6;
        var parseH = _v7;
        return function (s0) {
            var _v8 = parseA(s0);
            if (_v8.$ === 1) {
                var committed = _v8.a;
                var x = _v8.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v8.a;
                var s1 = _v8.b;
                var _v9 = parseB(s1);
                if (_v9.$ === 1) {
                    var x = _v9.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v9.a;
                    var s2 = _v9.b;
                    var _v10 = parseC(s2);
                    if (_v10.$ === 1) {
                        var x = _v10.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v10.a;
                        var s3 = _v10.b;
                        var _v11 = parseD(s3);
                        if (_v11.$ === 1) {
                            var x = _v11.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v11.a;
                            var s4 = _v11.b;
                            var _v12 = parseE(s4);
                            if (_v12.$ === 1) {
                                var x = _v12.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v12.a;
                                var s5 = _v12.b;
                                var _v13 = parseF(s5);
                                if (_v13.$ === 1) {
                                    var x = _v13.b;
                                    return $author$project$ParserFast$Bad_fn(true, x);
                                }
                                else {
                                    var f = _v13.a;
                                    var s6 = _v13.b;
                                    var _v14 = parseG(s6);
                                    if (_v14.$ === 1) {
                                        var x = _v14.b;
                                        return $author$project$ParserFast$Bad_fn(true, x);
                                    }
                                    else {
                                        var g = _v14.a;
                                        var s7 = _v14.b;
                                        var _v15 = parseH(s7);
                                        if (_v15.$ === 1) {
                                            var x = _v15.b;
                                            return $author$project$ParserFast$Bad_fn(true, x);
                                        }
                                        else {
                                            var h = _v15.a;
                                            var s8 = _v15.b;
                                            return $author$project$ParserFast$Good_fn(func({ bk: s0.a, bz: s0.bz }, a, b, c, d, e, f, g, h), s8);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map8WithStartLocation = F9($author$project$ParserFast$map8WithStartLocation_fn);
    var $author$project$ParserFast$validateEndColumnIndentation_fn = function (isOkay, problemOnIsNotOkay, _v0) {
        var parse = _v0;
        return function (s0) {
            var _v1 = parse(s0);
            if (!_v1.$) {
                var good = _v1;
                var s1 = good.b;
                return A2(isOkay, s1.a, s1.f) ? good : $author$project$ParserFast$Bad_fn(true, $author$project$ParserFast$ExpectingCustom_fn(s1.bz, s1.a, problemOnIsNotOkay));
            }
            else {
                var bad = _v1;
                return bad;
            }
        };
    }, $author$project$ParserFast$validateEndColumnIndentation_fn_unwrapped = function (isOkay, problemOnIsNotOkay, _v0) {
        var parse = _v0;
        return function (s0) {
            var _v1 = parse(s0);
            if (!_v1.$) {
                var good = _v1;
                var s1 = good.b;
                return isOkay(s1.a, s1.f) ? good : $author$project$ParserFast$Bad_fn(true, $author$project$ParserFast$ExpectingCustom_fn(s1.bz, s1.a, problemOnIsNotOkay));
            }
            else {
                var bad = _v1;
                return bad;
            }
        };
    }, $author$project$ParserFast$validateEndColumnIndentation = F3($author$project$ParserFast$validateEndColumnIndentation_fn);
    var $author$project$Elm$Parser$Layout$endsPositivelyIndented = function (parser) {
        return $author$project$ParserFast$validateEndColumnIndentation_fn_unwrapped(function (column, indent) {
            return _Utils_cmp(column, indent) > 0;
        }, "must be positively indented", parser);
    };
    var $author$project$Elm$Parser$Layout$maybeLayout = $author$project$Elm$Parser$Layout$endsPositivelyIndented($author$project$Elm$Parser$Layout$whitespaceAndCommentsOrEmpty);
    var $author$project$Elm$Parser$Layout$maybeAroundBothSides = function (x) {
        return $author$project$ParserFast$map3_fn_unwrapped(function (before, v, after) {
            return {
                e: $author$project$Rope$prependTo_fn(after, $author$project$Rope$prependTo_fn(v.e, before)),
                d: v.d
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, x, $author$project$Elm$Parser$Layout$maybeLayout);
    };
    var $author$project$Elm$Parser$Expression$negationWhitespaceProblem = $author$project$ParserFast$problem("if a negation sign is not preceded by whitespace, it's considered subtraction");
    var $author$project$Elm$Syntax$Expression$Floatable = function (a) {
        return { $: 9, a: a };
    };
    var $author$project$Elm$Syntax$Expression$Hex = function (a) {
        return { $: 8, a: a };
    };
    var $author$project$Elm$Syntax$Expression$Integer = function (a) {
        return { $: 7, a: a };
    };
    var $author$project$ParserFast$ExpectingNumber_fn = function (a, b) {
        return { $: 0, a: a, b: b };
    }, $author$project$ParserFast$ExpectingNumber = F2($author$project$ParserFast$ExpectingNumber_fn);
    var $author$project$ParserFast$Decimal = 0;
    var $author$project$ParserFast$Hexadecimal = 1;
    var $author$project$ParserFast$convert0OrMore0To9s_fn = function (soFar, offset, src) {
        convert0OrMore0To9s: while (true) {
            var _v0 = _String_slice_fn(offset, offset + 1, src);
            switch (_v0) {
                case "0":
                    var $temp$soFar = soFar * 10, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMore0To9s;
                case "1":
                    var $temp$soFar = (soFar * 10) + 1, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMore0To9s;
                case "2":
                    var $temp$soFar = (soFar * 10) + 2, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMore0To9s;
                case "3":
                    var $temp$soFar = (soFar * 10) + 3, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMore0To9s;
                case "4":
                    var $temp$soFar = (soFar * 10) + 4, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMore0To9s;
                case "5":
                    var $temp$soFar = (soFar * 10) + 5, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMore0To9s;
                case "6":
                    var $temp$soFar = (soFar * 10) + 6, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMore0To9s;
                case "7":
                    var $temp$soFar = (soFar * 10) + 7, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMore0To9s;
                case "8":
                    var $temp$soFar = (soFar * 10) + 8, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMore0To9s;
                case "9":
                    var $temp$soFar = (soFar * 10) + 9, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMore0To9s;
                default:
                    return { F: soFar, b: offset };
            }
        }
    }, $author$project$ParserFast$convert0OrMore0To9s = F3($author$project$ParserFast$convert0OrMore0To9s_fn);
    var $author$project$ParserFast$convert0OrMoreHexadecimal_fn = function (soFar, offset, src) {
        convert0OrMoreHexadecimal: while (true) {
            var _v0 = _String_slice_fn(offset, offset + 1, src);
            switch (_v0) {
                case "0":
                    var $temp$soFar = soFar * 16, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "1":
                    var $temp$soFar = (soFar * 16) + 1, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "2":
                    var $temp$soFar = (soFar * 16) + 2, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "3":
                    var $temp$soFar = (soFar * 16) + 3, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "4":
                    var $temp$soFar = (soFar * 16) + 4, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "5":
                    var $temp$soFar = (soFar * 16) + 5, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "6":
                    var $temp$soFar = (soFar * 16) + 6, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "7":
                    var $temp$soFar = (soFar * 16) + 7, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "8":
                    var $temp$soFar = (soFar * 16) + 8, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "9":
                    var $temp$soFar = (soFar * 16) + 9, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "a":
                    var $temp$soFar = (soFar * 16) + 10, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "A":
                    var $temp$soFar = (soFar * 16) + 10, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "b":
                    var $temp$soFar = (soFar * 16) + 11, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "B":
                    var $temp$soFar = (soFar * 16) + 11, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "c":
                    var $temp$soFar = (soFar * 16) + 12, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "C":
                    var $temp$soFar = (soFar * 16) + 12, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "d":
                    var $temp$soFar = (soFar * 16) + 13, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "D":
                    var $temp$soFar = (soFar * 16) + 13, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "e":
                    var $temp$soFar = (soFar * 16) + 14, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "E":
                    var $temp$soFar = (soFar * 16) + 14, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "f":
                    var $temp$soFar = (soFar * 16) + 15, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                case "F":
                    var $temp$soFar = (soFar * 16) + 15, $temp$offset = offset + 1, $temp$src = src;
                    soFar = $temp$soFar;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue convert0OrMoreHexadecimal;
                default:
                    return { F: soFar, b: offset };
            }
        }
    }, $author$project$ParserFast$convert0OrMoreHexadecimal = F3($author$project$ParserFast$convert0OrMoreHexadecimal_fn);
    var $author$project$ParserFast$convert1OrMoreHexadecimal_fn = function (offset, src) {
        var _v0 = _String_slice_fn(offset, offset + 1, src);
        switch (_v0) {
            case "0":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(0, offset + 1, src);
            case "1":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(1, offset + 1, src);
            case "2":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(2, offset + 1, src);
            case "3":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(3, offset + 1, src);
            case "4":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(4, offset + 1, src);
            case "5":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(5, offset + 1, src);
            case "6":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(6, offset + 1, src);
            case "7":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(7, offset + 1, src);
            case "8":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(8, offset + 1, src);
            case "9":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(9, offset + 1, src);
            case "a":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(10, offset + 1, src);
            case "A":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(10, offset + 1, src);
            case "b":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(11, offset + 1, src);
            case "B":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(11, offset + 1, src);
            case "c":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(12, offset + 1, src);
            case "C":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(12, offset + 1, src);
            case "d":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(13, offset + 1, src);
            case "D":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(13, offset + 1, src);
            case "e":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(14, offset + 1, src);
            case "E":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(14, offset + 1, src);
            case "f":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(15, offset + 1, src);
            case "F":
                return $author$project$ParserFast$convert0OrMoreHexadecimal_fn(15, offset + 1, src);
            default:
                return { F: 0, b: -1 };
        }
    }, $author$project$ParserFast$convert1OrMoreHexadecimal = F2($author$project$ParserFast$convert1OrMoreHexadecimal_fn);
    var $author$project$ParserFast$errorAsBaseOffsetAndInt = {
        C: 0,
        r: { F: 0, b: -1 }
    };
    var $author$project$ParserFast$convertIntegerDecimalOrHexadecimal_fn = function (offset, src) {
        var _v0 = _String_slice_fn(offset, offset + 1, src);
        switch (_v0) {
            case "0":
                var _v1 = _String_slice_fn(offset + 1, offset + 2, src);
                if (_v1 === "x") {
                    var hex = $author$project$ParserFast$convert1OrMoreHexadecimal_fn(offset + 2, src);
                    return {
                        C: 1,
                        r: { F: hex.F, b: hex.b }
                    };
                }
                else {
                    return {
                        C: 0,
                        r: { F: 0, b: offset + 1 }
                    };
                }
            case "1":
                return {
                    C: 0,
                    r: $author$project$ParserFast$convert0OrMore0To9s_fn(1, offset + 1, src)
                };
            case "2":
                return {
                    C: 0,
                    r: $author$project$ParserFast$convert0OrMore0To9s_fn(2, offset + 1, src)
                };
            case "3":
                return {
                    C: 0,
                    r: $author$project$ParserFast$convert0OrMore0To9s_fn(3, offset + 1, src)
                };
            case "4":
                return {
                    C: 0,
                    r: $author$project$ParserFast$convert0OrMore0To9s_fn(4, offset + 1, src)
                };
            case "5":
                return {
                    C: 0,
                    r: $author$project$ParserFast$convert0OrMore0To9s_fn(5, offset + 1, src)
                };
            case "6":
                return {
                    C: 0,
                    r: $author$project$ParserFast$convert0OrMore0To9s_fn(6, offset + 1, src)
                };
            case "7":
                return {
                    C: 0,
                    r: $author$project$ParserFast$convert0OrMore0To9s_fn(7, offset + 1, src)
                };
            case "8":
                return {
                    C: 0,
                    r: $author$project$ParserFast$convert0OrMore0To9s_fn(8, offset + 1, src)
                };
            case "9":
                return {
                    C: 0,
                    r: $author$project$ParserFast$convert0OrMore0To9s_fn(9, offset + 1, src)
                };
            default:
                return $author$project$ParserFast$errorAsBaseOffsetAndInt;
        }
    }, $author$project$ParserFast$convertIntegerDecimalOrHexadecimal = F2($author$project$ParserFast$convertIntegerDecimalOrHexadecimal_fn);
    var $author$project$ParserFast$skip0OrMoreDigits0To9_fn = function (offset, src) {
        skip0OrMoreDigits0To9: while (true) {
            var _v0 = _String_slice_fn(offset, offset + 1, src);
            switch (_v0) {
                case "0":
                    var $temp$offset = offset + 1, $temp$src = src;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue skip0OrMoreDigits0To9;
                case "1":
                    var $temp$offset = offset + 1, $temp$src = src;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue skip0OrMoreDigits0To9;
                case "2":
                    var $temp$offset = offset + 1, $temp$src = src;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue skip0OrMoreDigits0To9;
                case "3":
                    var $temp$offset = offset + 1, $temp$src = src;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue skip0OrMoreDigits0To9;
                case "4":
                    var $temp$offset = offset + 1, $temp$src = src;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue skip0OrMoreDigits0To9;
                case "5":
                    var $temp$offset = offset + 1, $temp$src = src;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue skip0OrMoreDigits0To9;
                case "6":
                    var $temp$offset = offset + 1, $temp$src = src;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue skip0OrMoreDigits0To9;
                case "7":
                    var $temp$offset = offset + 1, $temp$src = src;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue skip0OrMoreDigits0To9;
                case "8":
                    var $temp$offset = offset + 1, $temp$src = src;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue skip0OrMoreDigits0To9;
                case "9":
                    var $temp$offset = offset + 1, $temp$src = src;
                    offset = $temp$offset;
                    src = $temp$src;
                    continue skip0OrMoreDigits0To9;
                default:
                    return offset;
            }
        }
    }, $author$project$ParserFast$skip0OrMoreDigits0To9 = F2($author$project$ParserFast$skip0OrMoreDigits0To9_fn);
    var $author$project$ParserFast$skip1OrMoreDigits0To9_fn = function (offset, src) {
        var _v0 = _String_slice_fn(offset, offset + 1, src);
        switch (_v0) {
            case "0":
                return $author$project$ParserFast$skip0OrMoreDigits0To9_fn(offset + 1, src);
            case "1":
                return $author$project$ParserFast$skip0OrMoreDigits0To9_fn(offset + 1, src);
            case "2":
                return $author$project$ParserFast$skip0OrMoreDigits0To9_fn(offset + 1, src);
            case "3":
                return $author$project$ParserFast$skip0OrMoreDigits0To9_fn(offset + 1, src);
            case "4":
                return $author$project$ParserFast$skip0OrMoreDigits0To9_fn(offset + 1, src);
            case "5":
                return $author$project$ParserFast$skip0OrMoreDigits0To9_fn(offset + 1, src);
            case "6":
                return $author$project$ParserFast$skip0OrMoreDigits0To9_fn(offset + 1, src);
            case "7":
                return $author$project$ParserFast$skip0OrMoreDigits0To9_fn(offset + 1, src);
            case "8":
                return $author$project$ParserFast$skip0OrMoreDigits0To9_fn(offset + 1, src);
            case "9":
                return $author$project$ParserFast$skip0OrMoreDigits0To9_fn(offset + 1, src);
            default:
                return -1;
        }
    }, $author$project$ParserFast$skip1OrMoreDigits0To9 = F2($author$project$ParserFast$skip1OrMoreDigits0To9_fn);
    var $author$project$ParserFast$skipAfterFloatExponentMark_fn = function (offset, src) {
        var _v0 = _String_slice_fn(offset, offset + 1, src);
        switch (_v0) {
            case "+":
                return $author$project$ParserFast$skip1OrMoreDigits0To9_fn(offset + 1, src);
            case "-":
                return $author$project$ParserFast$skip1OrMoreDigits0To9_fn(offset + 1, src);
            default:
                return $author$project$ParserFast$skip1OrMoreDigits0To9_fn(offset, src);
        }
    }, $author$project$ParserFast$skipAfterFloatExponentMark = F2($author$project$ParserFast$skipAfterFloatExponentMark_fn);
    var $author$project$ParserFast$skipFloatAfterIntegerDecimal_fn = function (offset, src) {
        var _v0 = _String_slice_fn(offset, offset + 1, src);
        switch (_v0) {
            case ".":
                var offsetAfterDigits = $author$project$ParserFast$skip1OrMoreDigits0To9_fn(offset + 1, src);
                if (offsetAfterDigits === -1) {
                    return -1;
                }
                else {
                    var _v1 = _String_slice_fn(offsetAfterDigits, offsetAfterDigits + 1, src);
                    switch (_v1) {
                        case "e":
                            return $author$project$ParserFast$skipAfterFloatExponentMark_fn(offsetAfterDigits + 1, src);
                        case "E":
                            return $author$project$ParserFast$skipAfterFloatExponentMark_fn(offsetAfterDigits + 1, src);
                        default:
                            return offsetAfterDigits;
                    }
                }
            case "e":
                return $author$project$ParserFast$skipAfterFloatExponentMark_fn(offset + 1, src);
            case "E":
                return $author$project$ParserFast$skipAfterFloatExponentMark_fn(offset + 1, src);
            default:
                return -1;
        }
    }, $author$project$ParserFast$skipFloatAfterIntegerDecimal = F2($author$project$ParserFast$skipFloatAfterIntegerDecimal_fn);
    var $elm$core$String$toFloat = _String_toFloat;
    var $author$project$ParserFast$floatOrIntegerDecimalOrHexadecimalMapWithRange_fn = function (rangeAndFloatToRes, rangeAndIntDecimalToRes, rangeAndIntHexadecimalToRes) {
        return function (s0) {
            var s1 = $author$project$ParserFast$convertIntegerDecimalOrHexadecimal_fn(s0.b, s0.c);
            if (s1.r.b === -1) {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingNumber_fn(s0.bz, s0.a));
            }
            else {
                var offsetAfterFloat = $author$project$ParserFast$skipFloatAfterIntegerDecimal_fn(s1.r.b, s0.c);
                if (offsetAfterFloat === -1) {
                    var newColumn = s0.a + (s1.r.b - s0.b);
                    var range = {
                        cm: { bk: newColumn, bz: s0.bz },
                        bE: { bk: s0.a, bz: s0.bz }
                    };
                    return $author$project$ParserFast$Good_fn(function () {
                        var _v0 = s1.C;
                        if (!_v0) {
                            return A2(rangeAndIntDecimalToRes, range, s1.r.F);
                        }
                        else {
                            return A2(rangeAndIntHexadecimalToRes, range, s1.r.F);
                        }
                    }(), { a: newColumn, f: s0.f, b: s1.r.b, bz: s0.bz, c: s0.c });
                }
                else {
                    var _v1 = $elm$core$String$toFloat(_String_slice_fn(s0.b, offsetAfterFloat, s0.c));
                    if (!_v1.$) {
                        var _float = _v1.a;
                        var newColumn = s0.a + (offsetAfterFloat - s0.b);
                        return $author$project$ParserFast$Good_fn(A2(rangeAndFloatToRes, {
                            cm: { bk: newColumn, bz: s0.bz },
                            bE: { bk: s0.a, bz: s0.bz }
                        }, _float), { a: newColumn, f: s0.f, b: offsetAfterFloat, bz: s0.bz, c: s0.c });
                    }
                    else {
                        return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingNumber_fn(s0.bz, s0.a));
                    }
                }
            }
        };
    }, $author$project$ParserFast$floatOrIntegerDecimalOrHexadecimalMapWithRange = F3($author$project$ParserFast$floatOrIntegerDecimalOrHexadecimalMapWithRange_fn);
    var $author$project$Elm$Parser$Expression$numberExpression = $author$project$ParserFast$floatOrIntegerDecimalOrHexadecimalMapWithRange_fn(F2(function (range, n) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Expression$Floatable(n))
        };
    }), F2(function (range, n) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Expression$Integer(n))
        };
    }), F2(function (range, n) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Expression$Hex(n))
        };
    }));
    var $elm$core$Tuple$pair_fn = function (a, b) {
        return _Utils_Tuple2(a, b);
    }, $elm$core$Tuple$pair = F2($elm$core$Tuple$pair_fn);
    var $author$project$Elm$Parser$Tokens$equal = $author$project$ParserFast$symbol_fn("=", 0);
    var $author$project$Elm$Syntax$Pattern$AsPattern_fn = function (a, b) {
        return { $: 13, a: a, b: b };
    }, $author$project$Elm$Syntax$Pattern$AsPattern = F2($author$project$Elm$Syntax$Pattern$AsPattern_fn);
    var $author$project$Elm$Syntax$Pattern$ListPattern = function (a) {
        return { $: 10, a: a };
    };
    var $author$project$Elm$Syntax$Pattern$NamedPattern_fn = function (a, b) {
        return { $: 12, a: a, b: b };
    }, $author$project$Elm$Syntax$Pattern$NamedPattern = F2($author$project$Elm$Syntax$Pattern$NamedPattern_fn);
    var $author$project$Elm$Syntax$Pattern$ParenthesizedPattern = function (a) {
        return { $: 14, a: a };
    };
    var $author$project$Elm$Syntax$Pattern$TuplePattern = function (a) {
        return { $: 7, a: a };
    };
    var $author$project$Elm$Syntax$Pattern$UnConsPattern_fn = function (a, b) {
        return { $: 9, a: a, b: b };
    }, $author$project$Elm$Syntax$Pattern$UnConsPattern = F2($author$project$Elm$Syntax$Pattern$UnConsPattern_fn);
    var $author$project$Elm$Syntax$Pattern$UnitPattern = { $: 1 };
    var $author$project$Elm$Syntax$Pattern$AllPattern = { $: 0 };
    var $author$project$ParserFast$symbolWithRange_fn = function (str, startAndEndLocationToRes) {
        var strLength = $elm$core$String$length(str);
        return function (s) {
            var newOffset = s.b + strLength;
            if (_Utils_eq(_String_slice_fn(s.b, newOffset, s.c), str + "")) {
                var newCol = s.a + strLength;
                return $author$project$ParserFast$Good_fn(startAndEndLocationToRes({
                    cm: { bk: newCol, bz: s.bz },
                    bE: { bk: s.a, bz: s.bz }
                }), { a: newCol, f: s.f, b: newOffset, bz: s.bz, c: s.c });
            }
            else {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingSymbol_fn(s.bz, s.a, str));
            }
        };
    }, $author$project$ParserFast$symbolWithRange = F2($author$project$ParserFast$symbolWithRange_fn);
    var $author$project$Elm$Parser$Patterns$allPattern = $author$project$ParserFast$symbolWithRange_fn("_", function (range) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Pattern$AllPattern)
        };
    });
    var $author$project$Elm$Syntax$Pattern$CharPattern = function (a) {
        return { $: 2, a: a };
    };
    var $author$project$Elm$Parser$Patterns$charPattern = $author$project$Elm$Parser$Tokens$characterLiteralMapWithRange_unwrapped(function (range, _char) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Pattern$CharPattern(_char))
        };
    });
    var $author$project$ParserFast$loopWhileSucceedsRightToLeftStackUnsafeHelp_fn = function (element, reduce, s0) {
        var parseElement = element;
        var _v0 = parseElement(s0);
        if (!_v0.$) {
            var elementResult = _v0.a;
            var s1 = _v0.b;
            var _v1 = $author$project$ParserFast$loopWhileSucceedsRightToLeftStackUnsafeHelp_fn(element, reduce, s1);
            if (!_v1.$) {
                var tailFolded = _v1.a;
                var s2 = _v1.b;
                return $author$project$ParserFast$Good_fn(A2(reduce, elementResult, tailFolded), s2);
            }
            else {
                var tailBad = _v1;
                var tailCommitted = tailBad.a;
                return tailCommitted ? tailBad : $author$project$ParserFast$Good_fn(elementResult, s1);
            }
        }
        else {
            var elementCommitted = _v0.a;
            var x = _v0.b;
            return $author$project$ParserFast$Bad_fn(elementCommitted, x);
        }
    }, $author$project$ParserFast$loopWhileSucceedsRightToLeftStackUnsafeHelp_fn_unwrapped = function (element, reduce, s0) {
        var parseElement = element;
        var _v0 = parseElement(s0);
        if (!_v0.$) {
            var elementResult = _v0.a;
            var s1 = _v0.b;
            var _v1 = $author$project$ParserFast$loopWhileSucceedsRightToLeftStackUnsafeHelp_fn_unwrapped(element, reduce, s1);
            if (!_v1.$) {
                var tailFolded = _v1.a;
                var s2 = _v1.b;
                return $author$project$ParserFast$Good_fn(reduce(elementResult, tailFolded), s2);
            }
            else {
                var tailBad = _v1;
                var tailCommitted = tailBad.a;
                return tailCommitted ? tailBad : $author$project$ParserFast$Good_fn(elementResult, s1);
            }
        }
        else {
            var elementCommitted = _v0.a;
            var x = _v0.b;
            return $author$project$ParserFast$Bad_fn(elementCommitted, x);
        }
    }, $author$project$ParserFast$loopWhileSucceedsRightToLeftStackUnsafeHelp = F3($author$project$ParserFast$loopWhileSucceedsRightToLeftStackUnsafeHelp_fn);
    var $author$project$ParserFast$loopWhileSucceedsOntoResultFromParserRightToLeftStackUnsafe_fn = function (_v0, taiElement, reduce) {
        var parseLeftestElement = _v0;
        return function (s0) {
            var _v1 = parseLeftestElement(s0);
            if (!_v1.$) {
                var elementResult = _v1.a;
                var s1 = _v1.b;
                var _v2 = $author$project$ParserFast$loopWhileSucceedsRightToLeftStackUnsafeHelp_fn(taiElement, reduce, s1);
                if (!_v2.$) {
                    var tailFolded = _v2.a;
                    var s2 = _v2.b;
                    return $author$project$ParserFast$Good_fn(A2(reduce, elementResult, tailFolded), s2);
                }
                else {
                    var tailBad = _v2;
                    var tailCommitted = tailBad.a;
                    return tailCommitted ? tailBad : $author$project$ParserFast$Good_fn(elementResult, s1);
                }
            }
            else {
                var elementCommitted = _v1.a;
                var x = _v1.b;
                return $author$project$ParserFast$Bad_fn(elementCommitted, x);
            }
        };
    }, $author$project$ParserFast$loopWhileSucceedsOntoResultFromParserRightToLeftStackUnsafe_fn_unwrapped = function (_v0, taiElement, reduce) {
        var parseLeftestElement = _v0;
        return function (s0) {
            var _v1 = parseLeftestElement(s0);
            if (!_v1.$) {
                var elementResult = _v1.a;
                var s1 = _v1.b;
                var _v2 = $author$project$ParserFast$loopWhileSucceedsRightToLeftStackUnsafeHelp_fn_unwrapped(taiElement, reduce, s1);
                if (!_v2.$) {
                    var tailFolded = _v2.a;
                    var s2 = _v2.b;
                    return $author$project$ParserFast$Good_fn(reduce(elementResult, tailFolded), s2);
                }
                else {
                    var tailBad = _v2;
                    var tailCommitted = tailBad.a;
                    return tailCommitted ? tailBad : $author$project$ParserFast$Good_fn(elementResult, s1);
                }
            }
            else {
                var elementCommitted = _v1.a;
                var x = _v1.b;
                return $author$project$ParserFast$Bad_fn(elementCommitted, x);
            }
        };
    }, $author$project$ParserFast$loopWhileSucceedsOntoResultFromParserRightToLeftStackUnsafe = F3($author$project$ParserFast$loopWhileSucceedsOntoResultFromParserRightToLeftStackUnsafe_fn);
    var $author$project$Elm$Syntax$Pattern$HexPattern = function (a) {
        return { $: 5, a: a };
    };
    var $author$project$Elm$Syntax$Pattern$IntPattern = function (a) {
        return { $: 4, a: a };
    };
    var $author$project$ParserFast$integerDecimalOrHexadecimalMapWithRange_fn = function (rangeAndIntDecimalToRes, rangeAndIntHexadecimalToRes) {
        return function (s0) {
            var s1 = $author$project$ParserFast$convertIntegerDecimalOrHexadecimal_fn(s0.b, s0.c);
            if (s1.r.b === -1) {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingNumber_fn(s0.bz, s0.a));
            }
            else {
                var newColumn = s0.a + (s1.r.b - s0.b);
                var range = {
                    cm: { bk: newColumn, bz: s0.bz },
                    bE: { bk: s0.a, bz: s0.bz }
                };
                return $author$project$ParserFast$Good_fn(function () {
                    var _v0 = s1.C;
                    if (!_v0) {
                        return A2(rangeAndIntDecimalToRes, range, s1.r.F);
                    }
                    else {
                        return A2(rangeAndIntHexadecimalToRes, range, s1.r.F);
                    }
                }(), { a: newColumn, f: s0.f, b: s1.r.b, bz: s0.bz, c: s0.c });
            }
        };
    }, $author$project$ParserFast$integerDecimalOrHexadecimalMapWithRange = F2($author$project$ParserFast$integerDecimalOrHexadecimalMapWithRange_fn);
    var $author$project$Elm$Parser$Patterns$numberPart = $author$project$ParserFast$integerDecimalOrHexadecimalMapWithRange_fn(F2(function (range, n) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Pattern$IntPattern(n))
        };
    }), F2(function (range, n) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Pattern$HexPattern(n))
        };
    }));
    var $author$project$ParserFast$oneOf9_fn = function (_v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7, _v8) {
        var attempt0 = _v0;
        var attempt1 = _v1;
        var attempt2 = _v2;
        var attempt3 = _v3;
        var attempt4 = _v4;
        var attempt5 = _v5;
        var attempt6 = _v6;
        var attempt7 = _v7;
        var attempt8 = _v8;
        return function (s) {
            var _v9 = attempt0(s);
            if (!_v9.$) {
                var good = _v9;
                return good;
            }
            else {
                var bad0 = _v9;
                var committed0 = bad0.a;
                var x0 = bad0.b;
                if (committed0) {
                    return bad0;
                }
                else {
                    var _v10 = attempt1(s);
                    if (!_v10.$) {
                        var good = _v10;
                        return good;
                    }
                    else {
                        var bad1 = _v10;
                        var committed1 = bad1.a;
                        var x1 = bad1.b;
                        if (committed1) {
                            return bad1;
                        }
                        else {
                            var _v11 = attempt2(s);
                            if (!_v11.$) {
                                var good = _v11;
                                return good;
                            }
                            else {
                                var bad2 = _v11;
                                var committed2 = bad2.a;
                                var x2 = bad2.b;
                                if (committed2) {
                                    return bad2;
                                }
                                else {
                                    var _v12 = attempt3(s);
                                    if (!_v12.$) {
                                        var good = _v12;
                                        return good;
                                    }
                                    else {
                                        var bad3 = _v12;
                                        var committed3 = bad3.a;
                                        var x3 = bad3.b;
                                        if (committed3) {
                                            return bad3;
                                        }
                                        else {
                                            var _v13 = attempt4(s);
                                            if (!_v13.$) {
                                                var good = _v13;
                                                return good;
                                            }
                                            else {
                                                var bad4 = _v13;
                                                var committed4 = bad4.a;
                                                var x4 = bad4.b;
                                                if (committed4) {
                                                    return bad4;
                                                }
                                                else {
                                                    var _v14 = attempt5(s);
                                                    if (!_v14.$) {
                                                        var good = _v14;
                                                        return good;
                                                    }
                                                    else {
                                                        var bad5 = _v14;
                                                        var committed5 = bad5.a;
                                                        var x5 = bad5.b;
                                                        if (committed5) {
                                                            return bad5;
                                                        }
                                                        else {
                                                            var _v15 = attempt6(s);
                                                            if (!_v15.$) {
                                                                var good = _v15;
                                                                return good;
                                                            }
                                                            else {
                                                                var bad6 = _v15;
                                                                var committed6 = bad6.a;
                                                                var x6 = bad6.b;
                                                                if (committed6) {
                                                                    return bad6;
                                                                }
                                                                else {
                                                                    var _v16 = attempt7(s);
                                                                    if (!_v16.$) {
                                                                        var good = _v16;
                                                                        return good;
                                                                    }
                                                                    else {
                                                                        var bad7 = _v16;
                                                                        var committed7 = bad7.a;
                                                                        var x7 = bad7.b;
                                                                        if (committed7) {
                                                                            return bad7;
                                                                        }
                                                                        else {
                                                                            var _v17 = attempt8(s);
                                                                            if (!_v17.$) {
                                                                                var good = _v17;
                                                                                return good;
                                                                            }
                                                                            else {
                                                                                var bad8 = _v17;
                                                                                var committed8 = bad8.a;
                                                                                var x8 = bad8.b;
                                                                                return committed8 ? bad8 : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingOneOf_fn(x0, x1, _List_fromArray([x2, x3, x4, x5, x6, x7, x8])));
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$oneOf9 = F9($author$project$ParserFast$oneOf9_fn);
    var $author$project$ParserFast$orSucceed_fn = function (_v0, secondRes) {
        var attemptFirst = _v0;
        return function (s) {
            var _v1 = attemptFirst(s);
            if (!_v1.$) {
                var firstGood = _v1;
                return firstGood;
            }
            else {
                var firstBad = _v1;
                var firstCommitted = firstBad.a;
                return firstCommitted ? firstBad : $author$project$ParserFast$Good_fn(secondRes, s);
            }
        };
    }, $author$project$ParserFast$orSucceed = F2($author$project$ParserFast$orSucceed_fn);
    var $author$project$Elm$Parser$Patterns$patternListEmpty = $author$project$Elm$Syntax$Pattern$ListPattern(_List_Nil);
    var $author$project$Elm$Parser$Layout$problemPositivelyIndented = $author$project$ParserFast$problem("must be positively indented");
    var $author$project$Elm$Parser$Layout$positivelyIndentedFollowedBy = function (nextParser) {
        return $author$project$ParserFast$columnIndentAndThen_unwrapped(function (column, indent) {
            return (_Utils_cmp(column, indent) > 0) ? nextParser : $author$project$Elm$Parser$Layout$problemPositivelyIndented;
        });
    };
    var $author$project$ParserFast$ifFollowedByWhileWithoutLinebreak_fn = function (firstIsOkay, afterFirstIsOkay) {
        return function (s) {
            var firstOffset = $author$project$ParserFast$isSubCharWithoutLinebreak_fn(firstIsOkay, s.b, s.c);
            if (firstOffset === -1) {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingCharSatisfyingPredicate_fn(s.bz, s.a));
            }
            else {
                var s1 = $author$project$ParserFast$skipWhileWithoutLinebreakHelp_fn(afterFirstIsOkay, firstOffset, s.bz, s.a + 1, s.c, s.f);
                return $author$project$ParserFast$Good_fn(_String_slice_fn(s.b, s1.b, s.c), s1);
            }
        };
    }, $author$project$ParserFast$ifFollowedByWhileWithoutLinebreak = F2($author$project$ParserFast$ifFollowedByWhileWithoutLinebreak_fn);
    var $author$project$Char$Extra$unicodeIsUpperFast = function (c) {
        var code = $elm$core$Char$toCode(c);
        return $author$project$Char$Extra$charCodeIsUpper(code) || function () {
            var cString = $elm$core$String$fromChar(c);
            return (_Utils_eq($elm$core$String$toUpper(cString), cString + "") && (!_Utils_eq($elm$core$String$toLower(cString), cString + ""))) ? ((code <= 8543) || (((8560 <= code) && (code <= 9397)) || ((9424 <= code) && (code <= 983040)))) : ((code < 120015) ? ((code < 8509) ? (((978 <= code) && (code <= 980)) || ((code === 8450) || ((code === 8455) || (((8459 <= code) && (code <= 8461)) || (((8464 <= code) && (code <= 8466)) || ((code === 8469) || (((8473 <= code) && (code <= 8477)) || ((code === 8484) || ((code === 8488) || (((8490 <= code) && (code <= 8493)) || ((8496 <= code) && (code <= 8499)))))))))))) : (((8510 <= code) && (code <= 8511)) || ((code === 8517) || (((119808 <= code) && (code <= 119833)) || (((119860 <= code) && (code <= 119885)) || (((119912 <= code) && (code <= 119937)) || ((code === 119964) || (((119966 <= code) && (code <= 119967)) || ((code === 119970) || (((119973 <= code) && (code <= 119974)) || (((119977 <= code) && (code <= 119980)) || ((119982 <= code) && (code <= 119989))))))))))))) : ((code < 120223) ? (((120016 <= code) && (code <= 120041)) || (((120068 <= code) && (code <= 120069)) || (((120071 <= code) && (code <= 120074)) || (((120077 <= code) && (code <= 120084)) || (((120086 <= code) && (code <= 120092)) || (((120120 <= code) && (code <= 120121)) || (((120123 <= code) && (code <= 120126)) || (((120128 <= code) && (code <= 120132)) || ((code === 120134) || (((120138 <= code) && (code <= 120144)) || ((120172 <= code) && (code <= 120197)))))))))))) : (((120224 <= code) && (code <= 120249)) || (((120276 <= code) && (code <= 120301)) || (((120328 <= code) && (code <= 120353)) || (((120380 <= code) && (code <= 120405)) || (((120432 <= code) && (code <= 120457)) || (((120488 <= code) && (code <= 120512)) || (((120546 <= code) && (code <= 120570)) || (((120604 <= code) && (code <= 120628)) || (((120662 <= code) && (code <= 120686)) || (((120720 <= code) && (code <= 120744)) || (code === 120778)))))))))))));
        }();
    };
    var $author$project$Elm$Parser$Tokens$typeName = $author$project$ParserFast$ifFollowedByWhileWithoutLinebreak_fn($author$project$Char$Extra$unicodeIsUpperFast, $author$project$Char$Extra$unicodeIsAlphaNumOrUnderscoreFast);
    function $author$project$Elm$Parser$Patterns$cyclic$maybeDotTypeNamesTuple() {
        return $author$project$ParserFast$map2OrSucceed_fn_unwrapped(function (startName, afterStartName) {
            if (afterStartName.$ === 1) {
                return $elm$core$Maybe$Just(_Utils_Tuple2(_List_Nil, startName));
            }
            else {
                var _v1 = afterStartName.a;
                var qualificationAfter = _v1.a;
                var unqualified = _v1.b;
                return $elm$core$Maybe$Just(_Utils_Tuple2(_List_Cons(startName, qualificationAfter), unqualified));
            }
        }, $author$project$ParserFast$symbolFollowedBy_fn(".", $author$project$Elm$Parser$Tokens$typeName), $author$project$ParserFast$lazy(function (_v2) {
            return $author$project$Elm$Parser$Patterns$cyclic$maybeDotTypeNamesTuple();
        }), $elm$core$Maybe$Nothing);
    }
    var $author$project$Elm$Parser$Patterns$maybeDotTypeNamesTuple = $author$project$Elm$Parser$Patterns$cyclic$maybeDotTypeNamesTuple();
    $author$project$Elm$Parser$Patterns$cyclic$maybeDotTypeNamesTuple = function () {
        return $author$project$Elm$Parser$Patterns$maybeDotTypeNamesTuple;
    };
    var $author$project$Elm$Parser$Patterns$qualifiedNameRefNode = $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, firstName, after) {
        return $author$project$Elm$Syntax$Node$Node_fn(range, function () {
            if (after.$ === 1) {
                return { eI: _List_Nil, q: firstName };
            }
            else {
                var _v1 = after.a;
                var qualificationAfter = _v1.a;
                var unqualified = _v1.b;
                return {
                    eI: _List_Cons(firstName, qualificationAfter),
                    q: unqualified
                };
            }
        }());
    }, $author$project$Elm$Parser$Tokens$typeName, $author$project$Elm$Parser$Patterns$maybeDotTypeNamesTuple);
    var $author$project$Elm$Parser$Patterns$qualifiedPatternWithoutConsumeArgs = $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, firstName, after) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Pattern$NamedPattern_fn(function () {
                if (after.$ === 1) {
                    return { eI: _List_Nil, q: firstName };
                }
                else {
                    var _v1 = after.a;
                    var qualificationAfter = _v1.a;
                    var unqualified = _v1.b;
                    return {
                        eI: _List_Cons(firstName, qualificationAfter),
                        q: unqualified
                    };
                }
            }(), _List_Nil))
        };
    }, $author$project$Elm$Parser$Tokens$typeName, $author$project$Elm$Parser$Patterns$maybeDotTypeNamesTuple);
    var $author$project$Elm$Syntax$Pattern$RecordPattern = function (a) {
        return { $: 8, a: a };
    };
    var $author$project$Elm$Parser$Patterns$recordPattern = $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, commentsBeforeElements, elements) {
        return {
            e: $author$project$Rope$prependTo_fn(elements.e, commentsBeforeElements),
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Pattern$RecordPattern(elements.d))
        };
    }, $author$project$ParserFast$symbolFollowedBy_fn("{", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$followedBySymbol_fn("}", $author$project$ParserFast$map3_fn_unwrapped(function (head, commentsAfterHead, tail) {
        return {
            e: $author$project$Rope$prependTo_fn(tail.e, commentsAfterHead),
            d: _List_Cons(head, tail.d)
        };
    }, $author$project$Elm$Parser$Tokens$functionNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserWithComments$many($author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$ParserFast$map3_fn_unwrapped(function (beforeName, name, afterName) {
        return {
            e: $author$project$Rope$prependTo_fn(afterName, beforeName),
            d: name
        };
    }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Tokens$functionNameNode, $author$project$Elm$Parser$Layout$maybeLayout))))), $author$project$ParserFast$symbol_fn("}", { e: $author$project$Rope$empty, d: _List_Nil })));
    var $author$project$Elm$Syntax$Pattern$StringPattern = function (a) {
        return { $: 3, a: a };
    };
    var $author$project$Elm$Parser$Patterns$stringPattern = $author$project$Elm$Parser$Tokens$singleOrTripleQuotedStringLiteralMapWithRange_unwrapped(function (range, string) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Pattern$StringPattern(string))
        };
    });
    var $author$project$Elm$Syntax$Pattern$VarPattern = function (a) {
        return { $: 11, a: a };
    };
    var $author$project$Elm$Parser$Tokens$functionNameMapWithRange = function (rangeAndNameToResult) {
        return $author$project$ParserFast$ifFollowedByWhileValidateMapWithRangeWithoutLinebreak_fn(rangeAndNameToResult, $author$project$Char$Extra$unicodeIsLowerFast, $author$project$Char$Extra$unicodeIsAlphaNumOrUnderscoreFast, $author$project$Elm$Parser$Tokens$isNotReserved);
    };
    var $author$project$Elm$Parser$Patterns$varPattern = $author$project$Elm$Parser$Tokens$functionNameMapWithRange(F2(function (range, _var) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Pattern$VarPattern(_var))
        };
    }));
    function $author$project$Elm$Parser$Patterns$cyclic$composablePattern() {
        return $author$project$ParserFast$oneOf9_fn($author$project$Elm$Parser$Patterns$varPattern, $author$project$Elm$Parser$Patterns$cyclic$qualifiedPatternWithConsumeArgs(), $author$project$Elm$Parser$Patterns$allPattern, $author$project$Elm$Parser$Patterns$cyclic$parensPattern(), $author$project$Elm$Parser$Patterns$recordPattern, $author$project$Elm$Parser$Patterns$stringPattern, $author$project$Elm$Parser$Patterns$cyclic$listPattern(), $author$project$Elm$Parser$Patterns$numberPart, $author$project$Elm$Parser$Patterns$charPattern);
    }
    function $author$project$Elm$Parser$Patterns$cyclic$qualifiedPatternWithConsumeArgs() {
        return $author$project$ParserFast$map3_fn_unwrapped(function (_v6, afterStartName, argsReverse) {
            var nameRange = _v6.a;
            var name = _v6.b;
            var range = function () {
                var _v7 = argsReverse.d;
                if (!_v7.b) {
                    return nameRange;
                }
                else {
                    var _v8 = _v7.a;
                    var lastArgRange = _v8.a;
                    return { cm: lastArgRange.cm, bE: nameRange.bE };
                }
            }();
            return {
                e: $author$project$Rope$prependTo_fn(argsReverse.e, afterStartName),
                d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Pattern$NamedPattern_fn(name, $elm$core$List$reverse(argsReverse.d)))
            };
        }, $author$project$Elm$Parser$Patterns$qualifiedNameRefNode, $author$project$Elm$Parser$Layout$optimisticLayout, $author$project$ParserWithComments$manyWithoutReverse($author$project$Elm$Parser$Layout$positivelyIndentedFollowedBy($author$project$ParserFast$map2_fn_unwrapped(function (arg, commentsAfterArg) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfterArg, arg.e),
                d: arg.d
            };
        }, $author$project$Elm$Parser$Patterns$cyclic$patternNotDirectlyComposing(), $author$project$Elm$Parser$Layout$optimisticLayout))));
    }
    function $author$project$Elm$Parser$Patterns$cyclic$patternNotDirectlyComposing() {
        return $author$project$ParserFast$oneOf9_fn($author$project$Elm$Parser$Patterns$varPattern, $author$project$Elm$Parser$Patterns$qualifiedPatternWithoutConsumeArgs, $author$project$Elm$Parser$Patterns$allPattern, $author$project$Elm$Parser$Patterns$cyclic$parensPattern(), $author$project$Elm$Parser$Patterns$recordPattern, $author$project$Elm$Parser$Patterns$stringPattern, $author$project$Elm$Parser$Patterns$cyclic$listPattern(), $author$project$Elm$Parser$Patterns$numberPart, $author$project$Elm$Parser$Patterns$charPattern);
    }
    function $author$project$Elm$Parser$Patterns$cyclic$listPattern() {
        return $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, commentsBeforeElements, maybeElements) {
            if (maybeElements.$ === 1) {
                return {
                    e: commentsBeforeElements,
                    d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Parser$Patterns$patternListEmpty)
                };
            }
            else {
                var elements = maybeElements.a;
                return {
                    e: $author$project$Rope$prependTo_fn(elements.e, commentsBeforeElements),
                    d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Pattern$ListPattern(elements.d))
                };
            }
        }, $author$project$ParserFast$symbolFollowedBy_fn("[", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbol_fn("]", $elm$core$Maybe$Nothing), $author$project$ParserFast$followedBySymbol_fn("]", $author$project$ParserFast$map3_fn_unwrapped(function (head, commentsAfterHead, tail) {
            return $elm$core$Maybe$Just({
                e: $author$project$Rope$prependTo_fn(commentsAfterHead, $author$project$Rope$prependTo_fn(tail.e, head.e)),
                d: _List_Cons(head.d, tail.d)
            });
        }, $author$project$Elm$Parser$Patterns$cyclic$pattern(), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserWithComments$many($author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$Elm$Parser$Layout$maybeAroundBothSides($author$project$Elm$Parser$Patterns$cyclic$pattern())))))));
    }
    function $author$project$Elm$Parser$Patterns$cyclic$parensPattern() {
        return $author$project$ParserFast$symbolFollowedBy_fn("(", $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, commentsBeforeHead, contentResult) {
            return {
                e: $author$project$Rope$prependTo_fn(contentResult.e, commentsBeforeHead),
                d: $author$project$Elm$Syntax$Node$Node_fn({
                    cm: range.cm,
                    bE: { bk: range.bE.bk - 1, bz: range.bE.bz }
                }, contentResult.d)
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbol_fn(")", { e: $author$project$Rope$empty, d: $author$project$Elm$Syntax$Pattern$UnitPattern }), $author$project$ParserFast$map3_fn_unwrapped(function (headResult, commentsAfterHead, tailResult) {
            return {
                e: $author$project$Rope$prependTo_fn(tailResult.e, $author$project$Rope$prependTo_fn(commentsAfterHead, headResult.e)),
                d: function () {
                    var _v3 = tailResult.d;
                    if (_v3.$ === 1) {
                        return $author$project$Elm$Syntax$Pattern$ParenthesizedPattern(headResult.d);
                    }
                    else {
                        var secondAndMaybeThirdPart = _v3.a;
                        var _v4 = secondAndMaybeThirdPart.cI;
                        if (_v4.$ === 1) {
                            return $author$project$Elm$Syntax$Pattern$TuplePattern(_List_fromArray([headResult.d, secondAndMaybeThirdPart.b2]));
                        }
                        else {
                            var thirdPart = _v4.a;
                            return $author$project$Elm$Syntax$Pattern$TuplePattern(_List_fromArray([headResult.d, secondAndMaybeThirdPart.b2, thirdPart]));
                        }
                    }
                }()
            };
        }, $author$project$Elm$Parser$Patterns$cyclic$pattern(), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbol_fn(")", { e: $author$project$Rope$empty, d: $elm$core$Maybe$Nothing }), $author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$ParserFast$map4_fn_unwrapped(function (commentsBefore, secondPart, commentsAfter, maybeThirdPart) {
            return {
                e: $author$project$Rope$prependTo_fn(maybeThirdPart.e, $author$project$Rope$prependTo_fn(commentsAfter, $author$project$Rope$prependTo_fn(secondPart.e, commentsBefore))),
                d: $elm$core$Maybe$Just({ cI: maybeThirdPart.d, b2: secondPart.d })
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Patterns$cyclic$pattern(), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbol_fn(")", { e: $author$project$Rope$empty, d: $elm$core$Maybe$Nothing }), $author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$ParserFast$followedBySymbol_fn(")", $author$project$ParserFast$map3_fn_unwrapped(function (commentsBefore, thirdPart, commentsAfter) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfter, $author$project$Rope$prependTo_fn(thirdPart.e, commentsBefore)),
                d: $elm$core$Maybe$Just(thirdPart.d)
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Patterns$cyclic$pattern(), $author$project$Elm$Parser$Layout$maybeLayout)))))))))));
    }
    function $author$project$Elm$Parser$Patterns$cyclic$pattern() {
        return $author$project$ParserFast$map2_fn_unwrapped(function (leftMaybeConsed, maybeAsExtension) {
            return {
                e: $author$project$Rope$prependTo_fn(maybeAsExtension.e, leftMaybeConsed.e),
                d: function () {
                    var _v0 = maybeAsExtension.d;
                    if (_v0.$ === 1) {
                        return leftMaybeConsed.d;
                    }
                    else {
                        var anotherName = _v0.a;
                        return $author$project$Elm$Syntax$Node$combine_fn($author$project$Elm$Syntax$Pattern$AsPattern, leftMaybeConsed.d, anotherName);
                    }
                }()
            };
        }, $author$project$ParserFast$loopWhileSucceedsOntoResultFromParserRightToLeftStackUnsafe_fn_unwrapped($author$project$ParserFast$map2_fn_unwrapped(function (startPatternResult, commentsAfter) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfter, startPatternResult.e),
                d: startPatternResult.d
            };
        }, $author$project$ParserFast$lazy(function (_v1) {
            return $author$project$Elm$Parser$Patterns$cyclic$composablePattern();
        }), $author$project$Elm$Parser$Layout$maybeLayout), $author$project$ParserFast$symbolFollowedBy_fn("::", $author$project$ParserFast$map3_fn_unwrapped(function (commentsAfterCons, patternResult, commentsAfterTailSubPattern) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfterTailSubPattern, $author$project$Rope$prependTo_fn(patternResult.e, commentsAfterCons)),
                d: patternResult.d
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$lazy(function (_v2) {
            return $author$project$Elm$Parser$Patterns$cyclic$composablePattern();
        }), $author$project$Elm$Parser$Layout$maybeLayout)), function (consed, afterCons) {
            return {
                e: $author$project$Rope$prependTo_fn(afterCons.e, consed.e),
                d: $author$project$Elm$Syntax$Node$combine_fn($author$project$Elm$Syntax$Pattern$UnConsPattern, consed.d, afterCons.d)
            };
        }), $author$project$ParserFast$orSucceed_fn($author$project$ParserFast$keywordFollowedBy_fn("as", $author$project$ParserFast$map2_fn_unwrapped(function (commentsAfterAs, name) {
            return {
                e: commentsAfterAs,
                d: $elm$core$Maybe$Just(name)
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Tokens$functionNameNode)), { e: $author$project$Rope$empty, d: $elm$core$Maybe$Nothing }));
    }
    var $author$project$Elm$Parser$Patterns$composablePattern = $author$project$Elm$Parser$Patterns$cyclic$composablePattern();
    $author$project$Elm$Parser$Patterns$cyclic$composablePattern = function () {
        return $author$project$Elm$Parser$Patterns$composablePattern;
    };
    var $author$project$Elm$Parser$Patterns$qualifiedPatternWithConsumeArgs = $author$project$Elm$Parser$Patterns$cyclic$qualifiedPatternWithConsumeArgs();
    $author$project$Elm$Parser$Patterns$cyclic$qualifiedPatternWithConsumeArgs = function () {
        return $author$project$Elm$Parser$Patterns$qualifiedPatternWithConsumeArgs;
    };
    var $author$project$Elm$Parser$Patterns$patternNotDirectlyComposing = $author$project$Elm$Parser$Patterns$cyclic$patternNotDirectlyComposing();
    $author$project$Elm$Parser$Patterns$cyclic$patternNotDirectlyComposing = function () {
        return $author$project$Elm$Parser$Patterns$patternNotDirectlyComposing;
    };
    var $author$project$Elm$Parser$Patterns$listPattern = $author$project$Elm$Parser$Patterns$cyclic$listPattern();
    $author$project$Elm$Parser$Patterns$cyclic$listPattern = function () {
        return $author$project$Elm$Parser$Patterns$listPattern;
    };
    var $author$project$Elm$Parser$Patterns$parensPattern = $author$project$Elm$Parser$Patterns$cyclic$parensPattern();
    $author$project$Elm$Parser$Patterns$cyclic$parensPattern = function () {
        return $author$project$Elm$Parser$Patterns$parensPattern;
    };
    var $author$project$Elm$Parser$Patterns$pattern = $author$project$Elm$Parser$Patterns$cyclic$pattern();
    $author$project$Elm$Parser$Patterns$cyclic$pattern = function () {
        return $author$project$Elm$Parser$Patterns$pattern;
    };
    var $author$project$ParserWithComments$until_fn = function (end, element) {
        return $author$project$ParserFast$loopUntil_fn(end, element, _Utils_Tuple2($author$project$Rope$empty, _List_Nil), F2(function (pResult, _v0) {
            var commentsSoFar = _v0.a;
            var itemsSoFar = _v0.b;
            return _Utils_Tuple2($author$project$Rope$prependTo_fn(pResult.e, commentsSoFar), _List_Cons(pResult.d, itemsSoFar));
        }), function (_v1) {
            var commentsSoFar = _v1.a;
            var itemsSoFar = _v1.b;
            return {
                e: commentsSoFar,
                d: $elm$core$List$reverse(itemsSoFar)
            };
        });
    }, $author$project$ParserWithComments$until = F2($author$project$ParserWithComments$until_fn);
    var $author$project$Elm$Parser$Expression$parameterPatternsEqual = $author$project$ParserWithComments$until_fn($author$project$Elm$Parser$Tokens$equal, $author$project$ParserFast$map2_fn_unwrapped(function (patternResult, commentsAfterPattern) {
        return {
            e: $author$project$Rope$prependTo_fn(commentsAfterPattern, patternResult.e),
            d: patternResult.d
        };
    }, $author$project$Elm$Parser$Patterns$patternNotDirectlyComposing, $author$project$Elm$Parser$Layout$maybeLayout));
    var $author$project$Elm$Parser$Layout$positivelyIndentedPlusFollowedBy_fn = function (extraIndent, nextParser) {
        return $author$project$ParserFast$columnIndentAndThen_unwrapped(function (column, indent) {
            return (_Utils_cmp(column, indent + extraIndent) > 0) ? nextParser : $author$project$Elm$Parser$Layout$problemPositivelyIndented;
        });
    }, $author$project$Elm$Parser$Layout$positivelyIndentedPlusFollowedBy = F2($author$project$Elm$Parser$Layout$positivelyIndentedPlusFollowedBy_fn);
    var $author$project$Elm$Parser$Expression$problemCannotMixNonAssociativeInfixOperators = $author$project$ParserFast$problem("cannot mix non-associative infix operators without parenthesis");
    var $author$project$Elm$Syntax$Expression$FunctionOrValue_fn = function (a, b) {
        return { $: 3, a: a, b: b };
    }, $author$project$Elm$Syntax$Expression$FunctionOrValue = F2($author$project$Elm$Syntax$Expression$FunctionOrValue_fn);
    var $author$project$ParserFast$ifFollowedByWhileValidateWithoutLinebreak_fn = function (firstIsOkay, afterFirstIsOkay, resultIsOkay) {
        return function (s) {
            var firstOffset = $author$project$ParserFast$isSubCharWithoutLinebreak_fn(firstIsOkay, s.b, s.c);
            if (firstOffset === -1) {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingCharSatisfyingPredicate_fn(s.bz, s.a));
            }
            else {
                var s1 = $author$project$ParserFast$skipWhileWithoutLinebreakHelp_fn(afterFirstIsOkay, firstOffset, s.bz, s.a + 1, s.c, s.f);
                var name = _String_slice_fn(s.b, s1.b, s.c);
                return resultIsOkay(name) ? $author$project$ParserFast$Good_fn(name, s1) : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingStringSatisfyingPredicate_fn(s.bz, s.a + 1));
            }
        };
    }, $author$project$ParserFast$ifFollowedByWhileValidateWithoutLinebreak = F3($author$project$ParserFast$ifFollowedByWhileValidateWithoutLinebreak_fn);
    var $author$project$Elm$Parser$Tokens$functionName = $author$project$ParserFast$ifFollowedByWhileValidateWithoutLinebreak_fn($author$project$Char$Extra$unicodeIsLowerFast, $author$project$Char$Extra$unicodeIsAlphaNumOrUnderscoreFast, $author$project$Elm$Parser$Tokens$isNotReserved);
    var $author$project$ParserFast$oneOf2Map_fn = function (firstToChoice, _v0, secondToChoice, _v1) {
        var attemptFirst = _v0;
        var attemptSecond = _v1;
        return function (s) {
            var _v2 = attemptFirst(s);
            if (!_v2.$) {
                var first = _v2.a;
                var s1 = _v2.b;
                return $author$project$ParserFast$Good_fn(firstToChoice(first), s1);
            }
            else {
                var firstCommitted = _v2.a;
                var firstX = _v2.b;
                if (firstCommitted) {
                    return $author$project$ParserFast$Bad_fn(firstCommitted, firstX);
                }
                else {
                    var _v3 = attemptSecond(s);
                    if (!_v3.$) {
                        var second = _v3.a;
                        var s1 = _v3.b;
                        return $author$project$ParserFast$Good_fn(secondToChoice(second), s1);
                    }
                    else {
                        var secondCommitted = _v3.a;
                        var secondX = _v3.b;
                        return secondCommitted ? $author$project$ParserFast$Bad_fn(secondCommitted, secondX) : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingOneOf_fn(firstX, secondX, _List_Nil));
                    }
                }
            }
        };
    }, $author$project$ParserFast$oneOf2Map = F4($author$project$ParserFast$oneOf2Map_fn);
    function $author$project$Elm$Parser$Expression$cyclic$maybeDotReferenceExpressionTuple() {
        return $author$project$ParserFast$orSucceed_fn($author$project$ParserFast$symbolFollowedBy_fn(".", $author$project$ParserFast$oneOf2Map_fn($elm$core$Maybe$Just, $author$project$ParserFast$map2_fn_unwrapped(function (firstName, after) {
            if (after.$ === 1) {
                return _Utils_Tuple2(_List_Nil, firstName);
            }
            else {
                var _v1 = after.a;
                var qualificationAfter = _v1.a;
                var unqualified = _v1.b;
                return _Utils_Tuple2(_List_Cons(firstName, qualificationAfter), unqualified);
            }
        }, $author$project$Elm$Parser$Tokens$typeName, $author$project$ParserFast$lazy(function (_v2) {
            return $author$project$Elm$Parser$Expression$cyclic$maybeDotReferenceExpressionTuple();
        })), function (name) {
            return $elm$core$Maybe$Just(_Utils_Tuple2(_List_Nil, name));
        }, $author$project$Elm$Parser$Tokens$functionName)), $elm$core$Maybe$Nothing);
    }
    var $author$project$Elm$Parser$Expression$maybeDotReferenceExpressionTuple = $author$project$Elm$Parser$Expression$cyclic$maybeDotReferenceExpressionTuple();
    $author$project$Elm$Parser$Expression$cyclic$maybeDotReferenceExpressionTuple = function () {
        return $author$project$Elm$Parser$Expression$maybeDotReferenceExpressionTuple;
    };
    var $author$project$Elm$Parser$Expression$qualifiedOrVariantOrRecordConstructorReferenceExpressionFollowedByRecordAccess = $author$project$Elm$Parser$Expression$followedByMultiRecordAccess($author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, firstName, after) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, function () {
                if (after.$ === 1) {
                    return $author$project$Elm$Syntax$Expression$FunctionOrValue_fn(_List_Nil, firstName);
                }
                else {
                    var _v1 = after.a;
                    var qualificationAfter = _v1.a;
                    var unqualified = _v1.b;
                    return $author$project$Elm$Syntax$Expression$FunctionOrValue_fn(_List_Cons(firstName, qualificationAfter), unqualified);
                }
            }())
        };
    }, $author$project$Elm$Parser$Tokens$typeName, $author$project$Elm$Parser$Expression$maybeDotReferenceExpressionTuple));
    var $author$project$Elm$Parser$Expression$rangeMoveStartLeftByOneColumn = function (range) {
        return {
            cm: range.cm,
            bE: { bk: range.bE.bk - 1, bz: range.bE.bz }
        };
    };
    var $author$project$Elm$Syntax$Expression$RecordAccessFunction = function (a) {
        return { $: 21, a: a };
    };
    var $author$project$Elm$Parser$Expression$recordAccessFunctionExpression = $author$project$ParserFast$symbolFollowedBy_fn(".", $author$project$Elm$Parser$Tokens$functionNameMapWithRange(F2(function (range, field) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn($author$project$Elm$Parser$Expression$rangeMoveStartLeftByOneColumn(range), $author$project$Elm$Syntax$Expression$RecordAccessFunction("." + field))
        };
    })));
    var $author$project$Elm$Parser$Expression$unqualifiedFunctionReferenceExpressionFollowedByRecordAccess = $author$project$Elm$Parser$Expression$followedByMultiRecordAccess($author$project$Elm$Parser$Tokens$functionNameMapWithRange(F2(function (range, unqualified) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Expression$FunctionOrValue_fn(_List_Nil, unqualified))
        };
    })));
    var $author$project$Elm$Parser$Expression$referenceOrNumberExpression = $author$project$ParserFast$oneOf3_fn($author$project$Elm$Parser$Expression$qualifiedOrVariantOrRecordConstructorReferenceExpressionFollowedByRecordAccess, $author$project$Elm$Parser$Expression$unqualifiedFunctionReferenceExpressionFollowedByRecordAccess, $author$project$Elm$Parser$Expression$numberExpression);
    var $author$project$ParserFast$symbolBacktrackableFollowedBy_fn = function (str, _v0) {
        var parseNext = _v0;
        var strLength = $elm$core$String$length(str);
        return function (s) {
            var newOffset = s.b + strLength;
            return _Utils_eq(_String_slice_fn(s.b, newOffset, s.c), str + "") ? parseNext({ a: s.a + strLength, f: s.f, b: newOffset, bz: s.bz, c: s.c }) : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingSymbol_fn(s.bz, s.a, str));
        };
    }, $author$project$ParserFast$symbolBacktrackableFollowedBy = F2($author$project$ParserFast$symbolBacktrackableFollowedBy_fn);
    var $author$project$ParserFast$symbolWithEndLocation_fn = function (str, endLocationToRes) {
        var strLength = $elm$core$String$length(str);
        return function (s) {
            var newOffset = s.b + strLength;
            if (_Utils_eq(_String_slice_fn(s.b, newOffset, s.c), str + "")) {
                var newCol = s.a + strLength;
                return $author$project$ParserFast$Good_fn(endLocationToRes({ bk: newCol, bz: s.bz }), { a: newCol, f: s.f, b: newOffset, bz: s.bz, c: s.c });
            }
            else {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingSymbol_fn(s.bz, s.a, str));
            }
        };
    }, $author$project$ParserFast$symbolWithEndLocation = F2($author$project$ParserFast$symbolWithEndLocation_fn);
    var $author$project$Elm$Parser$Expression$temporaryErrPrecedenceTooHigh = $elm$core$Result$Err("infix operator precedence too high");
    var $author$project$Elm$Parser$TypeAnnotation$FieldsAfterName = function (a) {
        return { $: 1, a: a };
    };
    var $author$project$Elm$Syntax$TypeAnnotation$FunctionTypeAnnotation_fn = function (a, b) {
        return { $: 6, a: a, b: b };
    }, $author$project$Elm$Syntax$TypeAnnotation$FunctionTypeAnnotation = F2($author$project$Elm$Syntax$TypeAnnotation$FunctionTypeAnnotation_fn);
    var $author$project$Elm$Syntax$TypeAnnotation$GenericRecord_fn = function (a, b) {
        return { $: 5, a: a, b: b };
    }, $author$project$Elm$Syntax$TypeAnnotation$GenericRecord = F2($author$project$Elm$Syntax$TypeAnnotation$GenericRecord_fn);
    var $author$project$Elm$Syntax$TypeAnnotation$Record = function (a) {
        return { $: 4, a: a };
    };
    var $author$project$Elm$Parser$TypeAnnotation$RecordExtensionExpressionAfterName = function (a) {
        return { $: 0, a: a };
    };
    var $author$project$Elm$Syntax$TypeAnnotation$Tupled = function (a) {
        return { $: 3, a: a };
    };
    var $author$project$Elm$Syntax$TypeAnnotation$Typed_fn = function (a, b) {
        return { $: 1, a: a, b: b };
    }, $author$project$Elm$Syntax$TypeAnnotation$Typed = F2($author$project$Elm$Syntax$TypeAnnotation$Typed_fn);
    var $author$project$Elm$Syntax$TypeAnnotation$Unit = { $: 2 };
    var $author$project$Elm$Syntax$TypeAnnotation$GenericType = function (a) {
        return { $: 0, a: a };
    };
    var $author$project$Elm$Parser$TypeAnnotation$genericTypeAnnotation = $author$project$Elm$Parser$Tokens$functionNameMapWithRange(F2(function (range, _var) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$TypeAnnotation$GenericType(_var))
        };
    }));
    var $author$project$ParserFast$map3WithRange_fn = function (func, _v0, _v1, _v2) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        return function (s0) {
            var _v3 = parseA(s0);
            if (_v3.$ === 1) {
                var committed = _v3.a;
                var x = _v3.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v3.a;
                var s1 = _v3.b;
                var _v4 = parseB(s1);
                if (_v4.$ === 1) {
                    var x = _v4.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v4.a;
                    var s2 = _v4.b;
                    var _v5 = parseC(s2);
                    if (_v5.$ === 1) {
                        var x = _v5.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v5.a;
                        var s3 = _v5.b;
                        return $author$project$ParserFast$Good_fn(A4(func, {
                            cm: { bk: s3.a, bz: s3.bz },
                            bE: { bk: s0.a, bz: s0.bz }
                        }, a, b, c), s3);
                    }
                }
            }
        };
    }, $author$project$ParserFast$map3WithRange_fn_unwrapped = function (func, _v0, _v1, _v2) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        return function (s0) {
            var _v3 = parseA(s0);
            if (_v3.$ === 1) {
                var committed = _v3.a;
                var x = _v3.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v3.a;
                var s1 = _v3.b;
                var _v4 = parseB(s1);
                if (_v4.$ === 1) {
                    var x = _v4.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v4.a;
                    var s2 = _v4.b;
                    var _v5 = parseC(s2);
                    if (_v5.$ === 1) {
                        var x = _v5.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v5.a;
                        var s3 = _v5.b;
                        return $author$project$ParserFast$Good_fn(func({
                            cm: { bk: s3.a, bz: s3.bz },
                            bE: { bk: s0.a, bz: s0.bz }
                        }, a, b, c), s3);
                    }
                }
            }
        };
    }, $author$project$ParserFast$map3WithRange = F4($author$project$ParserFast$map3WithRange_fn);
    var $author$project$ParserFast$map6WithRange_fn = function (func, _v0, _v1, _v2, _v3, _v4, _v5) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        var parseF = _v5;
        return function (s0) {
            var _v6 = parseA(s0);
            if (_v6.$ === 1) {
                var committed = _v6.a;
                var x = _v6.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v6.a;
                var s1 = _v6.b;
                var _v7 = parseB(s1);
                if (_v7.$ === 1) {
                    var x = _v7.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v7.a;
                    var s2 = _v7.b;
                    var _v8 = parseC(s2);
                    if (_v8.$ === 1) {
                        var x = _v8.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v8.a;
                        var s3 = _v8.b;
                        var _v9 = parseD(s3);
                        if (_v9.$ === 1) {
                            var x = _v9.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v9.a;
                            var s4 = _v9.b;
                            var _v10 = parseE(s4);
                            if (_v10.$ === 1) {
                                var x = _v10.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v10.a;
                                var s5 = _v10.b;
                                var _v11 = parseF(s5);
                                if (_v11.$ === 1) {
                                    var x = _v11.b;
                                    return $author$project$ParserFast$Bad_fn(true, x);
                                }
                                else {
                                    var f = _v11.a;
                                    var s6 = _v11.b;
                                    return $author$project$ParserFast$Good_fn(A7(func, {
                                        cm: { bk: s6.a, bz: s6.bz },
                                        bE: { bk: s0.a, bz: s0.bz }
                                    }, a, b, c, d, e, f), s6);
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map6WithRange_fn_unwrapped = function (func, _v0, _v1, _v2, _v3, _v4, _v5) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        var parseF = _v5;
        return function (s0) {
            var _v6 = parseA(s0);
            if (_v6.$ === 1) {
                var committed = _v6.a;
                var x = _v6.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v6.a;
                var s1 = _v6.b;
                var _v7 = parseB(s1);
                if (_v7.$ === 1) {
                    var x = _v7.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v7.a;
                    var s2 = _v7.b;
                    var _v8 = parseC(s2);
                    if (_v8.$ === 1) {
                        var x = _v8.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v8.a;
                        var s3 = _v8.b;
                        var _v9 = parseD(s3);
                        if (_v9.$ === 1) {
                            var x = _v9.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v9.a;
                            var s4 = _v9.b;
                            var _v10 = parseE(s4);
                            if (_v10.$ === 1) {
                                var x = _v10.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v10.a;
                                var s5 = _v10.b;
                                var _v11 = parseF(s5);
                                if (_v11.$ === 1) {
                                    var x = _v11.b;
                                    return $author$project$ParserFast$Bad_fn(true, x);
                                }
                                else {
                                    var f = _v11.a;
                                    var s6 = _v11.b;
                                    return $author$project$ParserFast$Good_fn(func({
                                        cm: { bk: s6.a, bz: s6.bz },
                                        bE: { bk: s0.a, bz: s0.bz }
                                    }, a, b, c, d, e, f), s6);
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map6WithRange = F7($author$project$ParserFast$map6WithRange_fn);
    function $author$project$Elm$Parser$TypeAnnotation$cyclic$maybeDotTypeNamesTuple() {
        return $author$project$ParserFast$map2OrSucceed_fn_unwrapped(function (firstName, afterFirstName) {
            if (afterFirstName.$ === 1) {
                return $elm$core$Maybe$Just(_Utils_Tuple2(_List_Nil, firstName));
            }
            else {
                var _v1 = afterFirstName.a;
                var qualificationAfter = _v1.a;
                var unqualified = _v1.b;
                return $elm$core$Maybe$Just(_Utils_Tuple2(_List_Cons(firstName, qualificationAfter), unqualified));
            }
        }, $author$project$ParserFast$symbolFollowedBy_fn(".", $author$project$Elm$Parser$Tokens$typeName), $author$project$ParserFast$lazy(function (_v2) {
            return $author$project$Elm$Parser$TypeAnnotation$cyclic$maybeDotTypeNamesTuple();
        }), $elm$core$Maybe$Nothing);
    }
    var $author$project$Elm$Parser$TypeAnnotation$maybeDotTypeNamesTuple = $author$project$Elm$Parser$TypeAnnotation$cyclic$maybeDotTypeNamesTuple();
    $author$project$Elm$Parser$TypeAnnotation$cyclic$maybeDotTypeNamesTuple = function () {
        return $author$project$Elm$Parser$TypeAnnotation$maybeDotTypeNamesTuple;
    };
    var $author$project$ParserFast$oneOf4_fn = function (_v0, _v1, _v2, _v3) {
        var attemptFirst = _v0;
        var attemptSecond = _v1;
        var attemptThird = _v2;
        var attemptFourth = _v3;
        return function (s) {
            var _v4 = attemptFirst(s);
            if (!_v4.$) {
                var firstGood = _v4;
                return firstGood;
            }
            else {
                var firstBad = _v4;
                var firstCommitted = firstBad.a;
                var firstX = firstBad.b;
                if (firstCommitted) {
                    return firstBad;
                }
                else {
                    var _v5 = attemptSecond(s);
                    if (!_v5.$) {
                        var secondGood = _v5;
                        return secondGood;
                    }
                    else {
                        var secondBad = _v5;
                        var secondCommitted = secondBad.a;
                        var secondX = secondBad.b;
                        if (secondCommitted) {
                            return secondBad;
                        }
                        else {
                            var _v6 = attemptThird(s);
                            if (!_v6.$) {
                                var thirdGood = _v6;
                                return thirdGood;
                            }
                            else {
                                var thirdBad = _v6;
                                var thirdCommitted = thirdBad.a;
                                var thirdX = thirdBad.b;
                                if (thirdCommitted) {
                                    return thirdBad;
                                }
                                else {
                                    var _v7 = attemptFourth(s);
                                    if (!_v7.$) {
                                        var fourthGood = _v7;
                                        return fourthGood;
                                    }
                                    else {
                                        var fourthBad = _v7;
                                        var fourthCommitted = fourthBad.a;
                                        var fourthX = fourthBad.b;
                                        return fourthCommitted ? fourthBad : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingOneOf_fn(firstX, secondX, _List_fromArray([thirdX, fourthX])));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$oneOf4 = F4($author$project$ParserFast$oneOf4_fn);
    var $author$project$Elm$Parser$TypeAnnotation$typeAnnotationRecordEmpty = $author$project$Elm$Syntax$TypeAnnotation$Record(_List_Nil);
    var $author$project$Elm$Parser$TypeAnnotation$typedTypeAnnotationWithoutArguments = $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, startName, afterStartName) {
        var name = function () {
            if (afterStartName.$ === 1) {
                return _Utils_Tuple2(_List_Nil, startName);
            }
            else {
                var _v1 = afterStartName.a;
                var qualificationAfterStartName = _v1.a;
                var unqualified = _v1.b;
                return _Utils_Tuple2(_List_Cons(startName, qualificationAfterStartName), unqualified);
            }
        }();
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$TypeAnnotation$Typed_fn($author$project$Elm$Syntax$Node$Node_fn(range, name), _List_Nil))
        };
    }, $author$project$Elm$Parser$Tokens$typeName, $author$project$Elm$Parser$TypeAnnotation$maybeDotTypeNamesTuple);
    function $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotationNoFnIncludingTypedWithArguments() {
        return $author$project$ParserFast$oneOf4_fn($author$project$Elm$Parser$TypeAnnotation$cyclic$parensTypeAnnotation(), $author$project$Elm$Parser$TypeAnnotation$cyclic$typedTypeAnnotationWithArgumentsOptimisticLayout(), $author$project$Elm$Parser$TypeAnnotation$genericTypeAnnotation, $author$project$Elm$Parser$TypeAnnotation$cyclic$recordTypeAnnotation());
    }
    function $author$project$Elm$Parser$TypeAnnotation$cyclic$typedTypeAnnotationWithArgumentsOptimisticLayout() {
        return $author$project$ParserFast$map3_fn_unwrapped(function (nameNode, commentsAfterName, argsReverse) {
            var nameRange = nameNode.a;
            var range = function () {
                var _v7 = argsReverse.d;
                if (!_v7.b) {
                    return nameRange;
                }
                else {
                    var _v8 = _v7.a;
                    var lastArgRange = _v8.a;
                    return { cm: lastArgRange.cm, bE: nameRange.bE };
                }
            }();
            return {
                e: $author$project$Rope$prependTo_fn(argsReverse.e, commentsAfterName),
                d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$TypeAnnotation$Typed_fn(nameNode, $elm$core$List$reverse(argsReverse.d)))
            };
        }, $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, startName, afterStartName) {
            var name = function () {
                if (afterStartName.$ === 1) {
                    return _Utils_Tuple2(_List_Nil, startName);
                }
                else {
                    var _v10 = afterStartName.a;
                    var qualificationAfterStartName = _v10.a;
                    var unqualified = _v10.b;
                    return _Utils_Tuple2(_List_Cons(startName, qualificationAfterStartName), unqualified);
                }
            }();
            return $author$project$Elm$Syntax$Node$Node_fn(range, name);
        }, $author$project$Elm$Parser$Tokens$typeName, $author$project$Elm$Parser$TypeAnnotation$maybeDotTypeNamesTuple), $author$project$Elm$Parser$Layout$optimisticLayout, $author$project$ParserWithComments$manyWithoutReverse($author$project$Elm$Parser$Layout$positivelyIndentedFollowedBy($author$project$ParserFast$map2_fn_unwrapped(function (typeAnnotationResult, commentsAfter) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfter, typeAnnotationResult.e),
                d: typeAnnotationResult.d
            };
        }, $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotationNoFnExcludingTypedWithArguments(), $author$project$Elm$Parser$Layout$optimisticLayout))));
    }
    function $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotationNoFnExcludingTypedWithArguments() {
        return $author$project$ParserFast$oneOf4_fn($author$project$Elm$Parser$TypeAnnotation$cyclic$parensTypeAnnotation(), $author$project$Elm$Parser$TypeAnnotation$typedTypeAnnotationWithoutArguments, $author$project$Elm$Parser$TypeAnnotation$genericTypeAnnotation, $author$project$Elm$Parser$TypeAnnotation$cyclic$recordTypeAnnotation());
    }
    function $author$project$Elm$Parser$TypeAnnotation$cyclic$parensTypeAnnotation() {
        return $author$project$ParserFast$symbolFollowedBy_fn("(", $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbolWithEndLocation_fn(")", function (end) {
            return {
                e: $author$project$Rope$empty,
                d: $author$project$Elm$Syntax$Node$Node_fn({
                    cm: end,
                    bE: { bk: end.bk - 2, bz: end.bz }
                }, $author$project$Elm$Syntax$TypeAnnotation$Unit)
            };
        }), $author$project$ParserFast$map4WithRange_fn_unwrapped(function (rangeAfterOpeningParens, commentsBeforeFirstPart, firstPart, commentsAfterFirstPart, lastToSecondPart) {
            return {
                e: $author$project$Rope$prependTo_fn(lastToSecondPart.e, $author$project$Rope$prependTo_fn(commentsAfterFirstPart, $author$project$Rope$prependTo_fn(firstPart.e, commentsBeforeFirstPart))),
                d: $author$project$Elm$Syntax$Node$Node_fn({
                    cm: rangeAfterOpeningParens.cm,
                    bE: { bk: rangeAfterOpeningParens.bE.bk - 1, bz: rangeAfterOpeningParens.bE.bz }
                }, function () {
                    var _v4 = lastToSecondPart.d;
                    if (_v4.$ === 1) {
                        var _v5 = firstPart.d;
                        var firstPartType = _v5.b;
                        return firstPartType;
                    }
                    else {
                        var firstAndMaybeThirdPart = _v4.a;
                        var _v6 = firstAndMaybeThirdPart.cI;
                        if (_v6.$ === 1) {
                            return $author$project$Elm$Syntax$TypeAnnotation$Tupled(_List_fromArray([firstPart.d, firstAndMaybeThirdPart.b2]));
                        }
                        else {
                            var thirdPart = _v6.a;
                            return $author$project$Elm$Syntax$TypeAnnotation$Tupled(_List_fromArray([firstPart.d, firstAndMaybeThirdPart.b2, thirdPart]));
                        }
                    }
                }())
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation(), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbol_fn(")", { e: $author$project$Rope$empty, d: $elm$core$Maybe$Nothing }), $author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$ParserFast$map4_fn_unwrapped(function (commentsBefore, secondPartResult, commentsAfter, maybeThirdPartResult) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfter, $author$project$Rope$prependTo_fn(secondPartResult.e, commentsBefore)),
                d: $elm$core$Maybe$Just({ cI: maybeThirdPartResult.d, b2: secondPartResult.d })
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation(), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbol_fn(")", { e: $author$project$Rope$empty, d: $elm$core$Maybe$Nothing }), $author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$ParserFast$followedBySymbol_fn(")", $author$project$ParserFast$map3_fn_unwrapped(function (commentsBefore, thirdPartResult, commentsAfter) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfter, $author$project$Rope$prependTo_fn(thirdPartResult.e, commentsBefore)),
                d: $elm$core$Maybe$Just(thirdPartResult.d)
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation(), $author$project$Elm$Parser$Layout$maybeLayout))))))))));
    }
    function $author$project$Elm$Parser$TypeAnnotation$cyclic$recordTypeAnnotation() {
        return $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, commentsBefore, afterCurly) {
            return {
                e: $author$project$Rope$prependTo_fn(afterCurly.e, commentsBefore),
                d: function () {
                    var _v2 = afterCurly.d;
                    if (_v2.$ === 1) {
                        return $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Parser$TypeAnnotation$typeAnnotationRecordEmpty);
                    }
                    else {
                        var afterCurlyResult = _v2.a;
                        return $author$project$Elm$Syntax$Node$Node_fn(range, afterCurlyResult);
                    }
                }()
            };
        }, $author$project$ParserFast$symbolFollowedBy_fn("{", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$followedBySymbol_fn("}", $author$project$ParserFast$map3_fn_unwrapped(function (firstNameNode, commentsAfterFirstName, afterFirstName) {
            return {
                e: $author$project$Rope$prependTo_fn(afterFirstName.e, commentsAfterFirstName),
                d: $elm$core$Maybe$Just(function () {
                    var _v3 = afterFirstName.d;
                    if (!_v3.$) {
                        var fields = _v3.a;
                        return $author$project$Elm$Syntax$TypeAnnotation$GenericRecord_fn(firstNameNode, fields);
                    }
                    else {
                        var fieldsAfterName = _v3.a;
                        return $author$project$Elm$Syntax$TypeAnnotation$Record(_List_Cons($author$project$Elm$Syntax$Node$combine_fn($elm$core$Tuple$pair, firstNameNode, fieldsAfterName.cp), fieldsAfterName.dc));
                    }
                }())
            };
        }, $author$project$Elm$Parser$Tokens$functionNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbolFollowedBy_fn("|", $author$project$ParserFast$map3WithRange_fn_unwrapped(function (range, commentsBefore, head, tail) {
            return {
                e: $author$project$Rope$prependTo_fn(tail.e, $author$project$Rope$prependTo_fn(head.e, commentsBefore)),
                d: $author$project$Elm$Parser$TypeAnnotation$RecordExtensionExpressionAfterName($author$project$Elm$Syntax$Node$Node_fn(range, _List_Cons(head.d, tail.d)))
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$TypeAnnotation$cyclic$recordFieldDefinition(), $author$project$ParserWithComments$many($author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$ParserFast$map2_fn_unwrapped(function (commentsBefore, field) {
            return {
                e: $author$project$Rope$prependTo_fn(field.e, commentsBefore),
                d: field.d
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$TypeAnnotation$cyclic$recordFieldDefinition()))))), $author$project$ParserFast$symbolFollowedBy_fn(":", $author$project$ParserFast$map4_fn_unwrapped(function (commentsBeforeFirstFieldValue, firstFieldValue, commentsAfterFirstFieldValue, tailFields) {
            return {
                e: $author$project$Rope$prependTo_fn(tailFields.e, $author$project$Rope$prependTo_fn(commentsAfterFirstFieldValue, $author$project$Rope$prependTo_fn(firstFieldValue.e, commentsBeforeFirstFieldValue))),
                d: $author$project$Elm$Parser$TypeAnnotation$FieldsAfterName({ cp: firstFieldValue.d, dc: tailFields.d })
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation(), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$orSucceed_fn($author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$Elm$Parser$TypeAnnotation$cyclic$recordFieldsTypeAnnotation()), { e: $author$project$Rope$empty, d: _List_Nil })))))), $author$project$ParserFast$symbol_fn("}", { e: $author$project$Rope$empty, d: $elm$core$Maybe$Nothing })));
    }
    function $author$project$Elm$Parser$TypeAnnotation$cyclic$recordFieldsTypeAnnotation() {
        return $author$project$ParserFast$map3_fn_unwrapped(function (commentsBefore, head, tail) {
            return {
                e: $author$project$Rope$prependTo_fn(tail.e, $author$project$Rope$prependTo_fn(head.e, commentsBefore)),
                d: _List_Cons(head.d, tail.d)
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$TypeAnnotation$cyclic$recordFieldDefinition(), $author$project$ParserWithComments$many($author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$ParserFast$map2_fn_unwrapped(function (commentsBefore, field) {
            return {
                e: $author$project$Rope$prependTo_fn(field.e, commentsBefore),
                d: field.d
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$TypeAnnotation$cyclic$recordFieldDefinition()))));
    }
    function $author$project$Elm$Parser$TypeAnnotation$cyclic$recordFieldDefinition() {
        return $author$project$ParserFast$map6WithRange_fn_unwrapped(function (range, commentsBeforeFunctionName, name, commentsAfterFunctionName, commentsAfterColon, value, commentsAfterValue) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfterValue, $author$project$Rope$prependTo_fn(value.e, $author$project$Rope$prependTo_fn(commentsAfterColon, $author$project$Rope$prependTo_fn(commentsAfterFunctionName, commentsBeforeFunctionName)))),
                d: $author$project$Elm$Syntax$Node$Node_fn(range, _Utils_Tuple2(name, value.d))
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Tokens$functionNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$symbolFollowedBy_fn(":", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation(), $author$project$Elm$Parser$Layout$maybeLayout);
    }
    function $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation() {
        return $author$project$ParserFast$loopWhileSucceedsOntoResultFromParserRightToLeftStackUnsafe_fn_unwrapped($author$project$ParserFast$map2_fn_unwrapped(function (startType, commentsAfter) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfter, startType.e),
                d: startType.d
            };
        }, $author$project$ParserFast$lazy(function (_v0) {
            return $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotationNoFnIncludingTypedWithArguments();
        }), $author$project$Elm$Parser$Layout$optimisticLayout), $author$project$ParserFast$symbolFollowedBy_fn("->", $author$project$Elm$Parser$Layout$positivelyIndentedPlusFollowedBy_fn(2, $author$project$ParserFast$map3_fn_unwrapped(function (commentsAfterArrow, typeAnnotationResult, commentsAfterType) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfterType, $author$project$Rope$prependTo_fn(typeAnnotationResult.e, commentsAfterArrow)),
                d: typeAnnotationResult.d
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$lazy(function (_v1) {
            return $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotationNoFnIncludingTypedWithArguments();
        }), $author$project$Elm$Parser$Layout$optimisticLayout))), function (inType, outType) {
            return {
                e: $author$project$Rope$prependTo_fn(outType.e, inType.e),
                d: $author$project$Elm$Syntax$Node$combine_fn($author$project$Elm$Syntax$TypeAnnotation$FunctionTypeAnnotation, inType.d, outType.d)
            };
        });
    }
    var $author$project$Elm$Parser$TypeAnnotation$typeAnnotationNoFnIncludingTypedWithArguments = $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotationNoFnIncludingTypedWithArguments();
    $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotationNoFnIncludingTypedWithArguments = function () {
        return $author$project$Elm$Parser$TypeAnnotation$typeAnnotationNoFnIncludingTypedWithArguments;
    };
    var $author$project$Elm$Parser$TypeAnnotation$typedTypeAnnotationWithArgumentsOptimisticLayout = $author$project$Elm$Parser$TypeAnnotation$cyclic$typedTypeAnnotationWithArgumentsOptimisticLayout();
    $author$project$Elm$Parser$TypeAnnotation$cyclic$typedTypeAnnotationWithArgumentsOptimisticLayout = function () {
        return $author$project$Elm$Parser$TypeAnnotation$typedTypeAnnotationWithArgumentsOptimisticLayout;
    };
    var $author$project$Elm$Parser$TypeAnnotation$typeAnnotationNoFnExcludingTypedWithArguments = $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotationNoFnExcludingTypedWithArguments();
    $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotationNoFnExcludingTypedWithArguments = function () {
        return $author$project$Elm$Parser$TypeAnnotation$typeAnnotationNoFnExcludingTypedWithArguments;
    };
    var $author$project$Elm$Parser$TypeAnnotation$parensTypeAnnotation = $author$project$Elm$Parser$TypeAnnotation$cyclic$parensTypeAnnotation();
    $author$project$Elm$Parser$TypeAnnotation$cyclic$parensTypeAnnotation = function () {
        return $author$project$Elm$Parser$TypeAnnotation$parensTypeAnnotation;
    };
    var $author$project$Elm$Parser$TypeAnnotation$recordTypeAnnotation = $author$project$Elm$Parser$TypeAnnotation$cyclic$recordTypeAnnotation();
    $author$project$Elm$Parser$TypeAnnotation$cyclic$recordTypeAnnotation = function () {
        return $author$project$Elm$Parser$TypeAnnotation$recordTypeAnnotation;
    };
    var $author$project$Elm$Parser$TypeAnnotation$recordFieldsTypeAnnotation = $author$project$Elm$Parser$TypeAnnotation$cyclic$recordFieldsTypeAnnotation();
    $author$project$Elm$Parser$TypeAnnotation$cyclic$recordFieldsTypeAnnotation = function () {
        return $author$project$Elm$Parser$TypeAnnotation$recordFieldsTypeAnnotation;
    };
    var $author$project$Elm$Parser$TypeAnnotation$recordFieldDefinition = $author$project$Elm$Parser$TypeAnnotation$cyclic$recordFieldDefinition();
    $author$project$Elm$Parser$TypeAnnotation$cyclic$recordFieldDefinition = function () {
        return $author$project$Elm$Parser$TypeAnnotation$recordFieldDefinition;
    };
    var $author$project$Elm$Parser$TypeAnnotation$typeAnnotation = $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation();
    $author$project$Elm$Parser$TypeAnnotation$cyclic$typeAnnotation = function () {
        return $author$project$Elm$Parser$TypeAnnotation$typeAnnotation;
    };
    var $author$project$ParserFast$validate_fn = function (isOkay, problemOnNotOkay, _v0) {
        var parseA = _v0;
        return function (s0) {
            var _v1 = parseA(s0);
            if (_v1.$ === 1) {
                var committed = _v1.a;
                var x = _v1.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var good = _v1;
                var a = good.a;
                var s1 = good.b;
                return isOkay(a) ? good : $author$project$ParserFast$Bad_fn(true, $author$project$ParserFast$ExpectingCustom_fn(s1.bz, s1.a, problemOnNotOkay));
            }
        };
    }, $author$project$ParserFast$validate = F3($author$project$ParserFast$validate_fn);
    var $author$project$ParserFast$whileAtMost3WithoutLinebreakAnd2PartUtf16ToResultAndThen_fn = function (charAsStringIsOkay, consumedStringToIntermediateOrErr, intermediateToFollowupParser) {
        return function (s0) {
            var src = s0.c;
            var s0Offset = s0.b;
            var consumed = charAsStringIsOkay(_String_slice_fn(s0Offset, s0Offset + 1, src)) ? (charAsStringIsOkay(_String_slice_fn(s0Offset + 1, s0Offset + 2, src)) ? (charAsStringIsOkay(_String_slice_fn(s0Offset + 2, s0Offset + 3, src)) ? {
                aO: 3,
                a9: _String_slice_fn(s0Offset, s0Offset + 3, src)
            } : {
                aO: 2,
                a9: _String_slice_fn(s0Offset, s0Offset + 2, src)
            }) : {
                aO: 1,
                a9: _String_slice_fn(s0Offset, s0Offset + 1, src)
            }) : { aO: 0, a9: "" };
            var _v0 = consumedStringToIntermediateOrErr(consumed.a9);
            if (!_v0.$) {
                var intermediate = _v0.a;
                var _v1 = intermediateToFollowupParser(intermediate);
                var parseFollowup = _v1;
                return $author$project$ParserFast$pStepCommit(parseFollowup({ a: s0.a + consumed.aO, f: s0.f, b: s0Offset + consumed.aO, bz: s0.bz, c: src }));
            }
            else {
                var problemMessage = _v0.a;
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingCustom_fn(s0.bz, s0.a, problemMessage));
            }
        };
    }, $author$project$ParserFast$whileAtMost3WithoutLinebreakAnd2PartUtf16ToResultAndThen = F3($author$project$ParserFast$whileAtMost3WithoutLinebreakAnd2PartUtf16ToResultAndThen_fn);
    var $author$project$ParserFast$changeIndent_fn = function (newIndent, s) {
        return { a: s.a, f: newIndent, b: s.b, bz: s.bz, c: s.c };
    }, $author$project$ParserFast$changeIndent = F2($author$project$ParserFast$changeIndent_fn);
    var $author$project$ParserFast$withIndentSetToColumn = function (_v0) {
        var parse = _v0;
        return function (s0) {
            var _v1 = parse($author$project$ParserFast$changeIndent_fn(s0.a, s0));
            if (!_v1.$) {
                var a = _v1.a;
                var s1 = _v1.b;
                return $author$project$ParserFast$Good_fn(a, $author$project$ParserFast$changeIndent_fn(s0.f, s1));
            }
            else {
                var bad = _v1;
                return bad;
            }
        };
    };
    var $author$project$ParserFast$withIndentSetToColumnMinus_fn = function (columnToMoveIndentationBaseBackBy, _v0) {
        var parse = _v0;
        return function (s0) {
            var _v1 = parse($author$project$ParserFast$changeIndent_fn(s0.a - columnToMoveIndentationBaseBackBy, s0));
            if (!_v1.$) {
                var a = _v1.a;
                var s1 = _v1.b;
                return $author$project$ParserFast$Good_fn(a, $author$project$ParserFast$changeIndent_fn(s0.f, s1));
            }
            else {
                var bad = _v1;
                return bad;
            }
        };
    }, $author$project$ParserFast$withIndentSetToColumnMinus = F2($author$project$ParserFast$withIndentSetToColumnMinus_fn);
    var $author$project$Elm$Parser$Expression$extendedSubExpressionOptimisticLayout = function (info) {
        return $author$project$ParserFast$loopWhileSucceedsOntoResultFromParser_fn($author$project$Elm$Parser$Layout$positivelyIndentedFollowedBy($author$project$Elm$Parser$Expression$infixOperatorAndThen(info)), $author$project$Elm$Parser$Expression$cyclic$subExpressionMaybeAppliedOptimisticLayout(), F2(function (extensionRightResult, leftNodeWithComments) {
            return {
                e: $author$project$Rope$prependTo_fn(extensionRightResult.e, leftNodeWithComments.e),
                d: $author$project$Elm$Parser$Expression$applyExtensionRight_fn(extensionRightResult.d, leftNodeWithComments.d)
            };
        }), $elm$core$Basics$identity);
    };
    var $author$project$Elm$Parser$Expression$extensionRightParser = function (extensionRightInfo) {
        return $author$project$ParserFast$map2_fn_unwrapped(function (commentsBefore, right) {
            return {
                e: $author$project$Rope$prependTo_fn(right.e, commentsBefore),
                d: { d6: extensionRightInfo.d6, V: right.d, T: extensionRightInfo.T }
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$lazy(function (_v7) {
            return $author$project$Elm$Parser$Expression$extendedSubExpressionOptimisticLayout(extensionRightInfo);
        }));
    };
    var $author$project$Elm$Parser$Expression$followedByMultiArgumentApplication = function (appliedExpressionParser) {
        return $author$project$ParserFast$map3_fn_unwrapped(function (leftExpressionResult, commentsBeforeExtension, maybeArgsReverse) {
            return {
                e: $author$project$Rope$prependTo_fn(maybeArgsReverse.e, $author$project$Rope$prependTo_fn(commentsBeforeExtension, leftExpressionResult.e)),
                d: function () {
                    var _v5 = maybeArgsReverse.d;
                    if (!_v5.b) {
                        return leftExpressionResult.d;
                    }
                    else {
                        var argsReverse = _v5;
                        var _v6 = argsReverse.a;
                        var lastArgRange = _v6.a;
                        var leftNode = leftExpressionResult.d;
                        var leftRange = leftNode.a;
                        return $author$project$Elm$Syntax$Node$Node_fn({ cm: lastArgRange.cm, bE: leftRange.bE }, $author$project$Elm$Syntax$Expression$Application(_List_Cons(leftNode, $elm$core$List$reverse(argsReverse))));
                    }
                }()
            };
        }, appliedExpressionParser, $author$project$Elm$Parser$Layout$optimisticLayout, $author$project$ParserWithComments$manyWithoutReverse($author$project$Elm$Parser$Layout$positivelyIndentedFollowedBy($author$project$ParserFast$map2_fn_unwrapped(function (arg, commentsAfter) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfter, arg.e),
                d: arg.d
            };
        }, $author$project$Elm$Parser$Expression$cyclic$subExpression(), $author$project$Elm$Parser$Layout$optimisticLayout))));
    };
    var $author$project$Elm$Parser$Expression$infixLeft_fn = function (leftPrecedence, symbol) {
        return {
            ac: $author$project$Elm$Parser$Expression$extensionRightParser({
                a_: function ($) {
                    return $.ac;
                },
                d6: 0,
                T: symbol,
                bf: function (rightInfo) {
                    return (_Utils_cmp(rightInfo.af, leftPrecedence) > 0) ? $elm$core$Result$Ok(rightInfo) : $author$project$Elm$Parser$Expression$temporaryErrPrecedenceTooHigh;
                }
            }),
            af: leftPrecedence,
            T: symbol
        };
    }, $author$project$Elm$Parser$Expression$infixLeft = F2($author$project$Elm$Parser$Expression$infixLeft_fn);
    var $author$project$Elm$Parser$Expression$infixNonAssociative_fn = function (leftPrecedence, symbol) {
        return {
            ac: $author$project$Elm$Parser$Expression$extensionRightParser({
                a_: function (rightInfo) {
                    return _Utils_eq(rightInfo.af, leftPrecedence) ? $author$project$Elm$Parser$Expression$problemCannotMixNonAssociativeInfixOperators : rightInfo.ac;
                },
                d6: 2,
                T: symbol,
                bf: function (rightInfo) {
                    return (_Utils_cmp(rightInfo.af, leftPrecedence) > -1) ? $elm$core$Result$Ok(rightInfo) : $author$project$Elm$Parser$Expression$temporaryErrPrecedenceTooHigh;
                }
            }),
            af: leftPrecedence,
            T: symbol
        };
    }, $author$project$Elm$Parser$Expression$infixNonAssociative = F2($author$project$Elm$Parser$Expression$infixNonAssociative_fn);
    var $author$project$Elm$Parser$Expression$infixOperatorAndThen = function (extensionRightConstraints) {
        var toResult = extensionRightConstraints.bf;
        var subResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence6Sub());
        var slashResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence7Slash());
        var questionMarkResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence8QuestionMark());
        var powResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence8Pow());
        var orResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence2Or());
        var neqResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence4Neq());
        var mulResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence7Mul());
        var ltResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence4Lt());
        var leResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence4Le());
        var keepResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence5Keep());
        var ignoreResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence6Ignore());
        var idivResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence7Idiv());
        var gtResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence4Gt());
        var geResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence4Ge());
        var fdivResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence7Fdiv());
        var eqResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence4Eq());
        var consResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence5Cons());
        var composeRResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence9ComposeR());
        var composeLResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence9ComposeL());
        var appendResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence5append());
        var apRResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence1ApR());
        var apLResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence1ApL());
        var andResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence3And());
        var addResult = toResult($author$project$Elm$Parser$Expression$cyclic$precedence6Add());
        return $author$project$ParserFast$whileAtMost3WithoutLinebreakAnd2PartUtf16ToResultAndThen_fn($author$project$Elm$Parser$Tokens$isOperatorSymbolCharAsString, function (operator) {
            switch (operator) {
                case "|>":
                    return apRResult;
                case "++":
                    return appendResult;
                case "<|":
                    return apLResult;
                case ">>":
                    return composeRResult;
                case "==":
                    return eqResult;
                case "*":
                    return mulResult;
                case "::":
                    return consResult;
                case "+":
                    return addResult;
                case "-":
                    return subResult;
                case "|.":
                    return ignoreResult;
                case "&&":
                    return andResult;
                case "|=":
                    return keepResult;
                case "<<":
                    return composeLResult;
                case "/=":
                    return neqResult;
                case "//":
                    return idivResult;
                case "/":
                    return fdivResult;
                case "</>":
                    return slashResult;
                case "||":
                    return orResult;
                case "<=":
                    return leResult;
                case ">=":
                    return geResult;
                case ">":
                    return gtResult;
                case "<?>":
                    return questionMarkResult;
                case "<":
                    return ltResult;
                case "^":
                    return powResult;
                default:
                    return $author$project$Elm$Parser$Expression$errUnknownInfixOperator;
            }
        }, extensionRightConstraints.a_);
    };
    var $author$project$Elm$Parser$Expression$infixRight_fn = function (leftPrecedence, symbol) {
        return {
            ac: $author$project$Elm$Parser$Expression$extensionRightParser({
                a_: function ($) {
                    return $.ac;
                },
                d6: 1,
                T: symbol,
                bf: function (rightInfo) {
                    return (_Utils_cmp(rightInfo.af, leftPrecedence) > -1) ? $elm$core$Result$Ok(rightInfo) : $author$project$Elm$Parser$Expression$temporaryErrPrecedenceTooHigh;
                }
            }),
            af: leftPrecedence,
            T: symbol
        };
    }, $author$project$Elm$Parser$Expression$infixRight = F2($author$project$Elm$Parser$Expression$infixRight_fn);
    function $author$project$Elm$Parser$Expression$cyclic$letOrUnqualifiedReferenceExpressionMaybeApplied() {
        return $author$project$ParserFast$oneOf2_fn($author$project$Elm$Parser$Expression$followedByOptimisticLayout($author$project$Elm$Parser$Expression$cyclic$letExpression()), $author$project$Elm$Parser$Expression$followedByMultiArgumentApplication($author$project$Elm$Parser$Expression$unqualifiedFunctionReferenceExpressionFollowedByRecordAccess));
    }
    function $author$project$Elm$Parser$Expression$cyclic$letOrUnqualifiedReferenceExpression() {
        return $author$project$ParserFast$oneOf2_fn($author$project$Elm$Parser$Expression$cyclic$letExpression(), $author$project$Elm$Parser$Expression$unqualifiedFunctionReferenceExpressionFollowedByRecordAccess);
    }
    function $author$project$Elm$Parser$Expression$cyclic$letExpression() {
        return $author$project$ParserFast$keywordFollowedBy_fn("let", $author$project$ParserFast$map3WithStartLocation_fn_unwrapped(function (start, declarations, commentsAfterIn, expressionResult) {
            var _v33 = expressionResult.d;
            var expressionRange = _v33.a;
            return {
                e: $author$project$Rope$prependTo_fn(expressionResult.e, $author$project$Rope$prependTo_fn(commentsAfterIn, declarations.e)),
                d: $author$project$Elm$Syntax$Node$Node_fn({
                    cm: expressionRange.cm,
                    bE: { bk: start.bk - 3, bz: start.bz }
                }, $author$project$Elm$Syntax$Expression$LetExpression({ bS: declarations.bS, V: expressionResult.d }))
            };
        }, $author$project$ParserFast$withIndentSetToColumnMinus_fn(3, $author$project$ParserFast$map2_fn_unwrapped(function (commentsAfterLet, declarations) {
            return {
                e: $author$project$Rope$prependTo_fn(declarations.e, commentsAfterLet),
                bS: declarations.d
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$withIndentSetToColumn($author$project$Elm$Parser$Expression$cyclic$letDeclarationsIn()))), $author$project$Elm$Parser$Layout$positivelyIndentedPlusFollowedBy_fn(2, $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Expression$cyclic$expression()));
    }
    function $author$project$Elm$Parser$Expression$cyclic$letDeclarationsIn() {
        return $author$project$Elm$Parser$Layout$onTopIndentationFollowedBy($author$project$ParserFast$map3_fn_unwrapped(function (headLetResult, commentsAfter, tailLetResult) {
            return {
                e: $author$project$Rope$prependTo_fn(tailLetResult.e, $author$project$Rope$prependTo_fn(commentsAfter, headLetResult.e)),
                d: _List_Cons(headLetResult.d, tailLetResult.d)
            };
        }, $author$project$ParserFast$oneOf2_fn($author$project$Elm$Parser$Expression$cyclic$letFunction(), $author$project$Elm$Parser$Expression$cyclic$letDestructuringDeclaration()), $author$project$Elm$Parser$Layout$optimisticLayout, $author$project$ParserWithComments$until_fn($author$project$Elm$Parser$Tokens$inToken, $author$project$Elm$Parser$Expression$cyclic$blockElement())));
    }
    function $author$project$Elm$Parser$Expression$cyclic$blockElement() {
        return $author$project$Elm$Parser$Layout$onTopIndentationFollowedBy($author$project$ParserFast$map2_fn_unwrapped(function (letDeclarationResult, commentsAfter) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfter, letDeclarationResult.e),
                d: letDeclarationResult.d
            };
        }, $author$project$ParserFast$oneOf2_fn($author$project$Elm$Parser$Expression$cyclic$letFunction(), $author$project$Elm$Parser$Expression$cyclic$letDestructuringDeclaration()), $author$project$Elm$Parser$Layout$optimisticLayout));
    }
    function $author$project$Elm$Parser$Expression$cyclic$caseOrUnqualifiedReferenceExpressionMaybeApplied() {
        return $author$project$ParserFast$oneOf2_fn($author$project$Elm$Parser$Expression$followedByOptimisticLayout($author$project$Elm$Parser$Expression$cyclic$caseExpression()), $author$project$Elm$Parser$Expression$followedByMultiArgumentApplication($author$project$Elm$Parser$Expression$unqualifiedFunctionReferenceExpressionFollowedByRecordAccess));
    }
    function $author$project$Elm$Parser$Expression$cyclic$caseOrUnqualifiedReferenceExpression() {
        return $author$project$ParserFast$oneOf2_fn($author$project$Elm$Parser$Expression$cyclic$caseExpression(), $author$project$Elm$Parser$Expression$unqualifiedFunctionReferenceExpressionFollowedByRecordAccess);
    }
    function $author$project$Elm$Parser$Expression$cyclic$caseExpression() {
        return $author$project$ParserFast$keywordFollowedBy_fn("case", $author$project$ParserFast$map5WithStartLocation_fn_unwrapped(function (start, commentsAfterCase, casedExpressionResult, commentsBeforeOf, commentsAfterOf, casesResult) {
            var _v27 = casesResult.d;
            var firstCase = _v27.a;
            var lastToSecondCase = _v27.b;
            return {
                e: $author$project$Rope$prependTo_fn(casesResult.e, $author$project$Rope$prependTo_fn(commentsAfterOf, $author$project$Rope$prependTo_fn(commentsBeforeOf, $author$project$Rope$prependTo_fn(casedExpressionResult.e, commentsAfterCase)))),
                d: $author$project$Elm$Syntax$Node$Node_fn({
                    cm: function () {
                        if (lastToSecondCase.b) {
                            var _v29 = lastToSecondCase.a;
                            var _v30 = _v29.b;
                            var lastCaseExpressionRange = _v30.a;
                            return lastCaseExpressionRange.cm;
                        }
                        else {
                            var _v31 = firstCase;
                            var _v32 = _v31.b;
                            var firstCaseExpressionRange = _v32.a;
                            return firstCaseExpressionRange.cm;
                        }
                    }(),
                    bE: { bk: start.bk - 4, bz: start.bz }
                }, $author$project$Elm$Syntax$Expression$CaseExpression({
                    dU: _List_Cons(firstCase, $elm$core$List$reverse(lastToSecondCase)),
                    V: casedExpressionResult.d
                }))
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$cyclic$expression(), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$keywordFollowedBy_fn("of", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$ParserFast$withIndentSetToColumn($author$project$Elm$Parser$Expression$cyclic$caseStatements())));
    }
    function $author$project$Elm$Parser$Expression$cyclic$caseStatements() {
        return $author$project$ParserFast$map5_fn_unwrapped(function (firstCasePatternResult, commentsAfterFirstCasePattern, commentsAfterFirstCaseArrowRight, firstCaseExpressionResult, lastToSecondCase) {
            return {
                e: $author$project$Rope$prependTo_fn(lastToSecondCase.e, $author$project$Rope$prependTo_fn(firstCaseExpressionResult.e, $author$project$Rope$prependTo_fn(commentsAfterFirstCaseArrowRight, $author$project$Rope$prependTo_fn(commentsAfterFirstCasePattern, firstCasePatternResult.e)))),
                d: _Utils_Tuple2(_Utils_Tuple2(firstCasePatternResult.d, firstCaseExpressionResult.d), lastToSecondCase.d)
            };
        }, $author$project$Elm$Parser$Patterns$pattern, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$symbolFollowedBy_fn("->", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Expression$cyclic$expression(), $author$project$ParserWithComments$manyWithoutReverse($author$project$Elm$Parser$Expression$cyclic$caseStatement()));
    }
    function $author$project$Elm$Parser$Expression$cyclic$caseStatement() {
        return $author$project$Elm$Parser$Layout$onTopIndentationFollowedBy($author$project$ParserFast$map4_fn_unwrapped(function (pattern, commentsBeforeArrowRight, commentsAfterArrowRight, expr) {
            return {
                e: $author$project$Rope$prependTo_fn(expr.e, $author$project$Rope$prependTo_fn(commentsAfterArrowRight, $author$project$Rope$prependTo_fn(commentsBeforeArrowRight, pattern.e))),
                d: _Utils_Tuple2(pattern.d, expr.d)
            };
        }, $author$project$Elm$Parser$Patterns$pattern, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$symbolFollowedBy_fn("->", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Expression$cyclic$expression()));
    }
    function $author$project$Elm$Parser$Expression$cyclic$tupledExpressionIfNecessaryFollowedByRecordAccessMaybeApplied() {
        return $author$project$Elm$Parser$Expression$followedByMultiArgumentApplication($author$project$Elm$Parser$Expression$cyclic$tupledExpressionIfNecessaryFollowedByRecordAccess());
    }
    function $author$project$Elm$Parser$Expression$cyclic$tupledExpressionIfNecessaryFollowedByRecordAccess() {
        return $author$project$ParserFast$symbolFollowedBy_fn("(", $author$project$ParserFast$oneOf3_fn($author$project$ParserFast$symbolWithEndLocation_fn(")", function (end) {
            return {
                e: $author$project$Rope$empty,
                d: $author$project$Elm$Syntax$Node$Node_fn({
                    cm: end,
                    bE: { bk: end.bk - 2, bz: end.bz }
                }, $author$project$Elm$Syntax$Expression$UnitExpr)
            };
        }), $author$project$Elm$Parser$Expression$allowedPrefixOperatorFollowedByClosingParensOneOf, $author$project$Elm$Parser$Expression$cyclic$tupledExpressionInnerAfterOpeningParens()));
    }
    function $author$project$Elm$Parser$Expression$cyclic$tupledExpressionInnerAfterOpeningParens() {
        return $author$project$Elm$Parser$Expression$followedByMultiRecordAccess($author$project$ParserFast$map4WithRange_fn_unwrapped(function (rangeAfterOpeningParens, commentsBeforeFirstPart, firstPart, commentsAfterFirstPart, tailParts) {
            return {
                e: $author$project$Rope$prependTo_fn(tailParts.e, $author$project$Rope$prependTo_fn(commentsAfterFirstPart, $author$project$Rope$prependTo_fn(firstPart.e, commentsBeforeFirstPart))),
                d: function () {
                    var _v25 = tailParts.d;
                    if (!_v25.$) {
                        return $author$project$Elm$Syntax$Node$Node_fn({
                            cm: rangeAfterOpeningParens.cm,
                            bE: { bk: rangeAfterOpeningParens.bE.bk - 1, bz: rangeAfterOpeningParens.bE.bz }
                        }, $author$project$Elm$Syntax$Expression$ParenthesizedExpression(firstPart.d));
                    }
                    else {
                        var secondPart = _v25.a;
                        var maybeThirdPart = _v25.b;
                        return $author$project$Elm$Syntax$Node$Node_fn({
                            cm: rangeAfterOpeningParens.cm,
                            bE: { bk: rangeAfterOpeningParens.bE.bk - 1, bz: rangeAfterOpeningParens.bE.bz }
                        }, function () {
                            if (maybeThirdPart.$ === 1) {
                                return $author$project$Elm$Syntax$Expression$TupledExpression(_List_fromArray([firstPart.d, secondPart]));
                            }
                            else {
                                var thirdPart = maybeThirdPart.a;
                                return $author$project$Elm$Syntax$Expression$TupledExpression(_List_fromArray([firstPart.d, secondPart, thirdPart]));
                            }
                        }());
                    }
                }()
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$cyclic$expression(), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbol_fn(")", {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Parser$Expression$TupledParenthesized_fn(0, 0)
        }), $author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$ParserFast$map4_fn_unwrapped(function (commentsBefore, partResult, commentsAfter, maybeThirdPart) {
            return {
                e: $author$project$Rope$prependTo_fn(maybeThirdPart.e, $author$project$Rope$prependTo_fn(commentsAfter, $author$project$Rope$prependTo_fn(partResult.e, commentsBefore))),
                d: $author$project$Elm$Parser$Expression$TupledTwoOrThree_fn(partResult.d, maybeThirdPart.d)
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$cyclic$expression(), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbol_fn(")", { e: $author$project$Rope$empty, d: $elm$core$Maybe$Nothing }), $author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$ParserFast$followedBySymbol_fn(")", $author$project$ParserFast$map3_fn_unwrapped(function (commentsBefore, partResult, commentsAfter) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfter, $author$project$Rope$prependTo_fn(partResult.e, commentsBefore)),
                d: $elm$core$Maybe$Just(partResult.d)
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$cyclic$expression(), $author$project$Elm$Parser$Layout$maybeLayout)))))))));
    }
    function $author$project$Elm$Parser$Expression$cyclic$recordExpressionFollowedByRecordAccessMaybeApplied() {
        return $author$project$Elm$Parser$Expression$followedByMultiArgumentApplication($author$project$Elm$Parser$Expression$cyclic$recordExpressionFollowedByRecordAccess());
    }
    function $author$project$Elm$Parser$Expression$cyclic$recordExpressionFollowedByRecordAccess() {
        return $author$project$ParserFast$symbolFollowedBy_fn("{", $author$project$Elm$Parser$Expression$followedByMultiRecordAccess($author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, commentsBefore, afterCurly) {
            return {
                e: $author$project$Rope$prependTo_fn(afterCurly.e, commentsBefore),
                d: $author$project$Elm$Syntax$Node$Node_fn($author$project$Elm$Parser$Expression$rangeMoveStartLeftByOneColumn(range), afterCurly.d)
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$cyclic$recordContentsCurlyEnd())));
    }
    function $author$project$Elm$Parser$Expression$cyclic$recordContentsCurlyEnd() {
        return $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$map5_fn_unwrapped(function (nameNode, commentsAfterFunctionName, afterNameBeforeFields, tailFields, commentsBeforeClosingCurly) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsBeforeClosingCurly, $author$project$Rope$prependTo_fn(tailFields.e, $author$project$Rope$prependTo_fn(afterNameBeforeFields.e, commentsAfterFunctionName))),
                d: function () {
                    var _v24 = afterNameBeforeFields.d;
                    if (!_v24.$) {
                        var firstField = _v24.a;
                        return $author$project$Elm$Syntax$Expression$RecordUpdateExpression_fn(nameNode, _List_Cons(firstField, tailFields.d));
                    }
                    else {
                        var firstFieldValue = _v24.a;
                        return $author$project$Elm$Syntax$Expression$RecordExpr(_List_Cons($author$project$Elm$Syntax$Node$combine_fn($elm$core$Tuple$pair, nameNode, firstFieldValue), tailFields.d));
                    }
                }()
            };
        }, $author$project$Elm$Parser$Tokens$functionNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbolFollowedBy_fn("|", $author$project$ParserFast$map2_fn_unwrapped(function (commentsBefore, setterResult) {
            return {
                e: $author$project$Rope$prependTo_fn(setterResult.e, commentsBefore),
                d: $author$project$Elm$Parser$Expression$RecordUpdateFirstSetter(setterResult.d)
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$cyclic$recordSetterNodeWithLayout())), $author$project$ParserFast$symbolFollowedBy_fn("=", $author$project$ParserFast$map3_fn_unwrapped(function (commentsBefore, expressionResult, commentsAfter) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfter, $author$project$Rope$prependTo_fn(expressionResult.e, commentsBefore)),
                d: $author$project$Elm$Parser$Expression$FieldsFirstValue(expressionResult.d)
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$cyclic$expression(), $author$project$Elm$Parser$Layout$maybeLayout))), $author$project$Elm$Parser$Expression$cyclic$recordFields(), $author$project$ParserFast$followedBySymbol_fn("}", $author$project$Elm$Parser$Layout$maybeLayout)), $author$project$ParserFast$symbol_fn("}", {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Expression$RecordExpr(_List_Nil)
        }));
    }
    function $author$project$Elm$Parser$Expression$cyclic$recordFields() {
        return $author$project$ParserWithComments$many($author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$ParserFast$map2_fn_unwrapped(function (commentsBefore, setterResult) {
            return {
                e: $author$project$Rope$prependTo_fn(setterResult.e, commentsBefore),
                d: setterResult.d
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$cyclic$recordSetterNodeWithLayout())));
    }
    function $author$project$Elm$Parser$Expression$cyclic$recordSetterNodeWithLayout() {
        return $author$project$ParserFast$map5WithRange_fn_unwrapped(function (range, name, commentsAfterFunctionName, commentsAfterEquals, expressionResult, commentsAfterExpression) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfterExpression, $author$project$Rope$prependTo_fn(expressionResult.e, $author$project$Rope$prependTo_fn(commentsAfterEquals, commentsAfterFunctionName))),
                d: $author$project$Elm$Syntax$Node$Node_fn(range, _Utils_Tuple2(name, expressionResult.d))
            };
        }, $author$project$Elm$Parser$Tokens$functionNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$symbolFollowedBy_fn("=", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Expression$cyclic$expression(), $author$project$Elm$Parser$Layout$maybeLayout);
    }
    function $author$project$Elm$Parser$Expression$cyclic$letFunction() {
        return $author$project$ParserFast$validate_fn(function (result) {
            var _v17 = result.d;
            var letDeclaration = _v17.b;
            if (letDeclaration.$ === 1) {
                return true;
            }
            else {
                var letFunctionDeclaration = letDeclaration.a;
                var _v19 = letFunctionDeclaration.am;
                if (_v19.$ === 1) {
                    return true;
                }
                else {
                    var _v20 = _v19.a;
                    var signature = _v20.b;
                    var _v21 = signature.q;
                    var signatureName = _v21.b;
                    var _v22 = letFunctionDeclaration.aG;
                    var implementation = _v22.b;
                    var _v23 = implementation.q;
                    var implementationName = _v23.b;
                    return _Utils_eq(implementationName, signatureName + "");
                }
            }
        }, "Expected to find the same name for declaration and signature", $author$project$ParserFast$map6WithStartLocation_fn_unwrapped(function (startNameStart, startNameNode, commentsAfterStartName, maybeSignature, _arguments, commentsAfterEqual, expressionResult) {
            var allComments = $author$project$Rope$prependTo_fn(expressionResult.e, $author$project$Rope$prependTo_fn(commentsAfterEqual, $author$project$Rope$prependTo_fn(_arguments.e, function () {
                if (maybeSignature.$ === 1) {
                    return commentsAfterStartName;
                }
                else {
                    var signature = maybeSignature.a;
                    return $author$project$Rope$prependTo_fn(signature.e, commentsAfterStartName);
                }
            }())));
            if (maybeSignature.$ === 1) {
                var _v13 = expressionResult.d;
                var expressionRange = _v13.a;
                return {
                    e: allComments,
                    d: $author$project$Elm$Syntax$Node$Node_fn({ cm: expressionRange.cm, bE: startNameStart }, $author$project$Elm$Syntax$Expression$LetFunction({
                        aG: $author$project$Elm$Syntax$Node$Node_fn({ cm: expressionRange.cm, bE: startNameStart }, { _: _arguments.d, V: expressionResult.d, q: startNameNode }),
                        ab: $elm$core$Maybe$Nothing,
                        am: $elm$core$Maybe$Nothing
                    }))
                };
            }
            else {
                var signature = maybeSignature.a;
                var _v14 = signature.aM;
                var implementationNameRange = _v14.a;
                var _v15 = expressionResult.d;
                var expressionRange = _v15.a;
                return {
                    e: allComments,
                    d: $author$project$Elm$Syntax$Node$Node_fn({ cm: expressionRange.cm, bE: startNameStart }, $author$project$Elm$Syntax$Expression$LetFunction({
                        aG: $author$project$Elm$Syntax$Node$Node_fn({ cm: expressionRange.cm, bE: implementationNameRange.bE }, { _: _arguments.d, V: expressionResult.d, q: signature.aM }),
                        ab: $elm$core$Maybe$Nothing,
                        am: $elm$core$Maybe$Just($author$project$Elm$Syntax$Node$combine_fn($author$project$Elm$Syntax$Signature$Signature, startNameNode, signature.y))
                    }))
                };
            }
        }, $author$project$Elm$Parser$Tokens$functionNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$map4OrSucceed_fn_unwrapped(function (commentsBeforeTypeAnnotation, typeAnnotationResult, implementationName, afterImplementationName) {
            return $elm$core$Maybe$Just({
                e: $author$project$Rope$prependTo_fn(afterImplementationName, $author$project$Rope$prependTo_fn(implementationName.e, $author$project$Rope$prependTo_fn(typeAnnotationResult.e, commentsBeforeTypeAnnotation))),
                aM: implementationName.d,
                y: typeAnnotationResult.d
            });
        }, $author$project$ParserFast$symbolFollowedBy_fn(":", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$TypeAnnotation$typeAnnotation, $author$project$Elm$Parser$Layout$layoutStrictFollowedBy($author$project$Elm$Parser$Tokens$functionNameNode), $author$project$Elm$Parser$Layout$maybeLayout, $elm$core$Maybe$Nothing), $author$project$Elm$Parser$Expression$parameterPatternsEqual, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$cyclic$expression()));
    }
    function $author$project$Elm$Parser$Expression$cyclic$letDestructuringDeclaration() {
        return $author$project$ParserFast$map4_fn_unwrapped(function (pattern, commentsAfterPattern, commentsAfterEquals, expressionResult) {
            var _v10 = pattern.d;
            var start = _v10.a.bE;
            var _v11 = expressionResult.d;
            var end = _v11.a.cm;
            return {
                e: $author$project$Rope$prependTo_fn(expressionResult.e, $author$project$Rope$prependTo_fn(commentsAfterEquals, $author$project$Rope$prependTo_fn(commentsAfterPattern, pattern.e))),
                d: $author$project$Elm$Syntax$Node$Node_fn({ cm: end, bE: start }, $author$project$Elm$Syntax$Expression$LetDestructuring_fn(pattern.d, expressionResult.d))
            };
        }, $author$project$Elm$Parser$Patterns$patternNotDirectlyComposing, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$symbolFollowedBy_fn("=", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Expression$cyclic$expression());
    }
    function $author$project$Elm$Parser$Expression$cyclic$lambdaExpressionOptimisticLayout() {
        return $author$project$Elm$Parser$Expression$followedByOptimisticLayout($author$project$Elm$Parser$Expression$cyclic$lambdaExpression());
    }
    function $author$project$Elm$Parser$Expression$cyclic$lambdaExpression() {
        return $author$project$ParserFast$symbolFollowedBy_fn("\\", $author$project$ParserFast$map6WithStartLocation_fn_unwrapped(function (start, commentsAfterBackslash, firstArg, commentsAfterFirstArg, secondUpArgs, commentsAfterArrow, expressionResult) {
            var _v9 = expressionResult.d;
            var expressionRange = _v9.a;
            return {
                e: $author$project$Rope$prependTo_fn(expressionResult.e, $author$project$Rope$prependTo_fn(commentsAfterArrow, $author$project$Rope$prependTo_fn(secondUpArgs.e, $author$project$Rope$prependTo_fn(commentsAfterFirstArg, $author$project$Rope$prependTo_fn(firstArg.e, commentsAfterBackslash))))),
                d: $author$project$Elm$Syntax$Node$Node_fn({
                    cm: expressionRange.cm,
                    bE: { bk: start.bk - 1, bz: start.bz }
                }, $author$project$Elm$Syntax$Expression$LambdaExpression({
                    dB: _List_Cons(firstArg.d, secondUpArgs.d),
                    V: expressionResult.d
                }))
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Patterns$patternNotDirectlyComposing, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserWithComments$until_fn($author$project$ParserFast$symbol_fn("->", 0), $author$project$ParserFast$map2_fn_unwrapped(function (patternResult, commentsAfter) {
            return {
                e: $author$project$Rope$prependTo_fn(commentsAfter, patternResult.e),
                d: patternResult.d
            };
        }, $author$project$Elm$Parser$Patterns$patternNotDirectlyComposing, $author$project$Elm$Parser$Layout$maybeLayout)), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$cyclic$expression()));
    }
    function $author$project$Elm$Parser$Expression$cyclic$ifOrUnqualifiedReferenceExpressionMaybeApplied() {
        return $author$project$ParserFast$oneOf2_fn($author$project$Elm$Parser$Expression$followedByOptimisticLayout($author$project$Elm$Parser$Expression$cyclic$ifBlockExpression()), $author$project$Elm$Parser$Expression$followedByMultiArgumentApplication($author$project$Elm$Parser$Expression$unqualifiedFunctionReferenceExpressionFollowedByRecordAccess));
    }
    function $author$project$Elm$Parser$Expression$cyclic$ifOrUnqualifiedReferenceExpression() {
        return $author$project$ParserFast$oneOf2_fn($author$project$Elm$Parser$Expression$cyclic$ifBlockExpression(), $author$project$Elm$Parser$Expression$unqualifiedFunctionReferenceExpressionFollowedByRecordAccess);
    }
    function $author$project$Elm$Parser$Expression$cyclic$ifBlockExpression() {
        return $author$project$ParserFast$keywordFollowedBy_fn("if", $author$project$ParserFast$map8WithStartLocation_fn_unwrapped(function (start, commentsAfterIf, condition, commentsBeforeThen, commentsAfterThen, ifTrue, commentsBeforeElse, commentsAfterElse, ifFalse) {
            var _v8 = ifFalse.d;
            var ifFalseRange = _v8.a;
            return {
                e: $author$project$Rope$prependTo_fn(ifFalse.e, $author$project$Rope$prependTo_fn(commentsAfterElse, $author$project$Rope$prependTo_fn(commentsBeforeElse, $author$project$Rope$prependTo_fn(ifTrue.e, $author$project$Rope$prependTo_fn(commentsAfterThen, $author$project$Rope$prependTo_fn(commentsBeforeThen, $author$project$Rope$prependTo_fn(condition.e, commentsAfterIf))))))),
                d: $author$project$Elm$Syntax$Node$Node_fn({
                    cm: ifFalseRange.cm,
                    bE: { bk: start.bk - 2, bz: start.bz }
                }, $author$project$Elm$Syntax$Expression$IfBlock_fn(condition.d, ifTrue.d, ifFalse.d))
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$cyclic$expression(), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$keywordFollowedBy_fn("then", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Expression$cyclic$expression(), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$keywordFollowedBy_fn("else", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Expression$cyclic$expression()));
    }
    function $author$project$Elm$Parser$Expression$cyclic$listOrGlslExpressionOptimisticLayout() {
        return $author$project$Elm$Parser$Expression$followedByOptimisticLayout($author$project$Elm$Parser$Expression$cyclic$listOrGlslExpression());
    }
    function $author$project$Elm$Parser$Expression$cyclic$listOrGlslExpression() {
        return $author$project$ParserFast$symbolFollowedBy_fn("[", $author$project$Elm$Parser$Expression$cyclic$expressionAfterOpeningSquareBracket());
    }
    function $author$project$Elm$Parser$Expression$cyclic$expressionAfterOpeningSquareBracket() {
        return $author$project$ParserFast$oneOf2_fn($author$project$Elm$Parser$Expression$glslExpressionAfterOpeningSquareBracket, $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, commentsBefore, elements) {
            return {
                e: $author$project$Rope$prependTo_fn(elements.e, commentsBefore),
                d: $author$project$Elm$Syntax$Node$Node_fn({
                    cm: range.cm,
                    bE: { bk: range.bE.bk - 1, bz: range.bE.bz }
                }, elements.d)
            };
        }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$symbol_fn("]", {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Expression$ListExpr(_List_Nil)
        }), $author$project$ParserFast$followedBySymbol_fn("]", $author$project$ParserFast$map3_fn_unwrapped(function (head, commentsAfterHead, tail) {
            return {
                e: $author$project$Rope$prependTo_fn(tail.e, $author$project$Rope$prependTo_fn(commentsAfterHead, head.e)),
                d: $author$project$Elm$Syntax$Expression$ListExpr(_List_Cons(head.d, tail.d))
            };
        }, $author$project$Elm$Parser$Expression$cyclic$expression(), $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserWithComments$many($author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$Elm$Parser$Layout$maybeAroundBothSides($author$project$Elm$Parser$Expression$cyclic$expression()))))))));
    }
    function $author$project$Elm$Parser$Expression$cyclic$expression() {
        return $author$project$Elm$Parser$Expression$extendedSubExpressionOptimisticLayout({
            a_: function ($) {
                return $.ac;
            },
            bf: $elm$core$Result$Ok
        });
    }
    function $author$project$Elm$Parser$Expression$cyclic$referenceOrNumberExpressionMaybeApplied() {
        return $author$project$ParserFast$oneOf3_fn($author$project$Elm$Parser$Expression$followedByMultiArgumentApplication($author$project$Elm$Parser$Expression$qualifiedOrVariantOrRecordConstructorReferenceExpressionFollowedByRecordAccess), $author$project$Elm$Parser$Expression$followedByMultiArgumentApplication($author$project$Elm$Parser$Expression$unqualifiedFunctionReferenceExpressionFollowedByRecordAccess), $author$project$Elm$Parser$Expression$followedByOptimisticLayout($author$project$Elm$Parser$Expression$numberExpression));
    }
    function $author$project$Elm$Parser$Expression$cyclic$recordAccessFunctionExpressionMaybeApplied() {
        return $author$project$Elm$Parser$Expression$followedByMultiArgumentApplication($author$project$Elm$Parser$Expression$recordAccessFunctionExpression);
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence9ComposeL() {
        return $author$project$Elm$Parser$Expression$infixLeft_fn(9, "<<");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence8QuestionMark() {
        return $author$project$Elm$Parser$Expression$infixLeft_fn(8, "<?>");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence7Mul() {
        return $author$project$Elm$Parser$Expression$infixLeft_fn(7, "*");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence7Idiv() {
        return $author$project$Elm$Parser$Expression$infixLeft_fn(7, "//");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence7Fdiv() {
        return $author$project$Elm$Parser$Expression$infixLeft_fn(7, "/");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence6Sub() {
        return $author$project$Elm$Parser$Expression$infixLeft_fn(6, "-");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence6Ignore() {
        return $author$project$Elm$Parser$Expression$infixLeft_fn(6, "|.");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence6Add() {
        return $author$project$Elm$Parser$Expression$infixLeft_fn(6, "+");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence5Keep() {
        return $author$project$Elm$Parser$Expression$infixLeft_fn(5, "|=");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence1ApR() {
        return $author$project$Elm$Parser$Expression$infixLeft_fn(1, "|>");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence4Neq() {
        return $author$project$Elm$Parser$Expression$infixNonAssociative_fn(4, "/=");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence4Lt() {
        return $author$project$Elm$Parser$Expression$infixNonAssociative_fn(4, "<");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence4Le() {
        return $author$project$Elm$Parser$Expression$infixNonAssociative_fn(4, "<=");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence4Gt() {
        return $author$project$Elm$Parser$Expression$infixNonAssociative_fn(4, ">");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence4Ge() {
        return $author$project$Elm$Parser$Expression$infixNonAssociative_fn(4, ">=");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence4Eq() {
        return $author$project$Elm$Parser$Expression$infixNonAssociative_fn(4, "==");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence9ComposeR() {
        return $author$project$Elm$Parser$Expression$infixRight_fn(9, ">>");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence8Pow() {
        return $author$project$Elm$Parser$Expression$infixRight_fn(8, "^");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence7Slash() {
        return $author$project$Elm$Parser$Expression$infixRight_fn(7, "</>");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence5append() {
        return $author$project$Elm$Parser$Expression$infixRight_fn(5, "++");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence5Cons() {
        return $author$project$Elm$Parser$Expression$infixRight_fn(5, "::");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence3And() {
        return $author$project$Elm$Parser$Expression$infixRight_fn(3, "&&");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence2Or() {
        return $author$project$Elm$Parser$Expression$infixRight_fn(2, "||");
    }
    function $author$project$Elm$Parser$Expression$cyclic$precedence1ApL() {
        return $author$project$Elm$Parser$Expression$infixRight_fn(1, "<|");
    }
    function $author$project$Elm$Parser$Expression$cyclic$negationAfterMinus() {
        return $author$project$ParserFast$map_fn(function (subExpressionResult) {
            var _v3 = subExpressionResult.d;
            var subExpressionRange = _v3.a;
            return {
                e: subExpressionResult.e,
                d: $author$project$Elm$Syntax$Node$Node_fn({
                    cm: subExpressionRange.cm,
                    bE: { bk: subExpressionRange.bE.bk - 1, bz: subExpressionRange.bE.bz }
                }, $author$project$Elm$Syntax$Expression$Negation(subExpressionResult.d))
            };
        }, $author$project$Elm$Parser$Expression$cyclic$subExpression());
    }
    function $author$project$Elm$Parser$Expression$cyclic$negationOperationOptimisticLayout() {
        return $author$project$Elm$Parser$Expression$followedByOptimisticLayout($author$project$Elm$Parser$Expression$cyclic$negationOperation());
    }
    function $author$project$Elm$Parser$Expression$cyclic$negationOperation() {
        return $author$project$ParserFast$symbolBacktrackableFollowedBy_fn("-", $author$project$ParserFast$offsetSourceAndThen_unwrapped(function (offset, source) {
            var _v2 = _String_slice_fn(offset - 2, offset - 1, source);
            switch (_v2) {
                case " ":
                    return $author$project$Elm$Parser$Expression$cyclic$negationAfterMinus();
                case "(":
                    return $author$project$Elm$Parser$Expression$cyclic$negationAfterMinus();
                case ")":
                    return $author$project$Elm$Parser$Expression$cyclic$negationAfterMinus();
                case "}":
                    return $author$project$Elm$Parser$Expression$cyclic$negationAfterMinus();
                case "":
                    return $author$project$Elm$Parser$Expression$cyclic$negationAfterMinus();
                default:
                    return $author$project$Elm$Parser$Expression$negationWhitespaceProblem;
            }
        }));
    }
    function $author$project$Elm$Parser$Expression$cyclic$subExpression() {
        return $author$project$ParserFast$offsetSourceAndThen_unwrapped(function (offset, source) {
            var _v1 = _String_slice_fn(offset, offset + 1, source);
            switch (_v1) {
                case "\"":
                    return $author$project$Elm$Parser$Expression$literalExpression;
                case "(":
                    return $author$project$Elm$Parser$Expression$cyclic$tupledExpressionIfNecessaryFollowedByRecordAccess();
                case "[":
                    return $author$project$Elm$Parser$Expression$cyclic$listOrGlslExpression();
                case "{":
                    return $author$project$Elm$Parser$Expression$cyclic$recordExpressionFollowedByRecordAccess();
                case "c":
                    return $author$project$Elm$Parser$Expression$cyclic$caseOrUnqualifiedReferenceExpression();
                case "\\":
                    return $author$project$Elm$Parser$Expression$cyclic$lambdaExpression();
                case "l":
                    return $author$project$Elm$Parser$Expression$cyclic$letOrUnqualifiedReferenceExpression();
                case "i":
                    return $author$project$Elm$Parser$Expression$cyclic$ifOrUnqualifiedReferenceExpression();
                case ".":
                    return $author$project$Elm$Parser$Expression$recordAccessFunctionExpression;
                case "-":
                    return $author$project$Elm$Parser$Expression$cyclic$negationOperation();
                case "'":
                    return $author$project$Elm$Parser$Expression$charLiteralExpression;
                default:
                    return $author$project$Elm$Parser$Expression$referenceOrNumberExpression;
            }
        });
    }
    function $author$project$Elm$Parser$Expression$cyclic$subExpressionMaybeAppliedOptimisticLayout() {
        return $author$project$ParserFast$offsetSourceAndThen_unwrapped(function (offset, source) {
            var _v0 = _String_slice_fn(offset, offset + 1, source);
            switch (_v0) {
                case "\"":
                    return $author$project$Elm$Parser$Expression$literalExpressionOptimisticLayout;
                case "(":
                    return $author$project$Elm$Parser$Expression$cyclic$tupledExpressionIfNecessaryFollowedByRecordAccessMaybeApplied();
                case "[":
                    return $author$project$Elm$Parser$Expression$cyclic$listOrGlslExpressionOptimisticLayout();
                case "{":
                    return $author$project$Elm$Parser$Expression$cyclic$recordExpressionFollowedByRecordAccessMaybeApplied();
                case "c":
                    return $author$project$Elm$Parser$Expression$cyclic$caseOrUnqualifiedReferenceExpressionMaybeApplied();
                case "\\":
                    return $author$project$Elm$Parser$Expression$cyclic$lambdaExpressionOptimisticLayout();
                case "l":
                    return $author$project$Elm$Parser$Expression$cyclic$letOrUnqualifiedReferenceExpressionMaybeApplied();
                case "i":
                    return $author$project$Elm$Parser$Expression$cyclic$ifOrUnqualifiedReferenceExpressionMaybeApplied();
                case ".":
                    return $author$project$Elm$Parser$Expression$cyclic$recordAccessFunctionExpressionMaybeApplied();
                case "-":
                    return $author$project$Elm$Parser$Expression$cyclic$negationOperationOptimisticLayout();
                case "'":
                    return $author$project$Elm$Parser$Expression$charLiteralExpressionOptimisticLayout;
                default:
                    return $author$project$Elm$Parser$Expression$cyclic$referenceOrNumberExpressionMaybeApplied();
            }
        });
    }
    var $author$project$Elm$Parser$Expression$letOrUnqualifiedReferenceExpressionMaybeApplied = $author$project$Elm$Parser$Expression$cyclic$letOrUnqualifiedReferenceExpressionMaybeApplied();
    $author$project$Elm$Parser$Expression$cyclic$letOrUnqualifiedReferenceExpressionMaybeApplied = function () {
        return $author$project$Elm$Parser$Expression$letOrUnqualifiedReferenceExpressionMaybeApplied;
    };
    var $author$project$Elm$Parser$Expression$letOrUnqualifiedReferenceExpression = $author$project$Elm$Parser$Expression$cyclic$letOrUnqualifiedReferenceExpression();
    $author$project$Elm$Parser$Expression$cyclic$letOrUnqualifiedReferenceExpression = function () {
        return $author$project$Elm$Parser$Expression$letOrUnqualifiedReferenceExpression;
    };
    var $author$project$Elm$Parser$Expression$letExpression = $author$project$Elm$Parser$Expression$cyclic$letExpression();
    $author$project$Elm$Parser$Expression$cyclic$letExpression = function () {
        return $author$project$Elm$Parser$Expression$letExpression;
    };
    var $author$project$Elm$Parser$Expression$letDeclarationsIn = $author$project$Elm$Parser$Expression$cyclic$letDeclarationsIn();
    $author$project$Elm$Parser$Expression$cyclic$letDeclarationsIn = function () {
        return $author$project$Elm$Parser$Expression$letDeclarationsIn;
    };
    var $author$project$Elm$Parser$Expression$blockElement = $author$project$Elm$Parser$Expression$cyclic$blockElement();
    $author$project$Elm$Parser$Expression$cyclic$blockElement = function () {
        return $author$project$Elm$Parser$Expression$blockElement;
    };
    var $author$project$Elm$Parser$Expression$caseOrUnqualifiedReferenceExpressionMaybeApplied = $author$project$Elm$Parser$Expression$cyclic$caseOrUnqualifiedReferenceExpressionMaybeApplied();
    $author$project$Elm$Parser$Expression$cyclic$caseOrUnqualifiedReferenceExpressionMaybeApplied = function () {
        return $author$project$Elm$Parser$Expression$caseOrUnqualifiedReferenceExpressionMaybeApplied;
    };
    var $author$project$Elm$Parser$Expression$caseOrUnqualifiedReferenceExpression = $author$project$Elm$Parser$Expression$cyclic$caseOrUnqualifiedReferenceExpression();
    $author$project$Elm$Parser$Expression$cyclic$caseOrUnqualifiedReferenceExpression = function () {
        return $author$project$Elm$Parser$Expression$caseOrUnqualifiedReferenceExpression;
    };
    var $author$project$Elm$Parser$Expression$caseExpression = $author$project$Elm$Parser$Expression$cyclic$caseExpression();
    $author$project$Elm$Parser$Expression$cyclic$caseExpression = function () {
        return $author$project$Elm$Parser$Expression$caseExpression;
    };
    var $author$project$Elm$Parser$Expression$caseStatements = $author$project$Elm$Parser$Expression$cyclic$caseStatements();
    $author$project$Elm$Parser$Expression$cyclic$caseStatements = function () {
        return $author$project$Elm$Parser$Expression$caseStatements;
    };
    var $author$project$Elm$Parser$Expression$caseStatement = $author$project$Elm$Parser$Expression$cyclic$caseStatement();
    $author$project$Elm$Parser$Expression$cyclic$caseStatement = function () {
        return $author$project$Elm$Parser$Expression$caseStatement;
    };
    var $author$project$Elm$Parser$Expression$tupledExpressionIfNecessaryFollowedByRecordAccessMaybeApplied = $author$project$Elm$Parser$Expression$cyclic$tupledExpressionIfNecessaryFollowedByRecordAccessMaybeApplied();
    $author$project$Elm$Parser$Expression$cyclic$tupledExpressionIfNecessaryFollowedByRecordAccessMaybeApplied = function () {
        return $author$project$Elm$Parser$Expression$tupledExpressionIfNecessaryFollowedByRecordAccessMaybeApplied;
    };
    var $author$project$Elm$Parser$Expression$tupledExpressionIfNecessaryFollowedByRecordAccess = $author$project$Elm$Parser$Expression$cyclic$tupledExpressionIfNecessaryFollowedByRecordAccess();
    $author$project$Elm$Parser$Expression$cyclic$tupledExpressionIfNecessaryFollowedByRecordAccess = function () {
        return $author$project$Elm$Parser$Expression$tupledExpressionIfNecessaryFollowedByRecordAccess;
    };
    var $author$project$Elm$Parser$Expression$tupledExpressionInnerAfterOpeningParens = $author$project$Elm$Parser$Expression$cyclic$tupledExpressionInnerAfterOpeningParens();
    $author$project$Elm$Parser$Expression$cyclic$tupledExpressionInnerAfterOpeningParens = function () {
        return $author$project$Elm$Parser$Expression$tupledExpressionInnerAfterOpeningParens;
    };
    var $author$project$Elm$Parser$Expression$recordExpressionFollowedByRecordAccessMaybeApplied = $author$project$Elm$Parser$Expression$cyclic$recordExpressionFollowedByRecordAccessMaybeApplied();
    $author$project$Elm$Parser$Expression$cyclic$recordExpressionFollowedByRecordAccessMaybeApplied = function () {
        return $author$project$Elm$Parser$Expression$recordExpressionFollowedByRecordAccessMaybeApplied;
    };
    var $author$project$Elm$Parser$Expression$recordExpressionFollowedByRecordAccess = $author$project$Elm$Parser$Expression$cyclic$recordExpressionFollowedByRecordAccess();
    $author$project$Elm$Parser$Expression$cyclic$recordExpressionFollowedByRecordAccess = function () {
        return $author$project$Elm$Parser$Expression$recordExpressionFollowedByRecordAccess;
    };
    var $author$project$Elm$Parser$Expression$recordContentsCurlyEnd = $author$project$Elm$Parser$Expression$cyclic$recordContentsCurlyEnd();
    $author$project$Elm$Parser$Expression$cyclic$recordContentsCurlyEnd = function () {
        return $author$project$Elm$Parser$Expression$recordContentsCurlyEnd;
    };
    var $author$project$Elm$Parser$Expression$recordFields = $author$project$Elm$Parser$Expression$cyclic$recordFields();
    $author$project$Elm$Parser$Expression$cyclic$recordFields = function () {
        return $author$project$Elm$Parser$Expression$recordFields;
    };
    var $author$project$Elm$Parser$Expression$recordSetterNodeWithLayout = $author$project$Elm$Parser$Expression$cyclic$recordSetterNodeWithLayout();
    $author$project$Elm$Parser$Expression$cyclic$recordSetterNodeWithLayout = function () {
        return $author$project$Elm$Parser$Expression$recordSetterNodeWithLayout;
    };
    var $author$project$Elm$Parser$Expression$letFunction = $author$project$Elm$Parser$Expression$cyclic$letFunction();
    $author$project$Elm$Parser$Expression$cyclic$letFunction = function () {
        return $author$project$Elm$Parser$Expression$letFunction;
    };
    var $author$project$Elm$Parser$Expression$letDestructuringDeclaration = $author$project$Elm$Parser$Expression$cyclic$letDestructuringDeclaration();
    $author$project$Elm$Parser$Expression$cyclic$letDestructuringDeclaration = function () {
        return $author$project$Elm$Parser$Expression$letDestructuringDeclaration;
    };
    var $author$project$Elm$Parser$Expression$lambdaExpressionOptimisticLayout = $author$project$Elm$Parser$Expression$cyclic$lambdaExpressionOptimisticLayout();
    $author$project$Elm$Parser$Expression$cyclic$lambdaExpressionOptimisticLayout = function () {
        return $author$project$Elm$Parser$Expression$lambdaExpressionOptimisticLayout;
    };
    var $author$project$Elm$Parser$Expression$lambdaExpression = $author$project$Elm$Parser$Expression$cyclic$lambdaExpression();
    $author$project$Elm$Parser$Expression$cyclic$lambdaExpression = function () {
        return $author$project$Elm$Parser$Expression$lambdaExpression;
    };
    var $author$project$Elm$Parser$Expression$ifOrUnqualifiedReferenceExpressionMaybeApplied = $author$project$Elm$Parser$Expression$cyclic$ifOrUnqualifiedReferenceExpressionMaybeApplied();
    $author$project$Elm$Parser$Expression$cyclic$ifOrUnqualifiedReferenceExpressionMaybeApplied = function () {
        return $author$project$Elm$Parser$Expression$ifOrUnqualifiedReferenceExpressionMaybeApplied;
    };
    var $author$project$Elm$Parser$Expression$ifOrUnqualifiedReferenceExpression = $author$project$Elm$Parser$Expression$cyclic$ifOrUnqualifiedReferenceExpression();
    $author$project$Elm$Parser$Expression$cyclic$ifOrUnqualifiedReferenceExpression = function () {
        return $author$project$Elm$Parser$Expression$ifOrUnqualifiedReferenceExpression;
    };
    var $author$project$Elm$Parser$Expression$ifBlockExpression = $author$project$Elm$Parser$Expression$cyclic$ifBlockExpression();
    $author$project$Elm$Parser$Expression$cyclic$ifBlockExpression = function () {
        return $author$project$Elm$Parser$Expression$ifBlockExpression;
    };
    var $author$project$Elm$Parser$Expression$listOrGlslExpressionOptimisticLayout = $author$project$Elm$Parser$Expression$cyclic$listOrGlslExpressionOptimisticLayout();
    $author$project$Elm$Parser$Expression$cyclic$listOrGlslExpressionOptimisticLayout = function () {
        return $author$project$Elm$Parser$Expression$listOrGlslExpressionOptimisticLayout;
    };
    var $author$project$Elm$Parser$Expression$listOrGlslExpression = $author$project$Elm$Parser$Expression$cyclic$listOrGlslExpression();
    $author$project$Elm$Parser$Expression$cyclic$listOrGlslExpression = function () {
        return $author$project$Elm$Parser$Expression$listOrGlslExpression;
    };
    var $author$project$Elm$Parser$Expression$expressionAfterOpeningSquareBracket = $author$project$Elm$Parser$Expression$cyclic$expressionAfterOpeningSquareBracket();
    $author$project$Elm$Parser$Expression$cyclic$expressionAfterOpeningSquareBracket = function () {
        return $author$project$Elm$Parser$Expression$expressionAfterOpeningSquareBracket;
    };
    var $author$project$Elm$Parser$Expression$expression = $author$project$Elm$Parser$Expression$cyclic$expression();
    $author$project$Elm$Parser$Expression$cyclic$expression = function () {
        return $author$project$Elm$Parser$Expression$expression;
    };
    var $author$project$Elm$Parser$Expression$referenceOrNumberExpressionMaybeApplied = $author$project$Elm$Parser$Expression$cyclic$referenceOrNumberExpressionMaybeApplied();
    $author$project$Elm$Parser$Expression$cyclic$referenceOrNumberExpressionMaybeApplied = function () {
        return $author$project$Elm$Parser$Expression$referenceOrNumberExpressionMaybeApplied;
    };
    var $author$project$Elm$Parser$Expression$recordAccessFunctionExpressionMaybeApplied = $author$project$Elm$Parser$Expression$cyclic$recordAccessFunctionExpressionMaybeApplied();
    $author$project$Elm$Parser$Expression$cyclic$recordAccessFunctionExpressionMaybeApplied = function () {
        return $author$project$Elm$Parser$Expression$recordAccessFunctionExpressionMaybeApplied;
    };
    var $author$project$Elm$Parser$Expression$precedence9ComposeL = $author$project$Elm$Parser$Expression$cyclic$precedence9ComposeL();
    $author$project$Elm$Parser$Expression$cyclic$precedence9ComposeL = function () {
        return $author$project$Elm$Parser$Expression$precedence9ComposeL;
    };
    var $author$project$Elm$Parser$Expression$precedence8QuestionMark = $author$project$Elm$Parser$Expression$cyclic$precedence8QuestionMark();
    $author$project$Elm$Parser$Expression$cyclic$precedence8QuestionMark = function () {
        return $author$project$Elm$Parser$Expression$precedence8QuestionMark;
    };
    var $author$project$Elm$Parser$Expression$precedence7Mul = $author$project$Elm$Parser$Expression$cyclic$precedence7Mul();
    $author$project$Elm$Parser$Expression$cyclic$precedence7Mul = function () {
        return $author$project$Elm$Parser$Expression$precedence7Mul;
    };
    var $author$project$Elm$Parser$Expression$precedence7Idiv = $author$project$Elm$Parser$Expression$cyclic$precedence7Idiv();
    $author$project$Elm$Parser$Expression$cyclic$precedence7Idiv = function () {
        return $author$project$Elm$Parser$Expression$precedence7Idiv;
    };
    var $author$project$Elm$Parser$Expression$precedence7Fdiv = $author$project$Elm$Parser$Expression$cyclic$precedence7Fdiv();
    $author$project$Elm$Parser$Expression$cyclic$precedence7Fdiv = function () {
        return $author$project$Elm$Parser$Expression$precedence7Fdiv;
    };
    var $author$project$Elm$Parser$Expression$precedence6Sub = $author$project$Elm$Parser$Expression$cyclic$precedence6Sub();
    $author$project$Elm$Parser$Expression$cyclic$precedence6Sub = function () {
        return $author$project$Elm$Parser$Expression$precedence6Sub;
    };
    var $author$project$Elm$Parser$Expression$precedence6Ignore = $author$project$Elm$Parser$Expression$cyclic$precedence6Ignore();
    $author$project$Elm$Parser$Expression$cyclic$precedence6Ignore = function () {
        return $author$project$Elm$Parser$Expression$precedence6Ignore;
    };
    var $author$project$Elm$Parser$Expression$precedence6Add = $author$project$Elm$Parser$Expression$cyclic$precedence6Add();
    $author$project$Elm$Parser$Expression$cyclic$precedence6Add = function () {
        return $author$project$Elm$Parser$Expression$precedence6Add;
    };
    var $author$project$Elm$Parser$Expression$precedence5Keep = $author$project$Elm$Parser$Expression$cyclic$precedence5Keep();
    $author$project$Elm$Parser$Expression$cyclic$precedence5Keep = function () {
        return $author$project$Elm$Parser$Expression$precedence5Keep;
    };
    var $author$project$Elm$Parser$Expression$precedence1ApR = $author$project$Elm$Parser$Expression$cyclic$precedence1ApR();
    $author$project$Elm$Parser$Expression$cyclic$precedence1ApR = function () {
        return $author$project$Elm$Parser$Expression$precedence1ApR;
    };
    var $author$project$Elm$Parser$Expression$precedence4Neq = $author$project$Elm$Parser$Expression$cyclic$precedence4Neq();
    $author$project$Elm$Parser$Expression$cyclic$precedence4Neq = function () {
        return $author$project$Elm$Parser$Expression$precedence4Neq;
    };
    var $author$project$Elm$Parser$Expression$precedence4Lt = $author$project$Elm$Parser$Expression$cyclic$precedence4Lt();
    $author$project$Elm$Parser$Expression$cyclic$precedence4Lt = function () {
        return $author$project$Elm$Parser$Expression$precedence4Lt;
    };
    var $author$project$Elm$Parser$Expression$precedence4Le = $author$project$Elm$Parser$Expression$cyclic$precedence4Le();
    $author$project$Elm$Parser$Expression$cyclic$precedence4Le = function () {
        return $author$project$Elm$Parser$Expression$precedence4Le;
    };
    var $author$project$Elm$Parser$Expression$precedence4Gt = $author$project$Elm$Parser$Expression$cyclic$precedence4Gt();
    $author$project$Elm$Parser$Expression$cyclic$precedence4Gt = function () {
        return $author$project$Elm$Parser$Expression$precedence4Gt;
    };
    var $author$project$Elm$Parser$Expression$precedence4Ge = $author$project$Elm$Parser$Expression$cyclic$precedence4Ge();
    $author$project$Elm$Parser$Expression$cyclic$precedence4Ge = function () {
        return $author$project$Elm$Parser$Expression$precedence4Ge;
    };
    var $author$project$Elm$Parser$Expression$precedence4Eq = $author$project$Elm$Parser$Expression$cyclic$precedence4Eq();
    $author$project$Elm$Parser$Expression$cyclic$precedence4Eq = function () {
        return $author$project$Elm$Parser$Expression$precedence4Eq;
    };
    var $author$project$Elm$Parser$Expression$precedence9ComposeR = $author$project$Elm$Parser$Expression$cyclic$precedence9ComposeR();
    $author$project$Elm$Parser$Expression$cyclic$precedence9ComposeR = function () {
        return $author$project$Elm$Parser$Expression$precedence9ComposeR;
    };
    var $author$project$Elm$Parser$Expression$precedence8Pow = $author$project$Elm$Parser$Expression$cyclic$precedence8Pow();
    $author$project$Elm$Parser$Expression$cyclic$precedence8Pow = function () {
        return $author$project$Elm$Parser$Expression$precedence8Pow;
    };
    var $author$project$Elm$Parser$Expression$precedence7Slash = $author$project$Elm$Parser$Expression$cyclic$precedence7Slash();
    $author$project$Elm$Parser$Expression$cyclic$precedence7Slash = function () {
        return $author$project$Elm$Parser$Expression$precedence7Slash;
    };
    var $author$project$Elm$Parser$Expression$precedence5append = $author$project$Elm$Parser$Expression$cyclic$precedence5append();
    $author$project$Elm$Parser$Expression$cyclic$precedence5append = function () {
        return $author$project$Elm$Parser$Expression$precedence5append;
    };
    var $author$project$Elm$Parser$Expression$precedence5Cons = $author$project$Elm$Parser$Expression$cyclic$precedence5Cons();
    $author$project$Elm$Parser$Expression$cyclic$precedence5Cons = function () {
        return $author$project$Elm$Parser$Expression$precedence5Cons;
    };
    var $author$project$Elm$Parser$Expression$precedence3And = $author$project$Elm$Parser$Expression$cyclic$precedence3And();
    $author$project$Elm$Parser$Expression$cyclic$precedence3And = function () {
        return $author$project$Elm$Parser$Expression$precedence3And;
    };
    var $author$project$Elm$Parser$Expression$precedence2Or = $author$project$Elm$Parser$Expression$cyclic$precedence2Or();
    $author$project$Elm$Parser$Expression$cyclic$precedence2Or = function () {
        return $author$project$Elm$Parser$Expression$precedence2Or;
    };
    var $author$project$Elm$Parser$Expression$precedence1ApL = $author$project$Elm$Parser$Expression$cyclic$precedence1ApL();
    $author$project$Elm$Parser$Expression$cyclic$precedence1ApL = function () {
        return $author$project$Elm$Parser$Expression$precedence1ApL;
    };
    var $author$project$Elm$Parser$Expression$negationAfterMinus = $author$project$Elm$Parser$Expression$cyclic$negationAfterMinus();
    $author$project$Elm$Parser$Expression$cyclic$negationAfterMinus = function () {
        return $author$project$Elm$Parser$Expression$negationAfterMinus;
    };
    var $author$project$Elm$Parser$Expression$negationOperationOptimisticLayout = $author$project$Elm$Parser$Expression$cyclic$negationOperationOptimisticLayout();
    $author$project$Elm$Parser$Expression$cyclic$negationOperationOptimisticLayout = function () {
        return $author$project$Elm$Parser$Expression$negationOperationOptimisticLayout;
    };
    var $author$project$Elm$Parser$Expression$negationOperation = $author$project$Elm$Parser$Expression$cyclic$negationOperation();
    $author$project$Elm$Parser$Expression$cyclic$negationOperation = function () {
        return $author$project$Elm$Parser$Expression$negationOperation;
    };
    var $author$project$Elm$Parser$Expression$subExpression = $author$project$Elm$Parser$Expression$cyclic$subExpression();
    $author$project$Elm$Parser$Expression$cyclic$subExpression = function () {
        return $author$project$Elm$Parser$Expression$subExpression;
    };
    var $author$project$Elm$Parser$Expression$subExpressionMaybeAppliedOptimisticLayout = $author$project$Elm$Parser$Expression$cyclic$subExpressionMaybeAppliedOptimisticLayout();
    $author$project$Elm$Parser$Expression$cyclic$subExpressionMaybeAppliedOptimisticLayout = function () {
        return $author$project$Elm$Parser$Expression$subExpressionMaybeAppliedOptimisticLayout;
    };
    var $elm$core$Maybe$map_fn = function (f, maybe) {
        if (!maybe.$) {
            var value = maybe.a;
            return $elm$core$Maybe$Just(f(value));
        }
        else {
            return $elm$core$Maybe$Nothing;
        }
    }, $elm$core$Maybe$map = F2($elm$core$Maybe$map_fn);
    var $author$project$ParserFast$map6_fn = function (func, _v0, _v1, _v2, _v3, _v4, _v5) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        var parseF = _v5;
        return function (s0) {
            var _v6 = parseA(s0);
            if (_v6.$ === 1) {
                var committed = _v6.a;
                var x = _v6.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v6.a;
                var s1 = _v6.b;
                var _v7 = parseB(s1);
                if (_v7.$ === 1) {
                    var x = _v7.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v7.a;
                    var s2 = _v7.b;
                    var _v8 = parseC(s2);
                    if (_v8.$ === 1) {
                        var x = _v8.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v8.a;
                        var s3 = _v8.b;
                        var _v9 = parseD(s3);
                        if (_v9.$ === 1) {
                            var x = _v9.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v9.a;
                            var s4 = _v9.b;
                            var _v10 = parseE(s4);
                            if (_v10.$ === 1) {
                                var x = _v10.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v10.a;
                                var s5 = _v10.b;
                                var _v11 = parseF(s5);
                                if (_v11.$ === 1) {
                                    var x = _v11.b;
                                    return $author$project$ParserFast$Bad_fn(true, x);
                                }
                                else {
                                    var f = _v11.a;
                                    var s6 = _v11.b;
                                    return $author$project$ParserFast$Good_fn(A6(func, a, b, c, d, e, f), s6);
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map6_fn_unwrapped = function (func, _v0, _v1, _v2, _v3, _v4, _v5) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        var parseF = _v5;
        return function (s0) {
            var _v6 = parseA(s0);
            if (_v6.$ === 1) {
                var committed = _v6.a;
                var x = _v6.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v6.a;
                var s1 = _v6.b;
                var _v7 = parseB(s1);
                if (_v7.$ === 1) {
                    var x = _v7.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v7.a;
                    var s2 = _v7.b;
                    var _v8 = parseC(s2);
                    if (_v8.$ === 1) {
                        var x = _v8.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v8.a;
                        var s3 = _v8.b;
                        var _v9 = parseD(s3);
                        if (_v9.$ === 1) {
                            var x = _v9.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v9.a;
                            var s4 = _v9.b;
                            var _v10 = parseE(s4);
                            if (_v10.$ === 1) {
                                var x = _v10.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v10.a;
                                var s5 = _v10.b;
                                var _v11 = parseF(s5);
                                if (_v11.$ === 1) {
                                    var x = _v11.b;
                                    return $author$project$ParserFast$Bad_fn(true, x);
                                }
                                else {
                                    var f = _v11.a;
                                    var s6 = _v11.b;
                                    return $author$project$ParserFast$Good_fn(func(a, b, c, d, e, f), s6);
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map6 = F7($author$project$ParserFast$map6_fn);
    var $author$project$Elm$Parser$Declarations$parameterPatternsEqual = $author$project$ParserWithComments$until_fn($author$project$Elm$Parser$Tokens$equal, $author$project$ParserFast$map2_fn_unwrapped(function (patternResult, commentsAfterPattern) {
        return {
            e: $author$project$Rope$prependTo_fn(commentsAfterPattern, patternResult.e),
            d: patternResult.d
        };
    }, $author$project$Elm$Parser$Patterns$patternNotDirectlyComposing, $author$project$Elm$Parser$Layout$maybeLayout));
    var $author$project$Elm$Parser$Declarations$functionAfterDocumentation = $author$project$ParserFast$map6_fn_unwrapped(function (startName, commentsAfterStartName, maybeSignature, _arguments, commentsAfterEqual, result) {
        return {
            e: $author$project$Rope$prependTo_fn(result.e, $author$project$Rope$prependTo_fn(commentsAfterEqual, $author$project$Rope$prependTo_fn(_arguments.e, function () {
                if (maybeSignature.$ === 1) {
                    return commentsAfterStartName;
                }
                else {
                    var signature = maybeSignature.a;
                    return $author$project$Rope$prependTo_fn(signature.e, commentsAfterStartName);
                }
            }()))),
            d: $author$project$Elm$Parser$Declarations$FunctionDeclarationAfterDocumentation({
                _: _arguments.d,
                V: result.d,
                am: $elm$core$Maybe$map_fn(function ($) {
                    return $.d;
                }, maybeSignature),
                bF: startName
            })
        };
    }, $author$project$Elm$Parser$Tokens$functionNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$map4OrSucceed_fn_unwrapped(function (commentsBeforeTypeAnnotation, typeAnnotationResult, implementationName, afterImplementationName) {
        return $elm$core$Maybe$Just({
            e: $author$project$Rope$prependTo_fn(afterImplementationName, $author$project$Rope$prependTo_fn(implementationName.e, $author$project$Rope$prependTo_fn(typeAnnotationResult.e, commentsBeforeTypeAnnotation))),
            d: { aM: implementationName.d, y: typeAnnotationResult.d }
        });
    }, $author$project$ParserFast$symbolFollowedBy_fn(":", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$TypeAnnotation$typeAnnotation, $author$project$Elm$Parser$Layout$layoutStrictFollowedBy($author$project$Elm$Parser$Tokens$functionNameNode), $author$project$Elm$Parser$Layout$maybeLayout, $elm$core$Maybe$Nothing), $author$project$Elm$Parser$Declarations$parameterPatternsEqual, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$expression);
    var $author$project$Elm$Parser$Layout$layoutStrictFollowedByWithComments = function (nextParser) {
        return $author$project$ParserFast$map2_fn_unwrapped(function (commentsBefore, after) {
            return {
                e: $author$project$Rope$prependTo_fn(after.e, commentsBefore),
                d: after.d
            };
        }, $author$project$Elm$Parser$Layout$optimisticLayout, $author$project$Elm$Parser$Layout$onTopIndentationFollowedBy(nextParser));
    };
    var $author$project$Elm$Parser$Declarations$PortDeclarationAfterDocumentation = function (a) {
        return { $: 3, a: a };
    };
    var $author$project$Elm$Parser$Declarations$portDeclarationAfterDocumentation = $author$project$ParserFast$map5_fn_unwrapped(function (commentsAfterPort, name, commentsAfterName, commentsAfterColon, typeAnnotationResult) {
        var nameRange = name.a;
        return {
            e: $author$project$Rope$prependTo_fn(commentsAfterColon, $author$project$Rope$prependTo_fn(typeAnnotationResult.e, $author$project$Rope$prependTo_fn(commentsAfterName, commentsAfterPort))),
            d: $author$project$Elm$Parser$Declarations$PortDeclarationAfterDocumentation({
                q: name,
                c7: { bk: 1, bz: nameRange.bE.bz },
                y: typeAnnotationResult.d
            })
        };
    }, $author$project$ParserFast$keywordFollowedBy_fn("port", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Tokens$functionNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$symbolFollowedBy_fn(":", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$TypeAnnotation$typeAnnotation);
    var $author$project$Elm$Syntax$Node$range = function (_v0) {
        var r = _v0.a;
        return r;
    };
    var $author$project$Elm$Parser$Declarations$TypeDeclarationAfterDocumentation = function (a) {
        return { $: 1, a: a };
    };
    var $author$project$Elm$Parser$Declarations$typeGenericListEquals = $author$project$ParserWithComments$until_fn($author$project$Elm$Parser$Tokens$equal, $author$project$ParserFast$map2_fn_unwrapped(function (name, commentsAfterName) {
        return { e: commentsAfterName, d: name };
    }, $author$project$Elm$Parser$Tokens$functionNameNode, $author$project$Elm$Parser$Layout$maybeLayout));
    var $author$project$ParserFast$ifFollowedByWhileMapWithRangeWithoutLinebreak_fn = function (rangeAndConsumedStringToRes, firstIsOkay, afterFirstIsOkay) {
        return function (s0) {
            var firstOffset = $author$project$ParserFast$isSubCharWithoutLinebreak_fn(firstIsOkay, s0.b, s0.c);
            if (firstOffset === -1) {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingCharSatisfyingPredicate_fn(s0.bz, s0.a));
            }
            else {
                var s1 = $author$project$ParserFast$skipWhileWithoutLinebreakHelp_fn(afterFirstIsOkay, firstOffset, s0.bz, s0.a + 1, s0.c, s0.f);
                return $author$project$ParserFast$Good_fn(A2(rangeAndConsumedStringToRes, {
                    cm: { bk: s1.a, bz: s1.bz },
                    bE: { bk: s0.a, bz: s0.bz }
                }, _String_slice_fn(s0.b, s1.b, s0.c)), s1);
            }
        };
    }, $author$project$ParserFast$ifFollowedByWhileMapWithRangeWithoutLinebreak_fn_unwrapped = function (rangeAndConsumedStringToRes, firstIsOkay, afterFirstIsOkay) {
        return function (s0) {
            var firstOffset = $author$project$ParserFast$isSubCharWithoutLinebreak_fn(firstIsOkay, s0.b, s0.c);
            if (firstOffset === -1) {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingCharSatisfyingPredicate_fn(s0.bz, s0.a));
            }
            else {
                var s1 = $author$project$ParserFast$skipWhileWithoutLinebreakHelp_fn(afterFirstIsOkay, firstOffset, s0.bz, s0.a + 1, s0.c, s0.f);
                return $author$project$ParserFast$Good_fn(rangeAndConsumedStringToRes({
                    cm: { bk: s1.a, bz: s1.bz },
                    bE: { bk: s0.a, bz: s0.bz }
                }, _String_slice_fn(s0.b, s1.b, s0.c)), s1);
            }
        };
    }, $author$project$ParserFast$ifFollowedByWhileMapWithRangeWithoutLinebreak = F3($author$project$ParserFast$ifFollowedByWhileMapWithRangeWithoutLinebreak_fn);
    var $author$project$Elm$Parser$Tokens$typeNameNode = $author$project$ParserFast$ifFollowedByWhileMapWithRangeWithoutLinebreak_fn($author$project$Elm$Syntax$Node$Node, $author$project$Char$Extra$unicodeIsUpperFast, $author$project$Char$Extra$unicodeIsAlphaNumOrUnderscoreFast);
    var $author$project$Elm$Parser$Declarations$valueConstructorOptimisticLayout = $author$project$ParserFast$map3_fn_unwrapped(function (name, commentsAfterName, argumentsReverse) {
        var nameRange = name.a;
        var fullRange = function () {
            var _v0 = argumentsReverse.d;
            if (_v0.b) {
                var _v1 = _v0.a;
                var lastArgRange = _v1.a;
                return { cm: lastArgRange.cm, bE: nameRange.bE };
            }
            else {
                return nameRange;
            }
        }();
        return {
            e: $author$project$Rope$prependTo_fn(argumentsReverse.e, commentsAfterName),
            d: $author$project$Elm$Syntax$Node$Node_fn(fullRange, {
                _: $elm$core$List$reverse(argumentsReverse.d),
                q: name
            })
        };
    }, $author$project$Elm$Parser$Tokens$typeNameNode, $author$project$Elm$Parser$Layout$optimisticLayout, $author$project$ParserWithComments$manyWithoutReverse($author$project$Elm$Parser$Layout$positivelyIndentedFollowedBy($author$project$ParserFast$map2_fn_unwrapped(function (typeAnnotationResult, commentsAfter) {
        return {
            e: $author$project$Rope$prependTo_fn(commentsAfter, typeAnnotationResult.e),
            d: typeAnnotationResult.d
        };
    }, $author$project$Elm$Parser$TypeAnnotation$typeAnnotationNoFnExcludingTypedWithArguments, $author$project$Elm$Parser$Layout$optimisticLayout))));
    var $author$project$Elm$Parser$Declarations$customTypeDefinitionAfterDocumentationAfterTypePrefix = $author$project$ParserFast$map6_fn_unwrapped(function (name, commentsAfterName, parameters, commentsAfterEqual, headVariant, tailVariantsReverse) {
        return {
            e: $author$project$Rope$prependTo_fn(tailVariantsReverse.e, $author$project$Rope$prependTo_fn(headVariant.e, $author$project$Rope$prependTo_fn(commentsAfterEqual, $author$project$Rope$prependTo_fn(parameters.e, commentsAfterName)))),
            d: $author$project$Elm$Parser$Declarations$TypeDeclarationAfterDocumentation({ aK: headVariant.d, q: name, ah: parameters.d, aX: tailVariantsReverse.d })
        };
    }, $author$project$Elm$Parser$Tokens$typeNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Declarations$typeGenericListEquals, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Declarations$valueConstructorOptimisticLayout, $author$project$ParserWithComments$manyWithoutReverse($author$project$ParserFast$symbolFollowedBy_fn("|", $author$project$Elm$Parser$Layout$positivelyIndentedPlusFollowedBy_fn(1, $author$project$ParserFast$map2_fn_unwrapped(function (commentsBeforePipe, variantResult) {
        return {
            e: $author$project$Rope$prependTo_fn(variantResult.e, commentsBeforePipe),
            d: variantResult.d
        };
    }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Declarations$valueConstructorOptimisticLayout)))));
    var $author$project$Elm$Parser$Declarations$TypeAliasDeclarationAfterDocumentation = function (a) {
        return { $: 2, a: a };
    };
    var $author$project$Elm$Parser$Declarations$typeAliasDefinitionAfterDocumentationAfterTypePrefix = $author$project$ParserFast$map6_fn_unwrapped(function (commentsAfterAlias, name, commentsAfterName, parameters, commentsAfterEquals, typeAnnotationResult) {
        return {
            e: $author$project$Rope$prependTo_fn(typeAnnotationResult.e, $author$project$Rope$prependTo_fn(commentsAfterEquals, $author$project$Rope$prependTo_fn(parameters.e, $author$project$Rope$prependTo_fn(commentsAfterName, commentsAfterAlias)))),
            d: $author$project$Elm$Parser$Declarations$TypeAliasDeclarationAfterDocumentation({ q: name, ah: parameters.d, y: typeAnnotationResult.d })
        };
    }, $author$project$ParserFast$keywordFollowedBy_fn("alias", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Tokens$typeNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Declarations$typeGenericListEquals, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$TypeAnnotation$typeAnnotation);
    var $author$project$Elm$Parser$Declarations$typeOrTypeAliasDefinitionAfterDocumentation = $author$project$ParserFast$map2_fn_unwrapped(function (commentsAfterType, declarationAfterDocumentation) {
        return {
            e: $author$project$Rope$prependTo_fn(declarationAfterDocumentation.e, commentsAfterType),
            d: declarationAfterDocumentation.d
        };
    }, $author$project$ParserFast$keywordFollowedBy_fn("type", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$ParserFast$oneOf2_fn($author$project$Elm$Parser$Declarations$typeAliasDefinitionAfterDocumentationAfterTypePrefix, $author$project$Elm$Parser$Declarations$customTypeDefinitionAfterDocumentationAfterTypePrefix));
    var $author$project$Elm$Parser$Declarations$declarationWithDocumentation = $author$project$ParserFast$validate_fn(function (result) {
        var _v11 = result.d;
        var decl = _v11.b;
        if (!decl.$) {
            var letFunctionDeclaration = decl.a;
            var _v13 = letFunctionDeclaration.am;
            if (_v13.$ === 1) {
                return true;
            }
            else {
                var _v14 = _v13.a;
                var signature = _v14.b;
                var _v15 = signature.q;
                var signatureName = _v15.b;
                var _v16 = letFunctionDeclaration.aG;
                var implementation = _v16.b;
                var _v17 = implementation.q;
                var implementationName = _v17.b;
                return _Utils_eq(implementationName, signatureName + "");
            }
        }
        else {
            return true;
        }
    }, "Expected to find the same name for declaration and signature", $author$project$ParserFast$map2_fn_unwrapped(function (documentation, afterDocumentation) {
        var start = $author$project$Elm$Syntax$Node$range(documentation).bE;
        var _v0 = afterDocumentation.d;
        switch (_v0.$) {
            case 0:
                var functionDeclarationAfterDocumentation = _v0.a;
                var _v1 = functionDeclarationAfterDocumentation.am;
                if (!_v1.$) {
                    var signature = _v1.a;
                    var _v2 = signature.aM;
                    var implementationNameRange = _v2.a;
                    var _v3 = functionDeclarationAfterDocumentation.V;
                    var expressionRange = _v3.a;
                    return {
                        e: afterDocumentation.e,
                        d: $author$project$Elm$Syntax$Node$Node_fn({ cm: expressionRange.cm, bE: start }, $author$project$Elm$Syntax$Declaration$FunctionDeclaration({
                            aG: $author$project$Elm$Syntax$Node$Node_fn({ cm: expressionRange.cm, bE: implementationNameRange.bE }, { _: functionDeclarationAfterDocumentation._, V: functionDeclarationAfterDocumentation.V, q: signature.aM }),
                            ab: $elm$core$Maybe$Just(documentation),
                            am: $elm$core$Maybe$Just($author$project$Elm$Syntax$Node$combine_fn($author$project$Elm$Syntax$Signature$Signature, functionDeclarationAfterDocumentation.bF, signature.y))
                        }))
                    };
                }
                else {
                    var _v4 = functionDeclarationAfterDocumentation.bF;
                    var startNameRange = _v4.a;
                    var _v5 = functionDeclarationAfterDocumentation.V;
                    var expressionRange = _v5.a;
                    return {
                        e: afterDocumentation.e,
                        d: $author$project$Elm$Syntax$Node$Node_fn({ cm: expressionRange.cm, bE: start }, $author$project$Elm$Syntax$Declaration$FunctionDeclaration({
                            aG: $author$project$Elm$Syntax$Node$Node_fn({ cm: expressionRange.cm, bE: startNameRange.bE }, { _: functionDeclarationAfterDocumentation._, V: functionDeclarationAfterDocumentation.V, q: functionDeclarationAfterDocumentation.bF }),
                            ab: $elm$core$Maybe$Just(documentation),
                            am: $elm$core$Maybe$Nothing
                        }))
                    };
                }
            case 1:
                var typeDeclarationAfterDocumentation = _v0.a;
                var end = function () {
                    var _v6 = typeDeclarationAfterDocumentation.aX;
                    if (_v6.b) {
                        var _v7 = _v6.a;
                        var range = _v7.a;
                        return range.cm;
                    }
                    else {
                        var _v8 = typeDeclarationAfterDocumentation.aK;
                        var headVariantRange = _v8.a;
                        return headVariantRange.cm;
                    }
                }();
                return {
                    e: afterDocumentation.e,
                    d: $author$project$Elm$Syntax$Node$Node_fn({ cm: end, bE: start }, $author$project$Elm$Syntax$Declaration$CustomTypeDeclaration({
                        cj: _List_Cons(typeDeclarationAfterDocumentation.aK, $elm$core$List$reverse(typeDeclarationAfterDocumentation.aX)),
                        ab: $elm$core$Maybe$Just(documentation),
                        bs: typeDeclarationAfterDocumentation.ah,
                        q: typeDeclarationAfterDocumentation.q
                    }))
                };
            case 2:
                var typeAliasDeclarationAfterDocumentation = _v0.a;
                var _v9 = typeAliasDeclarationAfterDocumentation.y;
                var typeAnnotationRange = _v9.a;
                return {
                    e: afterDocumentation.e,
                    d: $author$project$Elm$Syntax$Node$Node_fn({ cm: typeAnnotationRange.cm, bE: start }, $author$project$Elm$Syntax$Declaration$AliasDeclaration({
                        ab: $elm$core$Maybe$Just(documentation),
                        bs: typeAliasDeclarationAfterDocumentation.ah,
                        q: typeAliasDeclarationAfterDocumentation.q,
                        y: typeAliasDeclarationAfterDocumentation.y
                    }))
                };
            default:
                var portDeclarationAfterName = _v0.a;
                var _v10 = portDeclarationAfterName.y;
                var typeAnnotationRange = _v10.a;
                return {
                    e: $author$project$Rope$filledPrependTo_fn(afterDocumentation.e, $author$project$Rope$one(documentation)),
                    d: $author$project$Elm$Syntax$Node$Node_fn({ cm: typeAnnotationRange.cm, bE: portDeclarationAfterName.c7 }, $author$project$Elm$Syntax$Declaration$PortDeclaration({ q: portDeclarationAfterName.q, y: portDeclarationAfterName.y }))
                };
        }
    }, $author$project$Elm$Parser$Comments$declarationDocumentation, $author$project$Elm$Parser$Layout$layoutStrictFollowedByWithComments($author$project$ParserFast$oneOf3_fn($author$project$Elm$Parser$Declarations$functionAfterDocumentation, $author$project$Elm$Parser$Declarations$typeOrTypeAliasDefinitionAfterDocumentation, $author$project$Elm$Parser$Declarations$portDeclarationAfterDocumentation))));
    var $author$project$Elm$Parser$Tokens$functionNameNotInfixNode = $author$project$ParserFast$ifFollowedByWhileValidateMapWithRangeWithoutLinebreak_fn($author$project$Elm$Syntax$Node$Node, $author$project$Char$Extra$unicodeIsLowerFast, $author$project$Char$Extra$unicodeIsAlphaNumOrUnderscoreFast, function (name) {
        return (name !== "infix") && $author$project$Elm$Parser$Tokens$isNotReserved(name);
    });
    var $author$project$Elm$Parser$Declarations$functionDeclarationWithoutDocumentation = $author$project$ParserFast$validate_fn(function (result) {
        var _v5 = result.d;
        var decl = _v5.b;
        if (!decl.$) {
            var letFunctionDeclaration = decl.a;
            var _v7 = letFunctionDeclaration.am;
            if (_v7.$ === 1) {
                return true;
            }
            else {
                var _v8 = _v7.a;
                var signature = _v8.b;
                var _v9 = signature.q;
                var signatureName = _v9.b;
                var _v10 = letFunctionDeclaration.aG;
                var implementation = _v10.b;
                var _v11 = implementation.q;
                var implementationName = _v11.b;
                return _Utils_eq(implementationName, signatureName + "");
            }
        }
        else {
            return true;
        }
    }, "Expected to find the same name for declaration and signature", $author$project$ParserFast$map6WithStartLocation_fn_unwrapped(function (startNameStart, startNameNode, commentsAfterStartName, maybeSignature, _arguments, commentsAfterEqual, result) {
        var allComments = $author$project$Rope$prependTo_fn(result.e, $author$project$Rope$prependTo_fn(commentsAfterEqual, $author$project$Rope$prependTo_fn(_arguments.e, function () {
            if (maybeSignature.$ === 1) {
                return commentsAfterStartName;
            }
            else {
                var signature = maybeSignature.a;
                return $author$project$Rope$prependTo_fn(signature.e, commentsAfterStartName);
            }
        }())));
        if (maybeSignature.$ === 1) {
            var _v1 = result.d;
            var expressionRange = _v1.a;
            return {
                e: allComments,
                d: $author$project$Elm$Syntax$Node$Node_fn({ cm: expressionRange.cm, bE: startNameStart }, $author$project$Elm$Syntax$Declaration$FunctionDeclaration({
                    aG: $author$project$Elm$Syntax$Node$Node_fn({ cm: expressionRange.cm, bE: startNameStart }, { _: _arguments.d, V: result.d, q: startNameNode }),
                    ab: $elm$core$Maybe$Nothing,
                    am: $elm$core$Maybe$Nothing
                }))
            };
        }
        else {
            var signature = maybeSignature.a;
            var _v2 = signature.aM;
            var implementationNameRange = _v2.a;
            var _v3 = result.d;
            var expressionRange = _v3.a;
            return {
                e: allComments,
                d: $author$project$Elm$Syntax$Node$Node_fn({ cm: expressionRange.cm, bE: startNameStart }, $author$project$Elm$Syntax$Declaration$FunctionDeclaration({
                    aG: $author$project$Elm$Syntax$Node$Node_fn({ cm: expressionRange.cm, bE: implementationNameRange.bE }, { _: _arguments.d, V: result.d, q: signature.aM }),
                    ab: $elm$core$Maybe$Nothing,
                    am: $elm$core$Maybe$Just($author$project$Elm$Syntax$Node$combine_fn($author$project$Elm$Syntax$Signature$Signature, startNameNode, signature.y))
                }))
            };
        }
    }, $author$project$Elm$Parser$Tokens$functionNameNotInfixNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$map4OrSucceed_fn_unwrapped(function (commentsBeforeTypeAnnotation, typeAnnotationResult, implementationName, afterImplementationName) {
        return $elm$core$Maybe$Just({
            e: $author$project$Rope$prependTo_fn(afterImplementationName, $author$project$Rope$prependTo_fn(implementationName.e, $author$project$Rope$prependTo_fn(typeAnnotationResult.e, commentsBeforeTypeAnnotation))),
            aM: implementationName.d,
            y: typeAnnotationResult.d
        });
    }, $author$project$ParserFast$symbolFollowedBy_fn(":", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$TypeAnnotation$typeAnnotation, $author$project$Elm$Parser$Layout$layoutStrictFollowedBy($author$project$Elm$Parser$Tokens$functionNameNode), $author$project$Elm$Parser$Layout$maybeLayout, $elm$core$Maybe$Nothing), $author$project$Elm$Parser$Declarations$parameterPatternsEqual, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expression$expression));
    var $author$project$Elm$Syntax$Declaration$InfixDeclaration = function (a) {
        return { $: 4, a: a };
    };
    var $author$project$Elm$Parser$Declarations$infixDirection = $author$project$ParserFast$oneOf3_fn($author$project$ParserFast$mapWithRange_fn($author$project$Elm$Syntax$Node$Node, $author$project$ParserFast$keyword_fn("right", 1)), $author$project$ParserFast$mapWithRange_fn($author$project$Elm$Syntax$Node$Node, $author$project$ParserFast$keyword_fn("left", 0)), $author$project$ParserFast$mapWithRange_fn($author$project$Elm$Syntax$Node$Node, $author$project$ParserFast$keyword_fn("non", 2)));
    var $author$project$ParserFast$errorAsOffsetAndInt = { F: 0, b: -1 };
    var $author$project$ParserFast$convertIntegerDecimal_fn = function (offset, src) {
        var _v0 = _String_slice_fn(offset, offset + 1, src);
        switch (_v0) {
            case "0":
                return { F: 0, b: offset + 1 };
            case "1":
                return $author$project$ParserFast$convert0OrMore0To9s_fn(1, offset + 1, src);
            case "2":
                return $author$project$ParserFast$convert0OrMore0To9s_fn(2, offset + 1, src);
            case "3":
                return $author$project$ParserFast$convert0OrMore0To9s_fn(3, offset + 1, src);
            case "4":
                return $author$project$ParserFast$convert0OrMore0To9s_fn(4, offset + 1, src);
            case "5":
                return $author$project$ParserFast$convert0OrMore0To9s_fn(5, offset + 1, src);
            case "6":
                return $author$project$ParserFast$convert0OrMore0To9s_fn(6, offset + 1, src);
            case "7":
                return $author$project$ParserFast$convert0OrMore0To9s_fn(7, offset + 1, src);
            case "8":
                return $author$project$ParserFast$convert0OrMore0To9s_fn(8, offset + 1, src);
            case "9":
                return $author$project$ParserFast$convert0OrMore0To9s_fn(9, offset + 1, src);
            default:
                return $author$project$ParserFast$errorAsOffsetAndInt;
        }
    }, $author$project$ParserFast$convertIntegerDecimal = F2($author$project$ParserFast$convertIntegerDecimal_fn);
    var $author$project$ParserFast$integerDecimalMapWithRange = function (rangeAndIntToRes) {
        return function (s0) {
            var s1 = $author$project$ParserFast$convertIntegerDecimal_fn(s0.b, s0.c);
            if (s1.b === -1) {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingNumber_fn(s0.bz, s0.a));
            }
            else {
                var newColumn = s0.a + (s1.b - s0.b);
                return $author$project$ParserFast$Good_fn(A2(rangeAndIntToRes, {
                    cm: { bk: newColumn, bz: s0.bz },
                    bE: { bk: s0.a, bz: s0.bz }
                }, s1.F), { a: newColumn, f: s0.f, b: s1.b, bz: s0.bz, c: s0.c });
            }
        };
    }, $author$project$ParserFast$integerDecimalMapWithRange_unwrapped = function (rangeAndIntToRes) {
        return function (s0) {
            var s1 = $author$project$ParserFast$convertIntegerDecimal_fn(s0.b, s0.c);
            if (s1.b === -1) {
                return $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingNumber_fn(s0.bz, s0.a));
            }
            else {
                var newColumn = s0.a + (s1.b - s0.b);
                return $author$project$ParserFast$Good_fn(rangeAndIntToRes({
                    cm: { bk: newColumn, bz: s0.bz },
                    bE: { bk: s0.a, bz: s0.bz }
                }, s1.F), { a: newColumn, f: s0.f, b: s1.b, bz: s0.bz, c: s0.c });
            }
        };
    };
    var $author$project$ParserFast$map9WithRange = function (func) {
        return function (_v0) {
            return function (_v1) {
                return function (_v2) {
                    return function (_v3) {
                        return function (_v4) {
                            return function (_v5) {
                                return function (_v6) {
                                    return function (_v7) {
                                        return function (_v8) {
                                            var parseA = _v0;
                                            var parseB = _v1;
                                            var parseC = _v2;
                                            var parseD = _v3;
                                            var parseE = _v4;
                                            var parseF = _v5;
                                            var parseG = _v6;
                                            var parseH = _v7;
                                            var parseI = _v8;
                                            return function (s0) {
                                                var _v9 = parseA(s0);
                                                if (_v9.$ === 1) {
                                                    var committed = _v9.a;
                                                    var x = _v9.b;
                                                    return $author$project$ParserFast$Bad_fn(committed, x);
                                                }
                                                else {
                                                    var a = _v9.a;
                                                    var s1 = _v9.b;
                                                    var _v10 = parseB(s1);
                                                    if (_v10.$ === 1) {
                                                        var x = _v10.b;
                                                        return $author$project$ParserFast$Bad_fn(true, x);
                                                    }
                                                    else {
                                                        var b = _v10.a;
                                                        var s2 = _v10.b;
                                                        var _v11 = parseC(s2);
                                                        if (_v11.$ === 1) {
                                                            var x = _v11.b;
                                                            return $author$project$ParserFast$Bad_fn(true, x);
                                                        }
                                                        else {
                                                            var c = _v11.a;
                                                            var s3 = _v11.b;
                                                            var _v12 = parseD(s3);
                                                            if (_v12.$ === 1) {
                                                                var x = _v12.b;
                                                                return $author$project$ParserFast$Bad_fn(true, x);
                                                            }
                                                            else {
                                                                var d = _v12.a;
                                                                var s4 = _v12.b;
                                                                var _v13 = parseE(s4);
                                                                if (_v13.$ === 1) {
                                                                    var x = _v13.b;
                                                                    return $author$project$ParserFast$Bad_fn(true, x);
                                                                }
                                                                else {
                                                                    var e = _v13.a;
                                                                    var s5 = _v13.b;
                                                                    var _v14 = parseF(s5);
                                                                    if (_v14.$ === 1) {
                                                                        var x = _v14.b;
                                                                        return $author$project$ParserFast$Bad_fn(true, x);
                                                                    }
                                                                    else {
                                                                        var f = _v14.a;
                                                                        var s6 = _v14.b;
                                                                        var _v15 = parseG(s6);
                                                                        if (_v15.$ === 1) {
                                                                            var x = _v15.b;
                                                                            return $author$project$ParserFast$Bad_fn(true, x);
                                                                        }
                                                                        else {
                                                                            var g = _v15.a;
                                                                            var s7 = _v15.b;
                                                                            var _v16 = parseH(s7);
                                                                            if (_v16.$ === 1) {
                                                                                var x = _v16.b;
                                                                                return $author$project$ParserFast$Bad_fn(true, x);
                                                                            }
                                                                            else {
                                                                                var h = _v16.a;
                                                                                var s8 = _v16.b;
                                                                                var _v17 = parseI(s8);
                                                                                if (_v17.$ === 1) {
                                                                                    var x = _v17.b;
                                                                                    return $author$project$ParserFast$Bad_fn(true, x);
                                                                                }
                                                                                else {
                                                                                    var i = _v17.a;
                                                                                    var s9 = _v17.b;
                                                                                    return $author$project$ParserFast$Good_fn(func({
                                                                                        cm: { bk: s9.a, bz: s9.bz },
                                                                                        bE: { bk: s0.a, bz: s0.bz }
                                                                                    })(a)(b)(c)(d)(e)(f)(g)(h)(i), s9);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            };
                                        };
                                    };
                                };
                            };
                        };
                    };
                };
            };
        };
    };
    var $author$project$Elm$Parser$Declarations$infixDeclaration = $author$project$ParserFast$map9WithRange(function (range) {
        return function (commentsAfterInfix) {
            return function (direction) {
                return function (commentsAfterDirection) {
                    return function (precedence) {
                        return function (commentsAfterPrecedence) {
                            return function (operator) {
                                return function (commentsAfterOperator) {
                                    return function (commentsAfterEqual) {
                                        return function (fn) {
                                            return {
                                                e: $author$project$Rope$prependTo_fn(commentsAfterEqual, $author$project$Rope$prependTo_fn(commentsAfterOperator, $author$project$Rope$prependTo_fn(commentsAfterPrecedence, $author$project$Rope$prependTo_fn(commentsAfterDirection, commentsAfterInfix)))),
                                                d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Declaration$InfixDeclaration({ d6: direction, ei: fn, eR: operator, eU: precedence }))
                                            };
                                        };
                                    };
                                };
                            };
                        };
                    };
                };
            };
        };
    })($author$project$ParserFast$keywordFollowedBy_fn("infix", $author$project$Elm$Parser$Layout$maybeLayout))($author$project$Elm$Parser$Declarations$infixDirection)($author$project$Elm$Parser$Layout$maybeLayout)($author$project$ParserFast$integerDecimalMapWithRange($author$project$Elm$Syntax$Node$Node))($author$project$Elm$Parser$Layout$maybeLayout)($author$project$ParserFast$symbolFollowedBy_fn("(", $author$project$ParserFast$whileAtMost3WithoutLinebreakAnd2PartUtf16ValidateMapWithRangeBacktrackableFollowedBySymbol_fn_unwrapped(function (operatorRange, operator) {
        return $author$project$Elm$Syntax$Node$Node_fn({
            cm: { bk: operatorRange.cm.bk + 1, bz: operatorRange.cm.bz },
            bE: { bk: operatorRange.bE.bk - 1, bz: operatorRange.bE.bz }
        }, operator);
    }, $author$project$Elm$Parser$Tokens$isOperatorSymbolCharAsString, $author$project$Elm$Parser$Tokens$isAllowedOperatorToken, ")")))($author$project$Elm$Parser$Layout$maybeLayout)($author$project$ParserFast$symbolFollowedBy_fn("=", $author$project$Elm$Parser$Layout$maybeLayout))($author$project$Elm$Parser$Tokens$functionNameNode);
    var $author$project$ParserFast$oneOf5_fn = function (_v0, _v1, _v2, _v3, _v4) {
        var attemptFirst = _v0;
        var attemptSecond = _v1;
        var attemptThird = _v2;
        var attemptFourth = _v3;
        var attemptFifth = _v4;
        return function (s) {
            var _v5 = attemptFirst(s);
            if (!_v5.$) {
                var firstGood = _v5;
                return firstGood;
            }
            else {
                var firstBad = _v5;
                var firstCommitted = firstBad.a;
                var firstX = firstBad.b;
                if (firstCommitted) {
                    return firstBad;
                }
                else {
                    var _v6 = attemptSecond(s);
                    if (!_v6.$) {
                        var secondGood = _v6;
                        return secondGood;
                    }
                    else {
                        var secondBad = _v6;
                        var secondCommitted = secondBad.a;
                        var secondX = secondBad.b;
                        if (secondCommitted) {
                            return secondBad;
                        }
                        else {
                            var _v7 = attemptThird(s);
                            if (!_v7.$) {
                                var thirdGood = _v7;
                                return thirdGood;
                            }
                            else {
                                var thirdBad = _v7;
                                var thirdCommitted = thirdBad.a;
                                var thirdX = thirdBad.b;
                                if (thirdCommitted) {
                                    return thirdBad;
                                }
                                else {
                                    var _v8 = attemptFourth(s);
                                    if (!_v8.$) {
                                        var fourthGood = _v8;
                                        return fourthGood;
                                    }
                                    else {
                                        var fourthBad = _v8;
                                        var fourthCommitted = fourthBad.a;
                                        var fourthX = fourthBad.b;
                                        if (fourthCommitted) {
                                            return fourthBad;
                                        }
                                        else {
                                            var _v9 = attemptFifth(s);
                                            if (!_v9.$) {
                                                var fifthGood = _v9;
                                                return fifthGood;
                                            }
                                            else {
                                                var fifthBad = _v9;
                                                var fifthCommitted = fifthBad.a;
                                                var fifthX = fifthBad.b;
                                                return fifthCommitted ? fifthBad : $author$project$ParserFast$Bad_fn(false, $author$project$ParserFast$ExpectingOneOf_fn(firstX, secondX, _List_fromArray([thirdX, fourthX, fifthX])));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$oneOf5 = F5($author$project$ParserFast$oneOf5_fn);
    var $author$project$Elm$Parser$Declarations$portDeclarationWithoutDocumentation = $author$project$ParserFast$map5_fn_unwrapped(function (commentsAfterPort, name, commentsAfterName, commentsAfterColon, typeAnnotationResult) {
        var nameRange = name.a;
        var _v0 = typeAnnotationResult.d;
        var end = _v0.a.cm;
        return {
            e: $author$project$Rope$prependTo_fn(typeAnnotationResult.e, $author$project$Rope$prependTo_fn(commentsAfterColon, $author$project$Rope$prependTo_fn(commentsAfterName, commentsAfterPort))),
            d: $author$project$Elm$Syntax$Node$Node_fn({
                cm: end,
                bE: { bk: 1, bz: nameRange.bE.bz }
            }, $author$project$Elm$Syntax$Declaration$PortDeclaration({ q: name, y: typeAnnotationResult.d }))
        };
    }, $author$project$ParserFast$keywordFollowedBy_fn("port", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Tokens$functionNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$symbolFollowedBy_fn(":", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$TypeAnnotation$typeAnnotation);
    var $author$project$Elm$Parser$Declarations$TypeDeclarationWithoutDocumentation = function (a) {
        return { $: 0, a: a };
    };
    var $author$project$Elm$Parser$Declarations$customTypeDefinitionWithoutDocumentationAfterTypePrefix = $author$project$ParserFast$map6_fn_unwrapped(function (name, commentsAfterName, parameters, commentsAfterEqual, headVariant, tailVariantsReverse) {
        return {
            e: $author$project$Rope$prependTo_fn(tailVariantsReverse.e, $author$project$Rope$prependTo_fn(headVariant.e, $author$project$Rope$prependTo_fn(commentsAfterEqual, $author$project$Rope$prependTo_fn(parameters.e, commentsAfterName)))),
            d: $author$project$Elm$Parser$Declarations$TypeDeclarationWithoutDocumentation({ aK: headVariant.d, q: name, ah: parameters.d, aX: tailVariantsReverse.d })
        };
    }, $author$project$Elm$Parser$Tokens$typeNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Declarations$typeGenericListEquals, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Declarations$valueConstructorOptimisticLayout, $author$project$ParserWithComments$manyWithoutReverse($author$project$ParserFast$symbolFollowedBy_fn("|", $author$project$Elm$Parser$Layout$positivelyIndentedPlusFollowedBy_fn(1, $author$project$ParserFast$map2_fn_unwrapped(function (commentsBeforePipe, variantResult) {
        return {
            e: $author$project$Rope$prependTo_fn(variantResult.e, commentsBeforePipe),
            d: variantResult.d
        };
    }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Declarations$valueConstructorOptimisticLayout)))));
    var $author$project$ParserFast$map2WithStartLocation_fn = function (func, _v0, _v1) {
        var parseA = _v0;
        var parseB = _v1;
        return function (s0) {
            var _v2 = parseA(s0);
            if (_v2.$ === 1) {
                var committed = _v2.a;
                var x = _v2.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v2.a;
                var s1 = _v2.b;
                var _v3 = parseB(s1);
                if (_v3.$ === 1) {
                    var x = _v3.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v3.a;
                    var s2 = _v3.b;
                    return $author$project$ParserFast$Good_fn(A3(func, { bk: s0.a, bz: s0.bz }, a, b), s2);
                }
            }
        };
    }, $author$project$ParserFast$map2WithStartLocation_fn_unwrapped = function (func, _v0, _v1) {
        var parseA = _v0;
        var parseB = _v1;
        return function (s0) {
            var _v2 = parseA(s0);
            if (_v2.$ === 1) {
                var committed = _v2.a;
                var x = _v2.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v2.a;
                var s1 = _v2.b;
                var _v3 = parseB(s1);
                if (_v3.$ === 1) {
                    var x = _v3.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v3.a;
                    var s2 = _v3.b;
                    return $author$project$ParserFast$Good_fn(func({ bk: s0.a, bz: s0.bz }, a, b), s2);
                }
            }
        };
    }, $author$project$ParserFast$map2WithStartLocation = F3($author$project$ParserFast$map2WithStartLocation_fn);
    var $author$project$Elm$Parser$Declarations$TypeAliasDeclarationWithoutDocumentation = function (a) {
        return { $: 1, a: a };
    };
    var $author$project$Elm$Parser$Declarations$typeAliasDefinitionWithoutDocumentationAfterTypePrefix = $author$project$ParserFast$map6_fn_unwrapped(function (commentsAfterAlias, name, commentsAfterName, parameters, commentsAfterEqual, typeAnnotationResult) {
        return {
            e: $author$project$Rope$prependTo_fn(typeAnnotationResult.e, $author$project$Rope$prependTo_fn(commentsAfterEqual, $author$project$Rope$prependTo_fn(parameters.e, $author$project$Rope$prependTo_fn(commentsAfterName, commentsAfterAlias)))),
            d: $author$project$Elm$Parser$Declarations$TypeAliasDeclarationWithoutDocumentation({ q: name, ah: parameters.d, y: typeAnnotationResult.d })
        };
    }, $author$project$ParserFast$keywordFollowedBy_fn("alias", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Tokens$typeNameNode, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Declarations$typeGenericListEquals, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$TypeAnnotation$typeAnnotation);
    var $author$project$Elm$Parser$Declarations$typeOrTypeAliasDefinitionWithoutDocumentation = $author$project$ParserFast$map2WithStartLocation_fn_unwrapped(function (start, commentsAfterType, afterStart) {
        var allComments = $author$project$Rope$prependTo_fn(afterStart.e, commentsAfterType);
        var _v0 = afterStart.d;
        if (!_v0.$) {
            var typeDeclarationAfterDocumentation = _v0.a;
            var end = function () {
                var _v1 = typeDeclarationAfterDocumentation.aX;
                if (_v1.b) {
                    var _v2 = _v1.a;
                    var range = _v2.a;
                    return range.cm;
                }
                else {
                    var _v3 = typeDeclarationAfterDocumentation.aK;
                    var headVariantRange = _v3.a;
                    return headVariantRange.cm;
                }
            }();
            return {
                e: allComments,
                d: $author$project$Elm$Syntax$Node$Node_fn({ cm: end, bE: start }, $author$project$Elm$Syntax$Declaration$CustomTypeDeclaration({
                    cj: _List_Cons(typeDeclarationAfterDocumentation.aK, $elm$core$List$reverse(typeDeclarationAfterDocumentation.aX)),
                    ab: $elm$core$Maybe$Nothing,
                    bs: typeDeclarationAfterDocumentation.ah,
                    q: typeDeclarationAfterDocumentation.q
                }))
            };
        }
        else {
            var typeAliasDeclarationAfterDocumentation = _v0.a;
            var _v4 = typeAliasDeclarationAfterDocumentation.y;
            var typeAnnotationRange = _v4.a;
            return {
                e: allComments,
                d: $author$project$Elm$Syntax$Node$Node_fn({ cm: typeAnnotationRange.cm, bE: start }, $author$project$Elm$Syntax$Declaration$AliasDeclaration({ ab: $elm$core$Maybe$Nothing, bs: typeAliasDeclarationAfterDocumentation.ah, q: typeAliasDeclarationAfterDocumentation.q, y: typeAliasDeclarationAfterDocumentation.y }))
            };
        }
    }, $author$project$ParserFast$keywordFollowedBy_fn("type", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$ParserFast$oneOf2_fn($author$project$Elm$Parser$Declarations$typeAliasDefinitionWithoutDocumentationAfterTypePrefix, $author$project$Elm$Parser$Declarations$customTypeDefinitionWithoutDocumentationAfterTypePrefix));
    var $author$project$Elm$Parser$Declarations$declaration = $author$project$ParserFast$oneOf5_fn($author$project$Elm$Parser$Declarations$functionDeclarationWithoutDocumentation, $author$project$Elm$Parser$Declarations$declarationWithDocumentation, $author$project$Elm$Parser$Declarations$typeOrTypeAliasDefinitionWithoutDocumentation, $author$project$Elm$Parser$Declarations$portDeclarationWithoutDocumentation, $author$project$Elm$Parser$Declarations$infixDeclaration);
    var $author$project$ParserFast$columnAndThen = function (callback) {
        return function (s) {
            var _v0 = callback(s.a);
            var parse = _v0;
            return parse(s);
        };
    };
    var $author$project$Elm$Parser$Layout$problemModuleLevelIndentation = $author$project$ParserFast$problem("must be on module-level indentation");
    var $author$project$Elm$Parser$Layout$moduleLevelIndentationFollowedBy = function (nextParser) {
        return $author$project$ParserFast$columnAndThen(function (column) {
            return (column === 1) ? nextParser : $author$project$Elm$Parser$Layout$problemModuleLevelIndentation;
        });
    };
    var $author$project$Elm$Parser$File$fileDeclarations = $author$project$ParserWithComments$many($author$project$Elm$Parser$Layout$moduleLevelIndentationFollowedBy($author$project$ParserFast$map2_fn_unwrapped(function (declarationParsed, commentsAfter) {
        return {
            e: $author$project$Rope$prependTo_fn(commentsAfter, declarationParsed.e),
            d: declarationParsed.d
        };
    }, $author$project$Elm$Parser$Declarations$declaration, $author$project$Elm$Parser$Layout$optimisticLayout)));
    var $author$project$Elm$Syntax$Exposing$All = function (a) {
        return { $: 0, a: a };
    };
    var $author$project$Elm$Syntax$Exposing$Explicit = function (a) {
        return { $: 1, a: a };
    };
    var $author$project$Elm$Syntax$Exposing$FunctionExpose = function (a) {
        return { $: 1, a: a };
    };
    var $author$project$Elm$Parser$Expose$functionExpose = $author$project$Elm$Parser$Tokens$functionNameMapWithRange(F2(function (range, name) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Exposing$FunctionExpose(name))
        };
    }));
    var $author$project$Elm$Syntax$Exposing$InfixExpose = function (a) {
        return { $: 0, a: a };
    };
    var $author$project$Elm$Parser$Tokens$parensEnd = $author$project$ParserFast$symbol_fn(")", 0);
    var $author$project$Elm$Parser$Expose$infixExpose = $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, infixName, _v0) {
        return {
            e: $author$project$Rope$empty,
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Exposing$InfixExpose(infixName))
        };
    }, $author$project$ParserFast$symbolFollowedBy_fn("(", $author$project$ParserFast$ifFollowedByWhileWithoutLinebreak_fn(function (c) {
        return (c !== ")") && ((c !== "\n") && (c !== " "));
    }, function (c) {
        return (c !== ")") && ((c !== "\n") && (c !== " "));
    })), $author$project$Elm$Parser$Tokens$parensEnd);
    var $author$project$Elm$Syntax$Exposing$TypeExpose = function (a) {
        return { $: 3, a: a };
    };
    var $author$project$Elm$Syntax$Exposing$TypeOrAliasExpose = function (a) {
        return { $: 2, a: a };
    };
    var $author$project$ParserFast$map2WithRangeOrSucceed_fn = function (func, _v0, _v1, fallback) {
        var parseA = _v0;
        var parseB = _v1;
        return function (s0) {
            var _v2 = parseA(s0);
            if (_v2.$ === 1) {
                var c1 = _v2.a;
                var x = _v2.b;
                return c1 ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(fallback, s0);
            }
            else {
                var a = _v2.a;
                var s1 = _v2.b;
                var _v3 = parseB(s1);
                if (_v3.$ === 1) {
                    var x = _v3.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v3.a;
                    var s2 = _v3.b;
                    return $author$project$ParserFast$Good_fn(A3(func, {
                        cm: { bk: s2.a, bz: s2.bz },
                        bE: { bk: s0.a, bz: s0.bz }
                    }, a, b), s2);
                }
            }
        };
    }, $author$project$ParserFast$map2WithRangeOrSucceed_fn_unwrapped = function (func, _v0, _v1, fallback) {
        var parseA = _v0;
        var parseB = _v1;
        return function (s0) {
            var _v2 = parseA(s0);
            if (_v2.$ === 1) {
                var c1 = _v2.a;
                var x = _v2.b;
                return c1 ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(fallback, s0);
            }
            else {
                var a = _v2.a;
                var s1 = _v2.b;
                var _v3 = parseB(s1);
                if (_v3.$ === 1) {
                    var x = _v3.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v3.a;
                    var s2 = _v3.b;
                    return $author$project$ParserFast$Good_fn(func({
                        cm: { bk: s2.a, bz: s2.bz },
                        bE: { bk: s0.a, bz: s0.bz }
                    }, a, b), s2);
                }
            }
        };
    }, $author$project$ParserFast$map2WithRangeOrSucceed = F4($author$project$ParserFast$map2WithRangeOrSucceed_fn);
    var $author$project$Elm$Parser$Expose$typeExpose = $author$project$ParserFast$map3_fn_unwrapped(function (_v0, commentsBeforeMaybeOpen, maybeOpen) {
        var typeNameRange = _v0.a;
        var typeName = _v0.b;
        return {
            e: $author$project$Rope$prependTo_fn(maybeOpen.e, commentsBeforeMaybeOpen),
            d: function () {
                var _v1 = maybeOpen.d;
                if (_v1.$ === 1) {
                    return $author$project$Elm$Syntax$Node$Node_fn(typeNameRange, $author$project$Elm$Syntax$Exposing$TypeOrAliasExpose(typeName));
                }
                else {
                    var openRange = _v1.a;
                    return $author$project$Elm$Syntax$Node$Node_fn({ cm: openRange.cm, bE: typeNameRange.bE }, $author$project$Elm$Syntax$Exposing$TypeExpose({ q: typeName, eQ: maybeOpen.d }));
                }
            }()
        };
    }, $author$project$Elm$Parser$Tokens$typeNameNode, $author$project$Elm$Parser$Layout$optimisticLayout, $author$project$ParserFast$map2WithRangeOrSucceed_fn_unwrapped(function (range, left, right) {
        return {
            e: $author$project$Rope$prependTo_fn(right, left),
            d: $elm$core$Maybe$Just(range)
        };
    }, $author$project$ParserFast$symbolFollowedBy_fn("(", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$ParserFast$followedBySymbol_fn(")", $author$project$ParserFast$symbolFollowedBy_fn("..", $author$project$Elm$Parser$Layout$maybeLayout)), { e: $author$project$Rope$empty, d: $elm$core$Maybe$Nothing }));
    var $author$project$Elm$Parser$Expose$exposable = $author$project$ParserFast$oneOf3_fn($author$project$Elm$Parser$Expose$functionExpose, $author$project$Elm$Parser$Expose$typeExpose, $author$project$Elm$Parser$Expose$infixExpose);
    var $author$project$Elm$Parser$Expose$exposingListInner = $author$project$ParserFast$oneOf2_fn($author$project$ParserFast$map3_fn_unwrapped(function (headElement, commentsAfterHeadElement, tailElements) {
        return {
            e: $author$project$Rope$prependTo_fn(tailElements.e, $author$project$Rope$prependTo_fn(commentsAfterHeadElement, headElement.e)),
            d: $author$project$Elm$Syntax$Exposing$Explicit(_List_Cons(headElement.d, tailElements.d))
        };
    }, $author$project$Elm$Parser$Expose$exposable, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserWithComments$many($author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$Elm$Parser$Layout$maybeAroundBothSides($author$project$Elm$Parser$Expose$exposable)))), $author$project$ParserFast$mapWithRange_fn_unwrapped(function (range, commentsAfterDotDot) {
        return {
            e: commentsAfterDotDot,
            d: $author$project$Elm$Syntax$Exposing$All(range)
        };
    }, $author$project$ParserFast$symbolFollowedBy_fn("..", $author$project$Elm$Parser$Layout$maybeLayout)));
    var $author$project$Elm$Parser$Expose$exposeDefinition = $author$project$ParserFast$map3WithRange_fn_unwrapped(function (range, commentsAfterExposing, commentsBefore, exposingListInnerResult) {
        return {
            e: $author$project$Rope$prependTo_fn(exposingListInnerResult.e, $author$project$Rope$prependTo_fn(commentsBefore, commentsAfterExposing)),
            d: $author$project$Elm$Syntax$Node$Node_fn(range, exposingListInnerResult.d)
        };
    }, $author$project$ParserFast$symbolFollowedBy_fn("exposing", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$ParserFast$symbolFollowedBy_fn("(", $author$project$Elm$Parser$Layout$optimisticLayout), $author$project$ParserFast$followedBySymbol_fn(")", $author$project$Elm$Parser$Expose$exposingListInner));
    var $author$project$ParserFast$map3OrSucceed_fn = function (func, _v0, _v1, _v2, fallback) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        return function (s0) {
            var _v3 = parseA(s0);
            if (_v3.$ === 1) {
                var c1 = _v3.a;
                var x = _v3.b;
                return c1 ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(fallback, s0);
            }
            else {
                var a = _v3.a;
                var s1 = _v3.b;
                var _v4 = parseB(s1);
                if (_v4.$ === 1) {
                    var x = _v4.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v4.a;
                    var s2 = _v4.b;
                    var _v5 = parseC(s2);
                    if (_v5.$ === 1) {
                        var x = _v5.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v5.a;
                        var s3 = _v5.b;
                        return $author$project$ParserFast$Good_fn(A3(func, a, b, c), s3);
                    }
                }
            }
        };
    }, $author$project$ParserFast$map3OrSucceed_fn_unwrapped = function (func, _v0, _v1, _v2, fallback) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        return function (s0) {
            var _v3 = parseA(s0);
            if (_v3.$ === 1) {
                var c1 = _v3.a;
                var x = _v3.b;
                return c1 ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(fallback, s0);
            }
            else {
                var a = _v3.a;
                var s1 = _v3.b;
                var _v4 = parseB(s1);
                if (_v4.$ === 1) {
                    var x = _v4.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v4.a;
                    var s2 = _v4.b;
                    var _v5 = parseC(s2);
                    if (_v5.$ === 1) {
                        var x = _v5.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v5.a;
                        var s3 = _v5.b;
                        return $author$project$ParserFast$Good_fn(func(a, b, c), s3);
                    }
                }
            }
        };
    }, $author$project$ParserFast$map3OrSucceed = F5($author$project$ParserFast$map3OrSucceed_fn);
    var $author$project$ParserFast$mapOrSucceed_fn = function (valueChange, _v0, fallback) {
        var parse = _v0;
        return function (s0) {
            var _v1 = parse(s0);
            if (!_v1.$) {
                var value = _v1.a;
                var s1 = _v1.b;
                return $author$project$ParserFast$Good_fn(valueChange(value), s1);
            }
            else {
                var firstCommitted = _v1.a;
                var x = _v1.b;
                return firstCommitted ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(fallback, s0);
            }
        };
    }, $author$project$ParserFast$mapOrSucceed = F3($author$project$ParserFast$mapOrSucceed_fn);
    var $author$project$ParserFast$loopWhileSucceedsFromRightToLeftStackUnsafeHelp_fn = function (element, initialFolded, reduce, s0) {
        var parseElement = element;
        var _v0 = parseElement(s0);
        if (!_v0.$) {
            var elementResult = _v0.a;
            var s1 = _v0.b;
            var _v1 = $author$project$ParserFast$loopWhileSucceedsFromRightToLeftStackUnsafeHelp_fn(element, initialFolded, reduce, s1);
            if (!_v1.$) {
                var tailFolded = _v1.a;
                var s2 = _v1.b;
                return $author$project$ParserFast$Good_fn(A2(reduce, elementResult, tailFolded), s2);
            }
            else {
                var tailBad = _v1;
                return tailBad;
            }
        }
        else {
            var elementCommitted = _v0.a;
            var x = _v0.b;
            return elementCommitted ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(initialFolded, s0);
        }
    }, $author$project$ParserFast$loopWhileSucceedsFromRightToLeftStackUnsafeHelp_fn_unwrapped = function (element, initialFolded, reduce, s0) {
        var parseElement = element;
        var _v0 = parseElement(s0);
        if (!_v0.$) {
            var elementResult = _v0.a;
            var s1 = _v0.b;
            var _v1 = $author$project$ParserFast$loopWhileSucceedsFromRightToLeftStackUnsafeHelp_fn_unwrapped(element, initialFolded, reduce, s1);
            if (!_v1.$) {
                var tailFolded = _v1.a;
                var s2 = _v1.b;
                return $author$project$ParserFast$Good_fn(reduce(elementResult, tailFolded), s2);
            }
            else {
                var tailBad = _v1;
                return tailBad;
            }
        }
        else {
            var elementCommitted = _v0.a;
            var x = _v0.b;
            return elementCommitted ? $author$project$ParserFast$Bad_fn(true, x) : $author$project$ParserFast$Good_fn(initialFolded, s0);
        }
    }, $author$project$ParserFast$loopWhileSucceedsFromRightToLeftStackUnsafeHelp = F4($author$project$ParserFast$loopWhileSucceedsFromRightToLeftStackUnsafeHelp_fn);
    var $author$project$ParserFast$loopWhileSucceedsRightToLeftStackUnsafe_fn = function (element, initialFolded, reduce) {
        return function (s) {
            return $author$project$ParserFast$loopWhileSucceedsFromRightToLeftStackUnsafeHelp_fn(element, initialFolded, reduce, s);
        };
    }, $author$project$ParserFast$loopWhileSucceedsRightToLeftStackUnsafe = F3($author$project$ParserFast$loopWhileSucceedsRightToLeftStackUnsafe_fn);
    var $author$project$Elm$Parser$Base$moduleName = $author$project$ParserFast$map2WithRange_fn_unwrapped(function (range, head, tail) {
        return $author$project$Elm$Syntax$Node$Node_fn(range, _List_Cons(head, tail));
    }, $author$project$Elm$Parser$Tokens$typeName, $author$project$ParserFast$loopWhileSucceedsRightToLeftStackUnsafe_fn($author$project$ParserFast$symbolFollowedBy_fn(".", $author$project$Elm$Parser$Tokens$typeName), _List_Nil, $elm$core$List$cons));
    var $author$project$Elm$Parser$Tokens$typeNameMapWithRange = function (rangeAndNameToRes) {
        return $author$project$ParserFast$ifFollowedByWhileMapWithRangeWithoutLinebreak_fn(rangeAndNameToRes, $author$project$Char$Extra$unicodeIsUpperFast, $author$project$Char$Extra$unicodeIsAlphaNumOrUnderscoreFast);
    };
    var $author$project$Elm$Parser$Imports$importDefinition = $author$project$ParserFast$map6WithStartLocation_fn_unwrapped(function (start, commentsAfterImport, mod, commentsAfterModuleName, maybeModuleAlias, maybeExposingList, commentsAfterEverything) {
        var modRange = mod.a;
        var endRange = function () {
            if (!maybeModuleAlias.$) {
                var moduleAliasValue = maybeModuleAlias.a;
                var _v3 = moduleAliasValue.d;
                var range = _v3.a;
                return range;
            }
            else {
                if (!maybeExposingList.$) {
                    var exposingListValue = maybeExposingList.a;
                    var _v5 = exposingListValue.d;
                    var range = _v5.a;
                    return range;
                }
                else {
                    return modRange;
                }
            }
        }();
        return {
            e: function () {
                var commentsBeforeAlias = $author$project$Rope$prependTo_fn(commentsAfterModuleName, commentsAfterImport);
                var commentsBeforeExposingList = function () {
                    if (maybeModuleAlias.$ === 1) {
                        return commentsBeforeAlias;
                    }
                    else {
                        var moduleAliasValue = maybeModuleAlias.a;
                        return $author$project$Rope$prependTo_fn(moduleAliasValue.e, commentsBeforeAlias);
                    }
                }();
                return $author$project$Rope$prependTo_fn(commentsAfterEverything, function () {
                    if (maybeExposingList.$ === 1) {
                        return commentsBeforeExposingList;
                    }
                    else {
                        var exposingListValue = maybeExposingList.a;
                        return $author$project$Rope$prependTo_fn(exposingListValue.e, commentsBeforeExposingList);
                    }
                }());
            }(),
            d: $author$project$Elm$Syntax$Node$Node_fn({ cm: endRange.cm, bE: start }, {
                ed: $elm$core$Maybe$map_fn(function ($) {
                    return $.d;
                }, maybeExposingList),
                eG: $elm$core$Maybe$map_fn(function ($) {
                    return $.d;
                }, maybeModuleAlias),
                eI: mod
            })
        };
    }, $author$project$ParserFast$keywordFollowedBy_fn("import", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Base$moduleName, $author$project$Elm$Parser$Layout$optimisticLayout, $author$project$ParserFast$map3OrSucceed_fn_unwrapped(function (commentsBefore, moduleAliasNode, commentsAfter) {
        return $elm$core$Maybe$Just({
            e: $author$project$Rope$prependTo_fn(commentsAfter, commentsBefore),
            d: moduleAliasNode
        });
    }, $author$project$ParserFast$keywordFollowedBy_fn("as", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Tokens$typeNameMapWithRange(F2(function (range, moduleAlias) {
        return $author$project$Elm$Syntax$Node$Node_fn(range, _List_fromArray([moduleAlias]));
    })), $author$project$Elm$Parser$Layout$optimisticLayout, $elm$core$Maybe$Nothing), $author$project$ParserFast$mapOrSucceed_fn($elm$core$Maybe$Just, $author$project$Elm$Parser$Expose$exposeDefinition, $elm$core$Maybe$Nothing), $author$project$Elm$Parser$Layout$optimisticLayout);
    var $author$project$Elm$Parser$Layout$endsTopIndented = function (parser) {
        return $author$project$ParserFast$validateEndColumnIndentation_fn_unwrapped(function (column, indent) {
            return !(column - indent);
        }, "must be on top indentation", parser);
    };
    var $author$project$Elm$Parser$Layout$layoutStrict = $author$project$Elm$Parser$Layout$endsTopIndented($author$project$Elm$Parser$Layout$optimisticLayout);
    var $author$project$Elm$Parser$Layout$layoutStrictFollowedByComments = function (nextParser) {
        return $author$project$ParserFast$map2_fn_unwrapped(function (commentsBefore, afterComments) {
            return $author$project$Rope$prependTo_fn(afterComments, commentsBefore);
        }, $author$project$Elm$Parser$Layout$optimisticLayout, $author$project$Elm$Parser$Layout$onTopIndentationFollowedBy(nextParser));
    };
    var $author$project$Elm$Syntax$Module$EffectModule = function (a) {
        return { $: 2, a: a };
    };
    var $author$project$Elm$Parser$Modules$effectWhereClause = $author$project$ParserFast$map4_fn_unwrapped(function (fnName, commentsAfterFnName, commentsAfterEqual, typeName_) {
        return {
            e: $author$project$Rope$prependTo_fn(commentsAfterEqual, commentsAfterFnName),
            d: _Utils_Tuple2(fnName, typeName_)
        };
    }, $author$project$Elm$Parser$Tokens$functionName, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserFast$symbolFollowedBy_fn("=", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Tokens$typeNameNode);
    var $author$project$List$Extra$find_fn = function (predicate, list) {
        find: while (true) {
            if (!list.b) {
                return $elm$core$Maybe$Nothing;
            }
            else {
                var x = list.a;
                var xs = list.b;
                if (predicate(x)) {
                    return $elm$core$Maybe$Just(x);
                }
                else {
                    var $temp$predicate = predicate, $temp$list = xs;
                    predicate = $temp$predicate;
                    list = $temp$list;
                    continue find;
                }
            }
        }
    }, $author$project$List$Extra$find = F2($author$project$List$Extra$find_fn);
    var $elm$core$Tuple$second = function (_v0) {
        var y = _v0.b;
        return y;
    };
    var $author$project$Elm$Parser$Modules$whereBlock = $author$project$ParserFast$followedBySymbol_fn("}", $author$project$ParserFast$symbolFollowedBy_fn("{", $author$project$ParserFast$map4_fn_unwrapped(function (commentsBeforeHead, head, commentsAfterHead, tail) {
        var pairs = _List_Cons(head.d, tail.d);
        return {
            e: $author$project$Rope$prependTo_fn(tail.e, $author$project$Rope$prependTo_fn(commentsAfterHead, $author$project$Rope$prependTo_fn(head.e, commentsBeforeHead))),
            d: {
                bP: $elm$core$Maybe$map_fn($elm$core$Tuple$second, $author$project$List$Extra$find_fn(function (_v0) {
                    var fnName = _v0.a;
                    return fnName === "command";
                }, pairs)),
                b7: $elm$core$Maybe$map_fn($elm$core$Tuple$second, $author$project$List$Extra$find_fn(function (_v1) {
                    var fnName = _v1.a;
                    return fnName === "subscription";
                }, pairs))
            }
        };
    }, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Modules$effectWhereClause, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$ParserWithComments$many($author$project$ParserFast$symbolFollowedBy_fn(",", $author$project$Elm$Parser$Layout$maybeAroundBothSides($author$project$Elm$Parser$Modules$effectWhereClause))))));
    var $author$project$Elm$Parser$Modules$effectWhereClauses = $author$project$ParserFast$map2_fn_unwrapped(function (commentsBefore, whereResult) {
        return {
            e: $author$project$Rope$prependTo_fn(whereResult.e, commentsBefore),
            d: whereResult.d
        };
    }, $author$project$ParserFast$keywordFollowedBy_fn("where", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Modules$whereBlock);
    var $author$project$ParserFast$map7WithRange_fn = function (func, _v0, _v1, _v2, _v3, _v4, _v5, _v6) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        var parseF = _v5;
        var parseG = _v6;
        return function (s0) {
            var _v7 = parseA(s0);
            if (_v7.$ === 1) {
                var committed = _v7.a;
                var x = _v7.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v7.a;
                var s1 = _v7.b;
                var _v8 = parseB(s1);
                if (_v8.$ === 1) {
                    var x = _v8.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v8.a;
                    var s2 = _v8.b;
                    var _v9 = parseC(s2);
                    if (_v9.$ === 1) {
                        var x = _v9.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v9.a;
                        var s3 = _v9.b;
                        var _v10 = parseD(s3);
                        if (_v10.$ === 1) {
                            var x = _v10.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v10.a;
                            var s4 = _v10.b;
                            var _v11 = parseE(s4);
                            if (_v11.$ === 1) {
                                var x = _v11.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v11.a;
                                var s5 = _v11.b;
                                var _v12 = parseF(s5);
                                if (_v12.$ === 1) {
                                    var x = _v12.b;
                                    return $author$project$ParserFast$Bad_fn(true, x);
                                }
                                else {
                                    var f = _v12.a;
                                    var s6 = _v12.b;
                                    var _v13 = parseG(s6);
                                    if (_v13.$ === 1) {
                                        var x = _v13.b;
                                        return $author$project$ParserFast$Bad_fn(true, x);
                                    }
                                    else {
                                        var g = _v13.a;
                                        var s7 = _v13.b;
                                        return $author$project$ParserFast$Good_fn(A8(func, {
                                            cm: { bk: s7.a, bz: s7.bz },
                                            bE: { bk: s0.a, bz: s0.bz }
                                        }, a, b, c, d, e, f, g), s7);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map7WithRange_fn_unwrapped = function (func, _v0, _v1, _v2, _v3, _v4, _v5, _v6) {
        var parseA = _v0;
        var parseB = _v1;
        var parseC = _v2;
        var parseD = _v3;
        var parseE = _v4;
        var parseF = _v5;
        var parseG = _v6;
        return function (s0) {
            var _v7 = parseA(s0);
            if (_v7.$ === 1) {
                var committed = _v7.a;
                var x = _v7.b;
                return $author$project$ParserFast$Bad_fn(committed, x);
            }
            else {
                var a = _v7.a;
                var s1 = _v7.b;
                var _v8 = parseB(s1);
                if (_v8.$ === 1) {
                    var x = _v8.b;
                    return $author$project$ParserFast$Bad_fn(true, x);
                }
                else {
                    var b = _v8.a;
                    var s2 = _v8.b;
                    var _v9 = parseC(s2);
                    if (_v9.$ === 1) {
                        var x = _v9.b;
                        return $author$project$ParserFast$Bad_fn(true, x);
                    }
                    else {
                        var c = _v9.a;
                        var s3 = _v9.b;
                        var _v10 = parseD(s3);
                        if (_v10.$ === 1) {
                            var x = _v10.b;
                            return $author$project$ParserFast$Bad_fn(true, x);
                        }
                        else {
                            var d = _v10.a;
                            var s4 = _v10.b;
                            var _v11 = parseE(s4);
                            if (_v11.$ === 1) {
                                var x = _v11.b;
                                return $author$project$ParserFast$Bad_fn(true, x);
                            }
                            else {
                                var e = _v11.a;
                                var s5 = _v11.b;
                                var _v12 = parseF(s5);
                                if (_v12.$ === 1) {
                                    var x = _v12.b;
                                    return $author$project$ParserFast$Bad_fn(true, x);
                                }
                                else {
                                    var f = _v12.a;
                                    var s6 = _v12.b;
                                    var _v13 = parseG(s6);
                                    if (_v13.$ === 1) {
                                        var x = _v13.b;
                                        return $author$project$ParserFast$Bad_fn(true, x);
                                    }
                                    else {
                                        var g = _v13.a;
                                        var s7 = _v13.b;
                                        return $author$project$ParserFast$Good_fn(func({
                                            cm: { bk: s7.a, bz: s7.bz },
                                            bE: { bk: s0.a, bz: s0.bz }
                                        }, a, b, c, d, e, f, g), s7);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
    }, $author$project$ParserFast$map7WithRange = F8($author$project$ParserFast$map7WithRange_fn);
    var $author$project$Elm$Parser$Modules$effectModuleDefinition = $author$project$ParserFast$map7WithRange_fn_unwrapped(function (range, commentsAfterEffect, commentsAfterModule, name, commentsAfterName, whereClauses, commentsAfterWhereClauses, exp) {
        return {
            e: $author$project$Rope$prependTo_fn(exp.e, $author$project$Rope$prependTo_fn(commentsAfterWhereClauses, $author$project$Rope$prependTo_fn(whereClauses.e, $author$project$Rope$prependTo_fn(commentsAfterName, $author$project$Rope$prependTo_fn(commentsAfterModule, commentsAfterEffect))))),
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Module$EffectModule({ bP: whereClauses.d.bP, ed: exp.d, eI: name, b7: whereClauses.d.b7 }))
        };
    }, $author$project$ParserFast$keywordFollowedBy_fn("effect", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$ParserFast$keywordFollowedBy_fn("module", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Base$moduleName, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Modules$effectWhereClauses, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expose$exposeDefinition);
    var $author$project$Elm$Syntax$Module$NormalModule = function (a) {
        return { $: 0, a: a };
    };
    var $author$project$Elm$Parser$Modules$normalModuleDefinition = $author$project$ParserFast$map4WithRange_fn_unwrapped(function (range, commentsAfterModule, moduleName, commentsAfterModuleName, exposingList) {
        return {
            e: $author$project$Rope$prependTo_fn(exposingList.e, $author$project$Rope$prependTo_fn(commentsAfterModuleName, commentsAfterModule)),
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Module$NormalModule({ ed: exposingList.d, eI: moduleName }))
        };
    }, $author$project$ParserFast$keywordFollowedBy_fn("module", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Base$moduleName, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expose$exposeDefinition);
    var $author$project$Elm$Syntax$Module$PortModule = function (a) {
        return { $: 1, a: a };
    };
    var $author$project$Elm$Parser$Modules$portModuleDefinition = $author$project$ParserFast$map5WithRange_fn_unwrapped(function (range, commentsAfterPort, commentsAfterModule, moduleName, commentsAfterModuleName, exposingList) {
        return {
            e: $author$project$Rope$prependTo_fn(exposingList.e, $author$project$Rope$prependTo_fn(commentsAfterModuleName, $author$project$Rope$prependTo_fn(commentsAfterModule, commentsAfterPort))),
            d: $author$project$Elm$Syntax$Node$Node_fn(range, $author$project$Elm$Syntax$Module$PortModule({ ed: exposingList.d, eI: moduleName }))
        };
    }, $author$project$ParserFast$keywordFollowedBy_fn("port", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$ParserFast$keywordFollowedBy_fn("module", $author$project$Elm$Parser$Layout$maybeLayout), $author$project$Elm$Parser$Base$moduleName, $author$project$Elm$Parser$Layout$maybeLayout, $author$project$Elm$Parser$Expose$exposeDefinition);
    var $author$project$Elm$Parser$Modules$moduleDefinition = $author$project$ParserFast$oneOf3_fn($author$project$Elm$Parser$Modules$normalModuleDefinition, $author$project$Elm$Parser$Modules$portModuleDefinition, $author$project$Elm$Parser$Modules$effectModuleDefinition);
    var $author$project$Elm$Parser$Comments$moduleDocumentation = $author$project$Elm$Parser$Comments$declarationDocumentation;
    var $author$project$Rope$ropeLikelyFilledToListInto_fn = function (initialAcc, ropeLikelyFilled) {
        ropeLikelyFilledToListInto: while (true) {
            if (!ropeLikelyFilled.$) {
                var onlyElement = ropeLikelyFilled.a;
                return _List_Cons(onlyElement, initialAcc);
            }
            else {
                var left = ropeLikelyFilled.a;
                var right = ropeLikelyFilled.b;
                var $temp$initialAcc = $author$project$Rope$ropeLikelyFilledToListInto_fn(initialAcc, right), $temp$ropeLikelyFilled = left;
                initialAcc = $temp$initialAcc;
                ropeLikelyFilled = $temp$ropeLikelyFilled;
                continue ropeLikelyFilledToListInto;
            }
        }
    }, $author$project$Rope$ropeLikelyFilledToListInto = F2($author$project$Rope$ropeLikelyFilledToListInto_fn);
    var $author$project$Rope$toList = function (rope) {
        if (rope.$ === 1) {
            return _List_Nil;
        }
        else {
            var ropeLikelyFilled = rope.a;
            return $author$project$Rope$ropeLikelyFilledToListInto_fn(_List_Nil, ropeLikelyFilled);
        }
    };
    var $author$project$Elm$Parser$File$file = $author$project$ParserFast$map4_fn_unwrapped(function (moduleDefinition, moduleComments, imports, declarations) {
        return {
            e: $author$project$Rope$toList($author$project$Rope$prependTo_fn(declarations.e, $author$project$Rope$prependTo_fn(imports.e, $author$project$Rope$prependTo_fn(moduleComments, moduleDefinition.e)))),
            bS: declarations.d,
            eq: imports.d,
            eH: moduleDefinition.d
        };
    }, $author$project$Elm$Parser$Layout$layoutStrictFollowedByWithComments($author$project$Elm$Parser$Modules$moduleDefinition), $author$project$Elm$Parser$Layout$layoutStrictFollowedByComments($author$project$ParserFast$map2OrSucceed_fn_unwrapped(function (moduleDocumentation, commentsAfter) {
        return $author$project$Rope$filledPrependTo_fn(commentsAfter, $author$project$Rope$one(moduleDocumentation));
    }, $author$project$Elm$Parser$Comments$moduleDocumentation, $author$project$Elm$Parser$Layout$layoutStrict, $author$project$Rope$empty)), $author$project$ParserWithComments$many($author$project$Elm$Parser$Imports$importDefinition), $author$project$Elm$Parser$File$fileDeclarations);
    var $elm$parser$Parser$ExpectingEnd = { $: 10 };
    var $elm$parser$Parser$ExpectingKeyword = function (a) {
        return { $: 9, a: a };
    };
    var $elm$parser$Parser$ExpectingNumber = { $: 6 };
    var $elm$parser$Parser$ExpectingSymbol = function (a) {
        return { $: 8, a: a };
    };
    var $elm$parser$Parser$Problem = function (a) {
        return { $: 12, a: a };
    };
    var $elm$parser$Parser$UnexpectedChar = { $: 11 };
    var $author$project$ParserFast$ropeFilledToList_fn = function (problemToConvert, soFar) {
        switch (problemToConvert.$) {
            case 7:
                var firstTry = problemToConvert.a;
                var secondTry = problemToConvert.b;
                var thirdTryUp = problemToConvert.c;
                return $author$project$ParserFast$ropeFilledToList_fn(firstTry, $author$project$ParserFast$ropeFilledToList_fn(secondTry, $elm$core$List$foldr_fn($author$project$ParserFast$ropeFilledToList, soFar, thirdTryUp)));
            case 0:
                var row = problemToConvert.a;
                var col = problemToConvert.b;
                return _List_Cons({ a: col, ak: $elm$parser$Parser$ExpectingNumber, bz: row }, soFar);
            case 1:
                var row = problemToConvert.a;
                var col = problemToConvert.b;
                var symbolString = problemToConvert.c;
                return _List_Cons({
                    a: col,
                    ak: $elm$parser$Parser$ExpectingSymbol(symbolString),
                    bz: row
                }, soFar);
            case 2:
                var row = problemToConvert.a;
                var col = problemToConvert.b;
                return _List_Cons({
                    a: col,
                    ak: $elm$parser$Parser$Problem("expecting any char"),
                    bz: row
                }, soFar);
            case 3:
                var row = problemToConvert.a;
                var col = problemToConvert.b;
                var keywordString = problemToConvert.c;
                return _List_Cons({
                    a: col,
                    ak: $elm$parser$Parser$ExpectingKeyword(keywordString),
                    bz: row
                }, soFar);
            case 4:
                var row = problemToConvert.a;
                var col = problemToConvert.b;
                return _List_Cons({ a: col, ak: $elm$parser$Parser$UnexpectedChar, bz: row }, soFar);
            case 5:
                var row = problemToConvert.a;
                var col = problemToConvert.b;
                return _List_Cons({
                    a: col,
                    ak: $elm$parser$Parser$Problem("expected string to pass validation"),
                    bz: row
                }, soFar);
            default:
                var row = problemToConvert.a;
                var col = problemToConvert.b;
                var customMessage = problemToConvert.c;
                return _List_Cons({
                    a: col,
                    ak: $elm$parser$Parser$Problem(customMessage),
                    bz: row
                }, soFar);
        }
    }, $author$project$ParserFast$ropeFilledToList = F2($author$project$ParserFast$ropeFilledToList_fn);
    var $author$project$ParserFast$run_fn = function (_v0, src) {
        var parse = _v0;
        var _v1 = parse({ a: 1, f: 1, b: 0, bz: 1, c: src });
        if (!_v1.$) {
            var value = _v1.a;
            var finalState = _v1.b;
            return (!(finalState.b - $elm$core$String$length(finalState.c))) ? $elm$core$Result$Ok(value) : $elm$core$Result$Err(_List_fromArray([
                { a: finalState.a, ak: $elm$parser$Parser$ExpectingEnd, bz: finalState.bz }
            ]));
        }
        else {
            var deadEnds = _v1.b;
            return $elm$core$Result$Err($author$project$ParserFast$ropeFilledToList_fn(deadEnds, _List_Nil));
        }
    }, $author$project$ParserFast$run = F2($author$project$ParserFast$run_fn);
    var $author$project$Elm$Parser$parseToFile = function (input) {
        return $author$project$ParserFast$run_fn($author$project$Elm$Parser$File$file, input);
    };
    var $author$project$Main$sampleFile = "\nmodule Simplify exposing\n    ( rule\n    , Configuration, defaults, expectNaN, ignoreCaseOfForTypes\n    )\n\n{-| Reports when an expression can be simplified.\n\n\uD83D\uDD27 Running with `--fix` will automatically remove all the reported errors.\n\n    config =\n        [ Simplify.rule Simplify.defaults\n        ]\n\n@docs rule\n@docs Configuration, defaults, expectNaN, ignoreCaseOfForTypes\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-simplify/example --rules Simplify\n```\n\n\n## Simplifications\n\nBelow is the list of all kinds of simplifications this rule applies.\n\n\n### Booleans\n\n    x || True\n    --> True\n\n    x || False\n    --> x\n\n    x && True\n    --> x\n\n    x && False\n    --> False\n\n    not True\n    --> False\n\n    not (not x)\n    --> x\n\n    -- for `<`, `>`, `<=`, `>=`, `==` and `/=`\n    not (a < b)\n    --> a >= b\n\n\n### Comparisons\n\n    x == True\n    --> x\n\n    x /= False\n    --> x\n\n    not x == not y\n    --> x == y\n\n    anything == anything\n    --> True\n\n    anything /= anything\n    --> False\n\n    { r | a = 1 } == { r | a = 2 }\n    --> False\n\n\n### If expressions\n\n    if True then x else y\n    --> x\n\n    if False then x else y\n    --> y\n\n    if condition then x else x\n    --> x\n\n    if condition then True else False\n    --> condition\n\n    if condition then False else True\n    --> not condition\n\n    a =\n        if condition then\n            if not condition then\n                1\n            else\n                2\n        else\n            3\n    --> if condition then 2 else 3\n\n\n### Case expressions\n\n    case condition of\n        True -> x\n        False -> y\n    --> if condition then x else y\n\n    case condition of\n        False -> y\n        True -> x\n    --> if not condition then x else y\n\n    -- only when no variables are introduced in the pattern\n    -- and no custom types defined in the project are referenced\n    case value of\n        Just _ -> x\n        Nothing -> x\n    --> x\n\nDestructuring using case expressions\n\n    case value of\n        ( x, y ) ->\n            x + y\n\n    -->\n    let\n        ( x, y ) =\n            value\n    in\n    x + y\n\n\n### Let expressions\n\n    let\n        a =\n            1\n    in\n    let\n        b =\n            1\n    in\n    a + b\n\n    -->\n    let\n        a =\n            1\n\n        b =\n            1\n    in\n    a + b\n\n\n### Record updates\n\n    { a | b = a.b }\n    --> a\n\n    { a | b = a.b, c = 1 }\n    --> { a | c = 1 }\n\n\n### Field access\n\n    { a = b }.a\n    --> b\n\n    { a | b = c }.b\n    --> c\n\n    { a | b = c }.d\n    --> a.d\n\n    (let a = b in c).d\n    --> let a = b in c.d\n\n\n### Basics functions\n\n    identity x\n    --> x\n\n    f >> identity\n    --> f\n\n    always x y\n    --> x\n\n    f >> always x\n    --> always x\n\n\n### Lambdas\n\n    (\\_ -> x) data\n    --> x\n\n    (\\() y -> x) ()\n    --> (\\y -> x)\n\n    (\\_ y -> x) data\n    --> (\\y -> x)\n\n\n### Operators\n\n    (++) a b\n    --> a ++ b\n\n    a |> f >> g\n    --> a |> f |> g\n\n\n### Numbers\n\n    n + 0\n    --> n\n\n    n - 0\n    --> n\n\n    0 - n\n    --> -n\n\n    n * 1\n    --> n\n\n    0 // n\n    --> 0\n\n    n // 0\n    --> 0\n\n    n // 1\n    --> n\n\n    n / 1\n    --> n\n\n    0 / n\n    --> 0\n\n    -(-n)\n    --> n\n\n    negate (negate n)\n    --> n\n\n    n - n\n    --> 0\n\n\n### Tuples\n\n    Tuple.pair a b\n    --> ( a, b )\n\n    Tuple.first ( a, b )\n    --> a\n\n    Tuple.second ( a, b )\n    --> b\n\n\n### Strings\n\n    \"a\" ++ \"\"\n    --> \"a\"\n\n    String.fromList []\n    --> \"\"\n\n    String.fromList [ a ]\n    --> String.fromChar a\n\n    String.fromList (String.toList str)\n    --> str\n\n    String.toList (String.fromList list)\n    --> list\n\n    String.isEmpty \"\"\n    --> True\n\n    String.isEmpty \"a\"\n    --> False\n\n    String.concat []\n    --> \"\"\n\n    String.append \"\" str\n    --> str\n\n    String.append (String.fromList [ a, b ]) (String.fromList [ c, d ])\n    --> String.fromList [ a, b, c, d ]\n\n    String.join str []\n    --> \"\"\n\n    String.join \"\" list\n    --> String.concat list\n\n    String.length \"abc\"\n    --> 3\n\n    String.repeat n \"\"\n    --> \"\"\n\n    String.repeat 0 str\n    --> \"\"\n\n    String.repeat 1 str\n    --> str\n\n    String.replace x y \"\"\n    --> \"\"\n\n    String.replace x x z\n    --> z\n\n    String.replace \"x\" \"y\" \"z\"\n    --> \"z\" -- only when resulting string is unchanged\n\n    String.words \"\"\n    --> []\n\n    String.lines \"\"\n    --> []\n\n    String.reverse \"\"\n    --> \"\"\n\n    String.reverse (String.fromChar a)\n    --> String.fromChar a\n\n    String.reverse (String.reverse str)\n    --> str\n\n    String.slice n n str\n    --> \"\"\n\n    String.slice n 0 str\n    --> \"\"\n\n    String.slice a z \"\"\n    --> \"\"\n\n    String.left 0 str\n    --> \"\"\n\n    String.left -1 str\n    --> \"\"\n\n    String.left n \"\"\n    --> \"\"\n\n    String.right 0 str\n    --> \"\"\n\n    String.right -1 str\n    --> \"\"\n\n    String.right n \"\"\n    --> \"\"\n\n    String.slice 2 1 str\n    --> \"\"\n\n    String.slice -1 -2 str\n    --> \"\"\n\n\n### Maybes\n\n    Maybe.map identity x\n    --> x\n\n    Maybe.map f Nothing\n    --> Nothing\n\n    Maybe.map f (Just x)\n    --> Just (f x)\n\n    Maybe.andThen f Nothing\n    --> Nothing\n\n    Maybe.andThen (always Nothing) x\n    --> Nothing\n\n    Maybe.andThen (\\a -> Just b) x\n    --> Maybe.map (\\a -> b) x\n\n    Maybe.andThen (\\a -> if condition a then Just b else Just c) x\n    --> Maybe.map (\\a -> if condition a then b else c) x\n\n    Maybe.andThen f (Just x)\n    --> f x\n\n    Maybe.withDefault x Nothing\n    --> x\n\n    Maybe.withDefault x (Just y)\n    --> y\n\n\n### Results\n\n    Result.map identity x\n    --> x\n\n    Result.map f (Err x)\n    --> Err x\n\n    Result.map f (Ok x)\n    --> Ok (f x)\n\n    -- the following simplifications for map3 work for all Result.mapN\n    Result.map3 f (Ok a) (Ok b) (Ok c)\n    --> Ok (f a b c)\n\n    Result.map3 f (Ok a) (Err x) thirdResult\n    --> Err x\n\n    Result.map3 f firstResult (Err x) thirdResult\n    --> Result.map2 f firstResult (Err x)\n\n    Result.mapError identity x\n    --> x\n\n    Result.mapError f (Ok x)\n    --> Ok x\n\n    Result.mapError f (Err x)\n    --> Err (f x)\n\n    Result.andThen f (Err x)\n    --> Err x\n\n    Result.andThen f (Ok x)\n    --> f x\n\n    Result.andThen (\\a -> Ok b) x\n    --> Result.map (\\a -> b) x\n\n    Result.withDefault x (Err y)\n    --> x\n\n    Result.withDefault x (Ok y)\n    --> y\n\n    Result.toMaybe (Ok x)\n    --> Just x\n\n    Result.toMaybe (Err e)\n    --> Nothing\n\n\n### Lists\n\n    a :: []\n    --> [ a ]\n\n    a :: [ b ]\n    --> [ a, b ]\n\n    [ a ] ++ list\n    --> a :: list\n\n    [] ++ list\n    --> list\n\n    [ a, b ] ++ [ c ]\n    --> [ a, b, c ]\n\n    List.append [] ys\n    --> ys\n\n    List.append [ a, b ] [ c ]\n    --> [ a, b, c ]\n\n    List.head []\n    --> Nothing\n\n    List.head (a :: bToZ)\n    --> Just a\n\n    List.tail []\n    --> Nothing\n\n    List.tail (a :: bToZ)\n    --> Just bToZ\n\n    List.member a []\n    --> False\n\n    List.member a [ a, b, c ]\n    --> True\n\n    List.member a [ b ]\n    --> a == b\n\n    List.map f [] -- same for most List functions like List.filter, List.filterMap, ...\n    --> []\n\n    List.map identity list\n    --> list\n\n    List.map f [ a ]\n    --> [ f a ]\n\n    List.filter (always True) list\n    --> list\n\n    List.filter (always False) list\n    --> []\n\n    List.filterMap Just list\n    --> list\n\n    List.filterMap (\\a -> if condition a then Just b else Just c) list\n    --> List.map (\\a -> if condition a then b else c) list\n\n    List.filterMap (always Nothing) list\n    --> []\n\n    List.filterMap identity (List.map f list)\n    --> List.filterMap f list\n\n    List.filterMap identity [ Just x, Just y ]\n    --> [ x, y ]\n\n    List.filterMap identity [ a, Nothing, b ]\n    --> List.filterMap identity [ a, b ]\n\n    List.concat [ [ a, b ], [ c ] ]\n    --> [ a, b, c ]\n\n    List.concat [ a, [ 1 ], [ 2 ] ]\n    --> List.concat [ a, [ 1, 2 ] ]\n\n    List.concat [ a, [], b ]\n    --> List.concat [ a, b ]\n\n    List.concatMap identity list\n    --> List.concat list\n\n    List.concatMap (\\a -> [ b ]) list\n    --> List.map (\\a -> b) list\n\n    List.concatMap f [ x ]\n    --> f x\n\n    List.concatMap (always []) list\n    --> []\n\n    List.concat (List.map f list)\n    --> List.concatMap f list\n\n    List.indexedMap (\\_ value -> f value) list\n    --> List.map (\\value -> f value) list\n\n    List.intersperse a []\n    --> []\n\n    List.intersperse s [ a ]\n    --> [ a ]\n\n    List.isEmpty []\n    --> True\n\n    List.isEmpty [ a ]\n    --> False\n\n    List.isEmpty (x :: xs)\n    --> False\n\n    List.sum []\n    --> 0\n\n    List.sum [ a ]\n    --> a\n\n    List.product []\n    --> 1\n\n    List.product [ a ]\n    --> a\n\n    List.minimum []\n    --> Nothing\n\n    List.minimum [ a ]\n    --> Just a\n\n    List.maximum []\n    --> Nothing\n\n    List.maximum [ a ]\n    --> Just a\n\n    -- The following simplifications for List.foldl also work for List.foldr\n    List.foldl f x []\n    --> x\n\n    List.foldl (\\_ soFar -> soFar) x list\n    --> x\n\n    List.foldl (+) 0 list\n    --> List.sum list\n\n    List.foldl (+) initial list\n    --> initial + List.sum list\n\n    List.foldl (*) 1 list\n    --> List.product list\n\n    List.foldl (*) 0 list\n    --> 0\n\n    List.foldl (*) initial list\n    --> initial * List.product list\n\n    List.foldl (&&) True list\n    --> List.all identity list\n\n    List.foldl (&&) False list\n    --> False\n\n    List.foldl (||) False list\n    --> List.any identity list\n\n    List.foldl (||) True list\n    --> True\n\n    List.all f []\n    --> True\n\n    List.all (always True) list\n    --> True\n\n    List.any f []\n    --> True\n\n    List.any (always False) list\n    --> False\n\n    List.any ((==) x) list\n    --> List.member x list\n\n    List.range 6 3\n    --> []\n\n    List.length [ a, b, c ]\n    --> 3\n\n    List.repeat 0 x\n    --> []\n\n    List.repeat 1 x\n    --> List.singleton x\n\n    List.partition f []\n    --> ( [], [] )\n\n    List.partition (always True) list\n    --> ( list, [] )\n\n    List.partition (always False) list\n    --> ( [], list )\n\n    List.take 0 list\n    --> []\n\n    List.drop 0 list\n    --> list\n\n    List.reverse []\n    --> []\n\n    List.reverse [ a ]\n    --> [ a ]\n\n    List.reverse (List.reverse list)\n    --> list\n\n    List.sortBy (always a) list\n    --> list\n\n    List.sortBy identity list\n    --> List.sort list\n\n    List.sortWith (\\_ _ -> LT) list\n    --> List.reverse list\n\n    List.sortWith (\\_ _ -> EQ) list\n    --> list\n\n    List.sortWith (\\_ _ -> GT) list\n    --> list\n\n    -- The following simplifications for List.sort also work for List.sortBy f and List.sortWith f\n    List.sort []\n    --> []\n\n    List.sort [ a ]\n    --> [ a ]\n\n    -- same for up to List.map5 when any list is empty\n    List.map2 f xs []\n    --> []\n\n    List.map2 f [] ys\n    --> []\n\n    List.unzip []\n    --> ( [], [] )\n\n\n### Arrays\n\n    Array.fromList []\n    --> Array.empty\n\n    Array.fromList (Array.toList array)\n    --> array\n\n    Array.toList (Array.fromList list)\n    --> list\n\n    Array.map f Array.empty -- same for Array.filter\n    --> Array.empty\n\n    Array.map identity array\n    --> array\n\n    Array.indexedMap (\\_ value -> f value) array\n    --> Array.map (\\value -> f value) array\n\n    Array.isEmpty Array.empty\n    --> True\n\n    Array.repeat 0 x\n    --> Array.empty\n\n    Array.initialize 0 f\n    --> Array.empty\n\n    Array.length Array.empty\n    --> 0\n\n    Array.length (Array.fromList [ a, b, c ])\n    --> 3\n\n    Array.length (Array.repeat 3 x)\n    --> 3\n\n    Array.length (Array.initialize 3 f)\n    --> 3\n\n    Array.length (Array.repeat n x)\n    --> max 0 n\n\n    Array.length (Array.initialize n f)\n    --> max 0 n\n\n    Array.append Array.empty array\n    --> array\n\n    Array.append (Array.fromList [ a, b ]) (Array.fromList [ c, d ])\n    --> Array.fromList [ a, b, c, d ]\n\n    Array.get n Array.empty\n    --> Nothing\n\n    Array.get 1 (Array.fromList [ a, b, c ])\n    --> Just b\n\n    Array.get 100 (Array.fromList [ a, b, c ])\n    --> Nothing\n\n    Array.get -1 array\n    --> Nothing\n\n    Array.set n x Array.empty\n    --> Array.empty\n\n    Array.set -1 x array\n    --> array\n\n    Array.set 1 x (Array.fromList [ a, b, c ])\n    --> Array.fromList [ a, x, c ]\n\n    Array.set 100 x (Array.fromList [ a, b, c ])\n    --> Array.fromList [ a, b, c ]\n\n\n### Sets\n\n    Set.fromList []\n    --> Set.empty\n\n    Set.fromList [ a ]\n    --> Set.singleton a\n\n    Set.fromList (Set.toList set)\n    --> set\n\n    Set.map f Set.empty -- same for Set.filter, Set.remove...\n    --> Set.empty\n\n    Set.map identity set\n    --> set\n\n    Set.isEmpty Set.empty\n    --> True\n\n    Set.member x Set.empty\n    --> False\n\n    Set.toList Set.empty\n    --> []\n\n    Set.length Set.empty\n    --> 0\n\n    Set.intersect Set.empty set\n    --> Set.empty\n\n    Set.diff Set.empty set\n    --> Set.empty\n\n    Set.diff set Set.empty\n    --> set\n\n    Set.union set Set.empty\n    --> set\n\n    Set.union (Set.fromList [ a, b ]) (Set.fromList [ c, d ])\n    --> Set.fromList [ a, b, c, d]\n\n    Set.insert x Set.empty\n    --> Set.singleton x\n\n    -- same for foldr\n    List.foldl f x (Set.toList set)\n    --> Set.foldl f x set\n\n    Set.partition f Set.empty\n    --> ( Set.empty, Set.empty )\n\n    Set.partition (always True) set\n    --> ( set, Set.empty )\n\n\n### Dict\n\n    Dict.fromList []\n    --> Dict.empty\n\n    Dict.fromList (Dict.toList dict)\n    --> dict\n\n    Dict.isEmpty Dict.empty\n    --> True\n\n    Dict.toList Dict.empty\n    --> []\n\n    Dict.size Dict.empty\n    --> 0\n\n    Dict.member x Dict.empty\n    --> False\n\n    Dict.intersect Dict.empty dict\n    --> Dict.empty\n\n    Dict.diff Dict.empty dict\n    --> Dict.empty\n\n    Dict.diff dict Dict.empty\n    --> dict\n\n    Dict.union dict Dict.empty\n    --> dict\n\n    Dict.union (Dict.fromList [ a, b ]) (Dict.fromList [ c, d ])\n    --> Dict.fromList [ c, d, a, b ]\n\n    Dict.partition f Dict.empty\n    --> ( Dict.empty, Dict.empty )\n\n    Dict.partition (always True) dict\n    --> ( dict, Dict.empty )\n\n    Dict.partition (always False) dict\n    --> ( Dict.empty, dict )\n\n    List.map Tuple.first (Dict.toList dict)\n    --> Dict.keys dict\n\n    List.map Tuple.second (Dict.toList dict)\n    --> Dict.values dict\n\n\n### Cmd / Sub\n\nAll of these also apply for `Sub`.\n\n    Cmd.batch []\n    --> Cmd.none\n\n    Cmd.batch [ a ]\n    --> a\n\n    Cmd.batch [ a, Cmd.none, b ]\n    --> Cmd.batch [ a, b ]\n\n    Cmd.map identity cmd\n    --> cmd\n\n    Cmd.map f Cmd.none\n    --> Cmd.none\n\n\n### Task\n\n    Task.map identity task\n    --> task\n\n    Task.map f (Task.fail x)\n    --> Task.fail x\n\n    Task.map f (Task.succeed a)\n    --> Task.succeed (f a)\n\n    -- the following simplifications for map3 work for all Task.mapN\n    Task.map3 f (Task.succeed a) (Task.succeed b) (Task.succeed c)\n    --> Task.succeed (f a b c)\n\n    Task.map3 f (Task.succeed a) (Task.fail x) thirdTask\n    --> Task.fail x\n\n    Task.map3 f firstTask (Task.fail x) thirdTask\n    --> Task.map2 f firstTask (Task.fail x)\n\n    Task.andThen f (Task.fail x)\n    --> Task.fail x\n\n    Task.andThen f (Task.succeed a)\n    --> f a\n\n    Task.andThen Task.succeed task\n    --> task\n\n    Task.andThen (\\a -> Task.succeed b) task\n    --> Task.map (\\a -> b) x\n\n    Task.mapError identity task\n    --> task\n\n    Task.mapError f (Task.succeed a)\n    --> Task.succeed a\n\n    Task.mapError f (Task.fail x)\n    --> Task.fail (f x)\n\n    Task.onError f (Task.succeed a)\n    --> Task.succeed a\n\n    Task.onError f (Task.fail x)\n    --> f x\n\n    Task.onError Task.fail task\n    --> task\n\n    Task.onError (\\x -> Task.fail y) task\n    --> Task.mapError (\\x -> y) x\n\n    Task.sequence [ Task.succeed a, Task.succeed b ]\n    --> Task.succeed [ a, b ]\n\n    Task.sequence [ Task.succeed a, Task.fail x ]\n    --> Task.fail x\n\n    Task.sequence [ a, Task.fail x, b ]\n    --> Task.sequence [ a, Task.fail x ]\n\n    Task.sequence [ task ]\n    --> Task.map List.singleton task\n\n\n### Html.Attributes\n\n    Html.Attributes.classList [ x, y, ( z, False ) ]\n    --> Html.Attributes.classList [ x, y ]\n\n    Html.Attributes.classList [ ( onlyOneThing, True ) ]\n    --> Html.Attributes.class onlyOneThing\n\n\n### Json.Decode\n\n    Json.Decode.oneOf [ a ]\n    --> a\n\n\n### Parser\n\n    Parser.oneOf [ a ]\n    --> a\n\n\n### Random\n\n    Random.uniform a []\n    --> Random.constant a\n\n    Random.weighted ( weight, a ) []\n    --> Random.constant a\n\n    Random.weighted tuple []\n    --> Random.constant (Tuple.first tuple)\n\n    Random.list 0 generator\n    --> Random.constant []\n\n    Random.list 1 generator\n    --> Random.map List.singleton generator\n\n    Random.list n (Random.constant el)\n    --> Random.constant (List.repeat n el)\n\n    Random.map identity generator\n    --> generator\n\n    Random.map (always a) generator\n    --> Random.constant a\n\n    Random.map f (Random.constant x)\n    --> Random.constant (f x)\n\n    Random.andThen f (Random.constant x)\n    --> f x\n\n    Random.andThen Random.constant generator\n    --> generator\n\n    Random.andThen (\\a -> Random.constant b) generator\n    --> Random.map (\\a -> b) generator\n\n    Random.andThen (always thenGenerator) generator\n    --> thenGenerator\n\n-}\n\nimport Dict exposing (Dict)\nimport Elm.Docs\nimport Elm.Project exposing (Exposed)\nimport Elm.Syntax.Declaration as Declaration exposing (Declaration)\nimport Elm.Syntax.Exposing as Exposing\nimport Elm.Syntax.Expression as Expression exposing (Expression)\nimport Elm.Syntax.Import exposing (Import)\nimport Elm.Syntax.Module\nimport Elm.Syntax.ModuleName exposing (ModuleName)\nimport Elm.Syntax.Node as Node exposing (Node(..))\nimport Elm.Syntax.Pattern as Pattern exposing (Pattern)\nimport Elm.Syntax.Range as Range exposing (Location, Range)\nimport Review.Fix as Fix exposing (Fix)\nimport Review.ModuleNameLookupTable as ModuleNameLookupTable exposing (ModuleNameLookupTable)\nimport Review.Project.Dependency as Dependency exposing (Dependency)\nimport Review.Rule as Rule exposing (Error, Rule)\nimport Set exposing (Set)\nimport Simplify.AstHelpers as AstHelpers exposing (emptyStringAsString, qualifiedToString)\nimport Simplify.Evaluate as Evaluate\nimport Simplify.Infer as Infer\nimport Simplify.Match as Match exposing (Match(..))\nimport Simplify.Normalize as Normalize\nimport Simplify.RangeDict as RangeDict exposing (RangeDict)\n\n\n{-| Rule to simplify Elm code.\n-}\nrule : Configuration -> Rule\nrule (Configuration config) =\n    Rule.newProjectRuleSchema \"Simplify\" initialContext\n        |> Rule.withDirectDependenciesProjectVisitor (dependenciesVisitor (Set.fromList config.ignoreConstructors))\n        |> Rule.withModuleVisitor (moduleVisitor config)\n        |> Rule.withContextFromImportedModules\n        |> Rule.withModuleContextUsingContextCreator\n            { fromProjectToModule = fromProjectToModule\n            , fromModuleToProject = fromModuleToProject\n            , foldProjectContexts = foldProjectContexts\n            }\n        |> Rule.providesFixesForProjectRule\n        |> Rule.fromProjectRuleSchema\n\n\nmoduleVisitor : { config | expectNaN : Bool } -> Rule.ModuleRuleSchema schemaState ModuleContext -> Rule.ModuleRuleSchema { schemaState | hasAtLeastOneVisitor : () } ModuleContext\nmoduleVisitor config schema =\n    schema\n        |> Rule.withCommentsVisitor (\\comments context -> ( [], commentsVisitor comments context ))\n        |> Rule.withDeclarationListVisitor (\\decls context -> ( [], declarationListVisitor decls context ))\n        |> Rule.withDeclarationEnterVisitor (\\node context -> ( [], declarationVisitor node context ))\n        |> Rule.withExpressionEnterVisitor (\\expressionNode context -> expressionVisitor expressionNode config context)\n        |> Rule.withExpressionExitVisitor (\\node context -> ( [], expressionExitVisitor node context ))\n\n\n\n-- CONFIGURATION\n\n\n{-| Configuration for this rule. Create a new one with [`defaults`](#defaults) and use [`ignoreCaseOfForTypes`](#ignoreCaseOfForTypes) to alter it.\n-}\ntype Configuration\n    = Configuration\n        { ignoreConstructors : List String\n        , expectNaN : Bool\n        }\n\n\n{-| Default configuration for this rule.\n\nThe rule aims tries to improve the code through simplifications that don't impact the behavior. An exception to this are\nwhen the presence of `NaN` values\n\nUse [`expectNaN`](#expectNaN) if you want to opt out of changes that can impact the behaviour of your code if you expect to work with `NaN` values.\n\nUse [`ignoreCaseOfForTypes`](#ignoreCaseOfForTypes) if you want to prevent simplifying case expressions that work on custom types defined in dependencies.\n\n    config =\n        [ Simplify.rule Simplify.defaults\n        ]\n\n    -- or\n    config =\n        [ Simplify.defaults\n            |> Simplify.expectNaN\n            |> Simplify.ignoreCaseOfForTypes [ \"Module.Name.Type\" ]\n            |> Simplify.rule\n        ]\n\n-}\ndefaults : Configuration\ndefaults =\n    Configuration\n        { ignoreConstructors = []\n        , expectNaN = False\n        }\n\n\n{-| Ignore some reports about types from dependencies used in case expressions.\n\nThis rule simplifies the following construct:\n\n    module Module.Name exposing (..)\n\n    case value of\n        Just _ -> x\n        Nothing -> x\n    --> x\n\n(Since `v2.0.19`) it will not try to simplify the case expression when some of the patterns references custom types constructors\ndefined in the project. It will only do so for custom types that are defined in dependencies (including `elm/core`).\n\nIf you do happen to want to disable this simplification for a type `Module.Name.Type`, you can configure the rule like this:\n\n    config =\n        [ Simplify.defaults\n            |> Simplify.ignoreCaseOfForTypes [ \"Module.Name.Type\" ]\n            |> Simplify.rule\n        ]\n\nI personally don't recommend to use this function too much, because this could be a sign of premature abstraction, and because\nI think that often [You Aren't Gonna Need this code](https://jfmengels.net/safe-dead-code-removal/#yagni-you-arent-gonna-need-it).\n\nPlease let me know by opening an issue if you do use this function, I am very curious to know;\n\n-}\nignoreCaseOfForTypes : List String -> Configuration -> Configuration\nignoreCaseOfForTypes ignoreConstructors (Configuration config) =\n    Configuration { ignoreConstructors = ignoreConstructors ++ config.ignoreConstructors, expectNaN = config.expectNaN }\n\n\n{-| Usually, `elm-review-simplify` will only suggest simplifications that are safe to apply without risk of changing the original behavior.\nHowever, when encountering [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN)\nvalues, some simplifications can actually impact behavior.\n\nFor instance, the following expression will evaluate to `True`:\n\n    x == x\n    --> True\n\nHowever, if `x` is `NaN` or a value containing `NaN` then the expression will evaluate to `False`:\n\n    -- given x = NaN\n    x == x\n    --> False\n\n    -- given x = { a = ( NaN, 0 ) }\n    x == x\n    --> False\n\nGiven the potential presence of `NaN`, some simplifications become unsafe to apply:\n\n  - `x == x` to `True`\n  - `List.member x [ x ]` to `True`\n  - `n * 0` to `0`\n\nThis special value is hard to recreate in Elm code both intentionally and unintentionally,\nand it's therefore unlikely to be found in your application,\nwhich is why the rule applies these simplifications by defaults.\n\nIf you somehow expect to create and encounter `NaN` values in your codebase, then you can use this function to disable these simplifications altogether.\n\n    config =\n        [ Simplify.defaults\n            |> Simplify.expectNaN\n            |> Simplify.rule\n        ]\n\n-}\nexpectNaN : Configuration -> Configuration\nexpectNaN (Configuration config) =\n    Configuration { ignoreConstructors = config.ignoreConstructors, expectNaN = True }\n\n\n\n-- CONTEXT\n\n\ntype alias ProjectContext =\n    { customTypesToReportInCases : Set ( ModuleName, ConstructorName )\n    , exposedVariants : Dict ModuleName (Set String)\n    }\n\n\ntype alias ModuleContext =\n    { lookupTable : ModuleNameLookupTable\n    , moduleName : ModuleName\n    , exposedVariantTypes : Exposed\n    , commentRanges : List Range\n    , moduleBindings : Set String\n    , localBindings : RangeDict (Set String)\n    , branchLocalBindings : RangeDict (Set String)\n    , rangesToIgnore : RangeDict ()\n    , rightSidesOfPlusPlus : RangeDict ()\n    , customTypesToReportInCases : Set ( ModuleName, ConstructorName )\n    , localIgnoredCustomTypes : List Constructor\n    , constructorsToIgnore : Set ( ModuleName, String )\n    , inferredConstantsDict : RangeDict Infer.Inferred\n    , inferredConstants : ( Infer.Inferred, List Infer.Inferred )\n    , extractSourceCode : Range -> String\n    , exposedVariants : Set String\n    , importLookup : ImportLookup\n    }\n\n\ntype alias ImportLookup =\n    Dict\n        ModuleName\n        { alias : Maybe ModuleName\n        , exposed : Exposed -- includes names of found variants\n        }\n\n\ntype alias QualifyResources a =\n    { a\n        | importLookup : ImportLookup\n        , moduleBindings : Set String\n        , localBindings : RangeDict (Set String)\n    }\n\n\ndefaultQualifyResources : QualifyResources {}\ndefaultQualifyResources =\n    { importLookup = implicitImports\n    , localBindings = RangeDict.empty\n    , moduleBindings = Set.empty\n    }\n\n\ntype Exposed\n    = ExposedAll\n    | ExposedSome (Set String)\n\n\nisExposedFrom : Exposed -> String -> Bool\nisExposedFrom exposed name =\n    case exposed of\n        ExposedAll ->\n            True\n\n        ExposedSome some ->\n            Set.member name some\n\n\ntype alias ConstructorName =\n    String\n\n\ntype alias Constructor =\n    { moduleName : ModuleName\n    , name : String\n    , constructors : List String\n    }\n\n\ninitialContext : ProjectContext\ninitialContext =\n    { customTypesToReportInCases = Set.empty\n    , exposedVariants = Dict.empty\n    }\n\n\nfromModuleToProject : Rule.ContextCreator ModuleContext ProjectContext\nfromModuleToProject =\n    Rule.initContextCreator\n        (\\moduleContext ->\n            { customTypesToReportInCases = Set.empty\n            , exposedVariants =\n                Dict.singleton moduleContext.moduleName\n                    moduleContext.exposedVariants\n            }\n        )\n\n\nfromProjectToModule : Rule.ContextCreator ProjectContext ModuleContext\nfromProjectToModule =\n    Rule.initContextCreator\n        (\\lookupTable metadata extractSourceCode fullAst projectContext ->\n            let\n                moduleExposedVariantTypes : Exposed\n                moduleExposedVariantTypes =\n                    moduleExposingContext fullAst.moduleDefinition\n\n                imports : ImportLookup\n                imports =\n                    List.foldl\n                        (\\import_ importLookup ->\n                            let\n                                importInfo : { moduleName : ModuleName, exposed : Exposed, alias : Maybe ModuleName }\n                                importInfo =\n                                    importContext import_\n                            in\n                            insertImport importInfo.moduleName { alias = importInfo.alias, exposed = importInfo.exposed } importLookup\n                        )\n                        implicitImports\n                        fullAst.imports\n            in\n            { lookupTable = lookupTable\n            , moduleName = Rule.moduleNameFromMetadata metadata\n            , exposedVariantTypes = moduleExposedVariantTypes\n            , importLookup =\n                createImportLookup\n                    { imports = imports\n                    , importExposedVariants = projectContext.exposedVariants\n                    }\n            , commentRanges = []\n            , moduleBindings = Set.empty\n            , localBindings = RangeDict.empty\n            , branchLocalBindings = RangeDict.empty\n            , rangesToIgnore = RangeDict.empty\n            , rightSidesOfPlusPlus = RangeDict.empty\n            , localIgnoredCustomTypes = []\n            , customTypesToReportInCases = projectContext.customTypesToReportInCases\n            , constructorsToIgnore = Set.empty\n            , inferredConstantsDict = RangeDict.empty\n            , inferredConstants = ( Infer.empty, [] )\n            , extractSourceCode = extractSourceCode\n            , exposedVariants = Set.empty\n            }\n        )\n        |> Rule.withModuleNameLookupTable\n        |> Rule.withMetadata\n        |> Rule.withSourceCodeExtractor\n        |> Rule.withFullAst\n\n\nimportContext : Node Import -> { moduleName : ModuleName, exposed : Exposed, alias : Maybe ModuleName }\nimportContext importNode =\n    let\n        import_ : Import\n        import_ =\n            Node.value importNode\n    in\n    { moduleName = import_.moduleName |> Node.value\n    , alias =\n        import_.moduleAlias |> Maybe.map Node.value\n    , exposed =\n        case import_.exposingList of\n            Nothing ->\n                ExposedSome Set.empty\n\n            Just (Node _ existingExposing) ->\n                case existingExposing of\n                    Exposing.All _ ->\n                        ExposedAll\n\n                    Exposing.Explicit exposes ->\n                        ExposedSome\n                            (Set.fromList\n                                (List.map\n                                    (\\(Node _ expose) -> AstHelpers.nameOfExpose expose)\n                                    exposes\n                                )\n                            )\n    }\n\n\ncreateImportLookup :\n    { imports : Dict ModuleName { alias : Maybe ModuleName, exposed : Exposed }\n    , importExposedVariants : Dict ModuleName (Set String)\n    }\n    -> ImportLookup\ncreateImportLookup context =\n    context.imports\n        |> Dict.map\n            (\\moduleName import_ ->\n                case import_.exposed of\n                    ExposedAll ->\n                        import_\n\n                    ExposedSome some ->\n                        case Dict.get moduleName context.importExposedVariants of\n                            Nothing ->\n                                import_\n\n                            Just importExposedVariants ->\n                                { import_\n                                    | exposed =\n                                        ExposedSome\n                                            (Set.union some importExposedVariants)\n                                }\n            )\n\n\nmoduleExposingContext : Node Elm.Syntax.Module.Module -> Exposed\nmoduleExposingContext moduleHeader =\n    case Elm.Syntax.Module.exposingList (Node.value moduleHeader) of\n        Exposing.All _ ->\n            ExposedAll\n\n        Exposing.Explicit some ->\n            ExposedSome\n                (List.foldl\n                    (\\(Node _ expose) acc ->\n                        case AstHelpers.getTypeExposeIncludingVariants expose of\n                            Just name ->\n                                Set.insert name acc\n\n                            Nothing ->\n                                acc\n                    )\n                    Set.empty\n                    some\n                )\n\n\nfoldProjectContexts : ProjectContext -> ProjectContext -> ProjectContext\nfoldProjectContexts newContext previousContext =\n    { customTypesToReportInCases = Set.empty\n    , exposedVariants = Dict.union newContext.exposedVariants previousContext.exposedVariants\n    }\n\n\n\n-- DEPENDENCIES VISITOR\n\n\ndependenciesVisitor : Set String -> Dict String Dependency -> ProjectContext -> ( List (Error scope), ProjectContext )\ndependenciesVisitor typeNamesAsStrings dict context =\n    let\n        modules : List Elm.Docs.Module\n        modules =\n            dict\n                |> Dict.values\n                |> List.concatMap Dependency.modules\n\n        unions : Set String\n        unions =\n            List.concatMap (\\module_ -> List.map (\\union -> module_.name ++ \".\" ++ union.name) module_.unions) modules\n                |> Set.fromList\n\n        unknownTypesToIgnore : List String\n        unknownTypesToIgnore =\n            Set.diff typeNamesAsStrings unions\n                |> Set.toList\n\n        customTypesToReportInCases : Set ( ModuleName, String )\n        customTypesToReportInCases =\n            modules\n                |> List.concatMap\n                    (\\mod ->\n                        let\n                            moduleName : ModuleName\n                            moduleName =\n                                AstHelpers.moduleNameFromString mod.name\n                        in\n                        mod.unions\n                            |> List.filter (\\union -> not (Set.member (mod.name ++ \".\" ++ union.name) typeNamesAsStrings))\n                            |> List.concatMap (\\union -> union.tags)\n                            |> List.map (\\( tagName, _ ) -> ( moduleName, tagName ))\n                    )\n                |> Set.fromList\n\n        dependencyExposedVariants : Dict ModuleName (Set String)\n        dependencyExposedVariants =\n            List.foldl\n                (\\moduleDoc acc ->\n                    Dict.insert\n                        (AstHelpers.moduleNameFromString moduleDoc.name)\n                        (moduleDoc.unions\n                            |> List.concatMap\n                                (\\union ->\n                                    union.tags\n                                        |> List.map (\\( variantName, _ ) -> variantName)\n                                )\n                            |> Set.fromList\n                        )\n                        acc\n                )\n                context.exposedVariants\n                modules\n    in\n    ( if List.isEmpty unknownTypesToIgnore then\n        []\n\n      else\n        [ errorForUnknownIgnoredConstructor unknownTypesToIgnore ]\n    , { customTypesToReportInCases = customTypesToReportInCases\n      , exposedVariants = dependencyExposedVariants\n      }\n    )\n\n\nerrorForUnknownIgnoredConstructor : List String -> Error scope\nerrorForUnknownIgnoredConstructor list =\n    Rule.globalError\n        { message = \"Could not find type names: \" ++ (String.join \", \" <| List.map wrapInBackticks list)\n        , details =\n            [ \"I expected to find these custom types in the dependencies, but I could not find them.\"\n            , \"Please check whether these types and have not been removed, and if so, remove them from the configuration of this rule.\"\n            , \"If you find that these types have been moved or renamed, please update your configuration.\"\n            , \"Note that I may have provided fixes for things you didn't wish to be fixed, so you might want to undo the changes I have applied.\"\n            , \"Also note that the configuration for this rule changed in v2.0.19: types that are custom to your project are ignored by default, so this configuration setting can only be used to avoid simplifying case expressions that use custom types defined in dependencies.\"\n            ]\n        }\n\n\n\n-- COMMENTS VISITOR\n\n\ncommentsVisitor : List (Node String) -> ModuleContext -> ModuleContext\ncommentsVisitor comments context =\n    { context | commentRanges = List.map Node.range comments }\n\n\n\n-- DECLARATION LIST VISITOR\n\n\ndeclarationListVisitor : List (Node Declaration) -> ModuleContext -> ModuleContext\ndeclarationListVisitor declarationList context =\n    { context\n        | moduleBindings = AstHelpers.declarationListBindings declarationList\n    }\n\n\n\n-- DECLARATION VISITOR\n\n\ndeclarationVisitor : Node Declaration -> ModuleContext -> ModuleContext\ndeclarationVisitor declarationNode context =\n    case Node.value declarationNode of\n        Declaration.CustomTypeDeclaration variantType ->\n            let\n                variantTypeName : String\n                variantTypeName =\n                    Node.value variantType.name\n            in\n            if isExposedFrom context.exposedVariantTypes variantTypeName then\n                let\n                    exposedVariants : Set String\n                    exposedVariants =\n                        List.foldl\n                            (\\(Node _ variant) acc -> Set.insert (Node.value variant.name) acc)\n                            context.exposedVariants\n                            variantType.constructors\n                in\n                { context | exposedVariants = exposedVariants }\n\n            else\n                context\n\n        Declaration.FunctionDeclaration functionDeclaration ->\n            { context\n                | rangesToIgnore = RangeDict.empty\n                , rightSidesOfPlusPlus = RangeDict.empty\n                , inferredConstantsDict = RangeDict.empty\n                , localBindings =\n                    RangeDict.singleton\n                        (Node.range functionDeclaration.declaration)\n                        (AstHelpers.patternListBindings (Node.value functionDeclaration.declaration).arguments)\n            }\n\n        _ ->\n            context\n\n\n\n-- EXPRESSION VISITOR\n\n\nexpressionVisitor : Node Expression -> { config | expectNaN : Bool } -> ModuleContext -> ( List (Error {}), ModuleContext )\nexpressionVisitor node config context =\n    let\n        expressionRange : Range\n        expressionRange =\n            Node.range node\n\n        contextWithInferredConstants : ModuleContext\n        contextWithInferredConstants =\n            case RangeDict.get expressionRange context.inferredConstantsDict of\n                Nothing ->\n                    context\n\n                Just inferredConstants ->\n                    let\n                        ( previous, previousStack ) =\n                            context.inferredConstants\n                    in\n                    { context\n                        | inferredConstants = ( inferredConstants, previous :: previousStack )\n                    }\n    in\n    if RangeDict.member expressionRange context.rangesToIgnore then\n        ( [], contextWithInferredConstants )\n\n    else\n        let\n            expression : Expression\n            expression =\n                Node.value node\n\n            withExpressionSurfaceBindings : RangeDict (Set String)\n            withExpressionSurfaceBindings =\n                RangeDict.insert expressionRange (expressionSurfaceBindings expression) context.localBindings\n\n            withNewBranchLocalBindings : RangeDict (Set String)\n            withNewBranchLocalBindings =\n                RangeDict.union (expressionBranchLocalBindings expression)\n                    context.branchLocalBindings\n\n            contextWithInferredConstantsAndLocalBindings : ModuleContext\n            contextWithInferredConstantsAndLocalBindings =\n                case RangeDict.get expressionRange context.branchLocalBindings of\n                    Nothing ->\n                        { contextWithInferredConstants\n                            | localBindings = withExpressionSurfaceBindings\n                            , branchLocalBindings =\n                                withNewBranchLocalBindings\n                        }\n\n                    Just currentBranchLocalBindings ->\n                        { contextWithInferredConstants\n                            | localBindings =\n                                RangeDict.insert expressionRange currentBranchLocalBindings withExpressionSurfaceBindings\n                            , branchLocalBindings =\n                                RangeDict.remove expressionRange withNewBranchLocalBindings\n                        }\n\n            expressionChecked : { error : Maybe (Error {}), rangesToIgnore : RangeDict (), rightSidesOfPlusPlus : RangeDict (), inferredConstants : List ( Range, Infer.Inferred ) }\n            expressionChecked =\n                expressionVisitorHelp node config contextWithInferredConstantsAndLocalBindings\n        in\n        ( expressionChecked.error |> maybeToList\n        , { contextWithInferredConstantsAndLocalBindings\n            | rangesToIgnore = RangeDict.union expressionChecked.rangesToIgnore context.rangesToIgnore\n            , rightSidesOfPlusPlus = RangeDict.union expressionChecked.rightSidesOfPlusPlus context.rightSidesOfPlusPlus\n            , inferredConstantsDict =\n                List.foldl (\\( range, constants ) acc -> RangeDict.insert range constants acc)\n                    contextWithInferredConstants.inferredConstantsDict\n                    expressionChecked.inferredConstants\n          }\n        )\n\n\n{-| From the `elm/core` readme:\n\n>\n> ### Default Imports\n\n> The modules in this package are so common, that some of them are imported by default in all Elm files. So it is as if every Elm file starts with these imports:\n>\n>     import Basics exposing (..)\n>     import List exposing (List, (::))\n>     import Maybe exposing (Maybe(..))\n>     import Result exposing (Result(..))\n>     import String exposing (String)\n>     import Char exposing (Char)\n>     import Tuple\n>     import Debug\n>     import Platform exposing (Program)\n>     import Platform.Cmd as Cmd exposing (Cmd)\n>     import Platform.Sub as Sub exposing (Sub)\n\n-}\nimplicitImports : ImportLookup\nimplicitImports =\n    [ ( [ \"Basics\" ], { alias = Nothing, exposed = ExposedAll } )\n    , ( [ \"List\" ], { alias = Nothing, exposed = ExposedSome (Set.fromList [ \"List\", \"(::)\" ]) } )\n    , ( [ \"Maybe\" ], { alias = Nothing, exposed = ExposedSome (Set.fromList [ \"Maybe\", \"Just\", \"Nothing\" ]) } )\n    , ( [ \"Result\" ], { alias = Nothing, exposed = ExposedSome (Set.fromList [ \"Result\", \"Ok\", \"Err\" ]) } )\n    , ( [ \"String\" ], { alias = Nothing, exposed = ExposedSome (Set.singleton \"String\") } )\n    , ( [ \"Char\" ], { alias = Nothing, exposed = ExposedSome (Set.singleton \"Char\") } )\n    , ( [ \"Tuple\" ], { alias = Nothing, exposed = ExposedSome Set.empty } )\n    , ( [ \"Debug\" ], { alias = Nothing, exposed = ExposedSome Set.empty } )\n    , ( [ \"Platform\" ], { alias = Nothing, exposed = ExposedSome (Set.singleton \"Program\") } )\n    , ( [ \"Platform\", \"Cmd\" ], { alias = Just [ \"Cmd\" ], exposed = ExposedSome (Set.singleton \"Cmd\") } )\n    , ( [ \"Platform\", \"Sub\" ], { alias = Just [ \"Sub\" ], exposed = ExposedSome (Set.singleton \"Sub\") } )\n    ]\n        |> Dict.fromList\n\n\n{-| Merge a given new import with an existing import lookup.\nThis is strongly preferred over Dict.insert since the implicit default imports can be overridden\n-}\ninsertImport : ModuleName -> { alias : Maybe ModuleName, exposed : Exposed } -> ImportLookup -> ImportLookup\ninsertImport moduleName importInfoToAdd importLookup =\n    Dict.update moduleName\n        (\\existingImport ->\n            let\n                newImportInfo : { alias : Maybe ModuleName, exposed : Exposed }\n                newImportInfo =\n                    case existingImport of\n                        Nothing ->\n                            importInfoToAdd\n\n                        Just import_ ->\n                            { alias = findMap .alias [ import_, importInfoToAdd ]\n                            , exposed = exposedMerge ( import_.exposed, importInfoToAdd.exposed )\n                            }\n            in\n            Just newImportInfo\n        )\n        importLookup\n\n\nexposedMerge : ( Exposed, Exposed ) -> Exposed\nexposedMerge exposedTuple =\n    case exposedTuple of\n        ( ExposedAll, _ ) ->\n            ExposedAll\n\n        ( ExposedSome _, ExposedAll ) ->\n            ExposedAll\n\n        ( ExposedSome aSet, ExposedSome bSet ) ->\n            ExposedSome (Set.union aSet bSet)\n\n\nqualify : ( ModuleName, String ) -> QualifyResources a -> ( ModuleName, String )\nqualify ( moduleName, name ) qualifyResources =\n    let\n        qualification : ModuleName\n        qualification =\n            case qualifyResources.importLookup |> Dict.get moduleName of\n                Nothing ->\n                    moduleName\n\n                Just import_ ->\n                    let\n                        moduleImportedName : ModuleName\n                        moduleImportedName =\n                            import_.alias |> Maybe.withDefault moduleName\n                    in\n                    if not (isExposedFrom import_.exposed name) then\n                        moduleImportedName\n\n                    else\n                        let\n                            isShadowed : Bool\n                            isShadowed =\n                                isBindingInScope qualifyResources name\n                        in\n                        if isShadowed then\n                            moduleImportedName\n\n                        else\n                            []\n    in\n    ( qualification, name )\n\n\nisBindingInScope :\n    { a\n        | moduleBindings : Set String\n        , localBindings : RangeDict (Set String)\n    }\n    -> String\n    -> Bool\nisBindingInScope resources name =\n    Set.member name resources.moduleBindings\n        || RangeDict.any (\\bindings -> Set.member name bindings) resources.localBindings\n\n\n{-| Whenever you add ranges on expression enter, the same ranges should be removed on expression exit.\nHaving one function finding unique ranges and a function for extracting bindings there ensures said consistency.\n\nAn alternative approach would be to use some kind of tree structure\nwith parent and sub ranges and bindings as leaves (maybe a \"trie\", tho I've not seen one as an elm package).\n\nRemoving all bindings for an expression's range on leave would then be trivial\n\n-}\nexpressionSurfaceBindings : Expression -> Set String\nexpressionSurfaceBindings expression =\n    case expression of\n        Expression.LambdaExpression lambda ->\n            AstHelpers.patternListBindings lambda.args\n\n        Expression.LetExpression letBlock ->\n            AstHelpers.letDeclarationListBindings letBlock.declarations\n\n        _ ->\n            Set.empty\n\n\nexpressionBranchLocalBindings : Expression -> RangeDict (Set String)\nexpressionBranchLocalBindings expression =\n    case expression of\n        Expression.CaseExpression caseBlock ->\n            RangeDict.mapFromList\n                (\\( Node _ pattern, Node resultRange _ ) ->\n                    ( resultRange\n                    , AstHelpers.patternBindings pattern\n                    )\n                )\n                caseBlock.cases\n\n        Expression.LetExpression letBlock ->\n            List.foldl\n                (\\(Node _ letDeclaration) acc ->\n                    case letDeclaration of\n                        Expression.LetFunction letFunctionOrValueDeclaration ->\n                            RangeDict.insert\n                                (Node.range (Node.value letFunctionOrValueDeclaration.declaration).expression)\n                                (AstHelpers.patternListBindings\n                                    (Node.value letFunctionOrValueDeclaration.declaration).arguments\n                                )\n                                acc\n\n                        _ ->\n                            acc\n                )\n                RangeDict.empty\n                letBlock.declarations\n\n        _ ->\n            RangeDict.empty\n\n\nexpressionExitVisitor : Node Expression -> ModuleContext -> ModuleContext\nexpressionExitVisitor (Node expressionRange _) context =\n    let\n        contextWithUpdatedLocalBindings : ModuleContext\n        contextWithUpdatedLocalBindings =\n            if RangeDict.member expressionRange context.rangesToIgnore then\n                context\n\n            else\n                { context\n                    | localBindings =\n                        RangeDict.remove expressionRange context.localBindings\n                }\n    in\n    if RangeDict.member expressionRange context.inferredConstantsDict then\n        case Tuple.second context.inferredConstants of\n            topOfStack :: restOfStack ->\n                { contextWithUpdatedLocalBindings | inferredConstants = ( topOfStack, restOfStack ) }\n\n            [] ->\n                -- should never be empty\n                contextWithUpdatedLocalBindings\n\n    else\n        contextWithUpdatedLocalBindings\n\n\nmaybeErrorAndRangesToIgnore : Maybe (Error {}) -> RangeDict () -> { error : Maybe (Error {}), rangesToIgnore : RangeDict (), rightSidesOfPlusPlus : RangeDict (), inferredConstants : List ( Range, Infer.Inferred ) }\nmaybeErrorAndRangesToIgnore maybeError rangesToIgnore =\n    { error = maybeError\n    , rangesToIgnore = rangesToIgnore\n    , rightSidesOfPlusPlus = RangeDict.empty\n    , inferredConstants = []\n    }\n\n\nonlyMaybeError : Maybe (Error {}) -> { error : Maybe (Error {}), rangesToIgnore : RangeDict (), rightSidesOfPlusPlus : RangeDict (), inferredConstants : List ( Range, Infer.Inferred ) }\nonlyMaybeError maybeError =\n    { error = maybeError\n    , rangesToIgnore = RangeDict.empty\n    , rightSidesOfPlusPlus = RangeDict.empty\n    , inferredConstants = []\n    }\n\n\nexpressionVisitorHelp : Node Expression -> { config | expectNaN : Bool } -> ModuleContext -> { error : Maybe (Error {}), rangesToIgnore : RangeDict (), rightSidesOfPlusPlus : RangeDict (), inferredConstants : List ( Range, Infer.Inferred ) }\nexpressionVisitorHelp (Node expressionRange expression) config context =\n    let\n        toCheckInfo :\n            { fnRange : Range\n            , fn : ( ModuleName, String )\n            , argCount : Int\n            , firstArg : Node Expression\n            , argsAfterFirst : List (Node Expression)\n            , callStyle : FunctionCallStyle\n            }\n            -> CheckInfo\n        toCheckInfo checkInfo =\n            let\n                ( parentRange, callStyle ) =\n                    case List.drop (checkInfo.argCount - 1) (checkInfo.firstArg :: checkInfo.argsAfterFirst) of\n                        lastExpectedArg :: _ :: _ ->\n                            -- Too many arguments!\n                            -- We'll update the range to drop the extra ones and force the call style to application\n                            ( case checkInfo.callStyle of\n                                Application ->\n                                    { start = checkInfo.fnRange.start, end = (Node.range lastExpectedArg).end }\n\n                                Pipe LeftToRight ->\n                                    { start = checkInfo.fnRange.start, end = (Node.range lastExpectedArg).end }\n\n                                Pipe RightToLeft ->\n                                    { start = (Node.range checkInfo.firstArg).start, end = (Node.range checkInfo.firstArg).end }\n                            , Application\n                            )\n\n                        -- [] | _ :: [] ->\n                        _ ->\n                            ( expressionRange, checkInfo.callStyle )\n\n                argsAfterFirst : List (Node Expression)\n                argsAfterFirst =\n                    -- Drop the extra arguments\n                    List.take (checkInfo.argCount - 1) checkInfo.argsAfterFirst\n            in\n            { lookupTable = context.lookupTable\n            , expectNaN = config.expectNaN\n            , extractSourceCode = context.extractSourceCode\n            , importLookup = context.importLookup\n            , commentRanges = context.commentRanges\n            , moduleBindings = context.moduleBindings\n            , localBindings = context.localBindings\n            , inferredConstants = context.inferredConstants\n            , parentRange = parentRange\n            , fnRange = checkInfo.fnRange\n            , fn = checkInfo.fn\n            , argCount = checkInfo.argCount\n            , firstArg = checkInfo.firstArg\n            , argsAfterFirst = argsAfterFirst\n            , secondArg = List.head argsAfterFirst\n            , thirdArg = List.head (List.drop 1 argsAfterFirst)\n            , callStyle = callStyle\n            }\n\n        toCompositionCheckInfo :\n            { direction : LeftOrRightDirection\n            , earlier : Node Expression\n            , later : Node Expression\n            , parentRange : Range\n            }\n            -> CompositionCheckInfo\n        toCompositionCheckInfo compositionSpecific =\n            { lookupTable = context.lookupTable\n            , importLookup = context.importLookup\n            , moduleBindings = context.moduleBindings\n            , localBindings = context.localBindings\n            , direction = compositionSpecific.direction\n            , parentRange = compositionSpecific.parentRange\n            , earlier = compositionSpecific.earlier\n            , later = compositionSpecific.later\n            }\n    in\n    case expression of\n        -----------------\n        -- APPLICATION --\n        -----------------\n        Expression.Application (applied :: firstArg :: argsAfterFirst) ->\n            onlyMaybeError\n                (case applied of\n                    Node fnRange (Expression.FunctionOrValue _ fnName) ->\n                        case ModuleNameLookupTable.moduleNameAt context.lookupTable fnRange of\n                            Just moduleName ->\n                                case Dict.get ( moduleName, fnName ) functionCallChecks of\n                                    Just ( argCount, checkFn ) ->\n                                        checkFn\n                                            (toCheckInfo\n                                                { fnRange = fnRange\n                                                , fn = ( moduleName, fnName )\n                                                , argCount = argCount\n                                                , firstArg = firstArg\n                                                , argsAfterFirst = argsAfterFirst\n                                                , callStyle = Application\n                                                }\n                                            )\n\n                                    Nothing ->\n                                        Nothing\n\n                            Nothing ->\n                                Nothing\n\n                    Node _ (Expression.ParenthesizedExpression (Node lambdaRange (Expression.LambdaExpression lambda))) ->\n                        appliedLambdaError\n                            { nodeRange = expressionRange\n                            , lambdaRange = lambdaRange\n                            , lambda = lambda\n                            }\n\n                    Node operatorRange (Expression.PrefixOperator operator) ->\n                        case argsAfterFirst of\n                            right :: [] ->\n                                Just\n                                    (fullyAppliedPrefixOperatorError\n                                        { operator = operator\n                                        , operatorRange = operatorRange\n                                        , left = firstArg\n                                        , right = right\n                                        }\n                                    )\n\n                            _ ->\n                                Nothing\n\n                    _ ->\n                        Nothing\n                )\n\n        ----------\n        -- (<|) --\n        ----------\n        Expression.OperatorApplication \"<|\" _ pipedInto lastArg ->\n            case pipedInto of\n                Node fnRange (Expression.FunctionOrValue _ fnName) ->\n                    onlyMaybeError\n                        (case ModuleNameLookupTable.moduleNameAt context.lookupTable fnRange of\n                            Just moduleName ->\n                                case Dict.get ( moduleName, fnName ) functionCallChecks of\n                                    Just ( argCount, checkFn ) ->\n                                        checkFn\n                                            (toCheckInfo\n                                                { fnRange = fnRange\n                                                , fn = ( moduleName, fnName )\n                                                , argCount = argCount\n                                                , firstArg = lastArg\n                                                , argsAfterFirst = []\n                                                , callStyle = Pipe RightToLeft\n                                                }\n                                            )\n\n                                    Nothing ->\n                                        Nothing\n\n                            Nothing ->\n                                Nothing\n                        )\n\n                Node applicationRange (Expression.Application ((Node fnRange (Expression.FunctionOrValue _ fnName)) :: firstArg :: argsBetweenFirstAndLast)) ->\n                    case ModuleNameLookupTable.moduleNameAt context.lookupTable fnRange of\n                        Just moduleName ->\n                            case Dict.get ( moduleName, fnName ) functionCallChecks of\n                                Just ( argCount, checkFn ) ->\n                                    maybeErrorAndRangesToIgnore\n                                        (checkFn\n                                            (toCheckInfo\n                                                { fnRange = fnRange\n                                                , argCount = argCount\n                                                , fn = ( moduleName, fnName )\n                                                , firstArg = firstArg\n                                                , argsAfterFirst = argsBetweenFirstAndLast ++ [ lastArg ]\n                                                , callStyle = Pipe RightToLeft\n                                                }\n                                            )\n                                        )\n                                        (RangeDict.singleton applicationRange ())\n\n                                Nothing ->\n                                    onlyMaybeError Nothing\n\n                        Nothing ->\n                            onlyMaybeError Nothing\n\n                pipedIntoOther ->\n                    onlyMaybeError\n                        (pipelineChecks\n                            { commentRanges = context.commentRanges\n                            , extractSourceCode = context.extractSourceCode\n                            , direction = RightToLeft\n                            , nodeRange = expressionRange\n                            , pipedInto = pipedIntoOther\n                            , arg = lastArg\n                            }\n                        )\n\n        ----------\n        -- (|>) --\n        ----------\n        Expression.OperatorApplication \"|>\" _ lastArg pipedInto ->\n            case pipedInto of\n                Node fnRange (Expression.FunctionOrValue _ fnName) ->\n                    onlyMaybeError\n                        (case ModuleNameLookupTable.moduleNameAt context.lookupTable fnRange of\n                            Just moduleName ->\n                                case Dict.get ( moduleName, fnName ) functionCallChecks of\n                                    Just ( argCount, checks ) ->\n                                        checks\n                                            (toCheckInfo\n                                                { fnRange = fnRange\n                                                , fn = ( moduleName, fnName )\n                                                , argCount = argCount\n                                                , firstArg = lastArg\n                                                , argsAfterFirst = []\n                                                , callStyle = Pipe LeftToRight\n                                                }\n                                            )\n\n                                    Nothing ->\n                                        Nothing\n\n                            Nothing ->\n                                Nothing\n                        )\n\n                Node applicationRange (Expression.Application ((Node fnRange (Expression.FunctionOrValue _ fnName)) :: firstArg :: argsBetweenFirstAndLast)) ->\n                    case ModuleNameLookupTable.moduleNameAt context.lookupTable fnRange of\n                        Just moduleName ->\n                            case Dict.get ( moduleName, fnName ) functionCallChecks of\n                                Just ( argCount, checks ) ->\n                                    maybeErrorAndRangesToIgnore\n                                        (checks\n                                            (toCheckInfo\n                                                { fnRange = fnRange\n                                                , fn = ( moduleName, fnName )\n                                                , argCount = argCount\n                                                , firstArg = firstArg\n                                                , argsAfterFirst = argsBetweenFirstAndLast ++ [ lastArg ]\n                                                , callStyle = Pipe LeftToRight\n                                                }\n                                            )\n                                        )\n                                        (RangeDict.singleton applicationRange ())\n\n                                Nothing ->\n                                    onlyMaybeError Nothing\n\n                        Nothing ->\n                            onlyMaybeError Nothing\n\n                pipedIntoOther ->\n                    onlyMaybeError\n                        (pipelineChecks\n                            { commentRanges = context.commentRanges\n                            , extractSourceCode = context.extractSourceCode\n                            , direction = LeftToRight\n                            , nodeRange = expressionRange\n                            , pipedInto = pipedIntoOther\n                            , arg = lastArg\n                            }\n                        )\n\n        ----------\n        -- (>>) --\n        ----------\n        Expression.OperatorApplication \">>\" _ earlier composedLater ->\n            let\n                ( later, parentRange ) =\n                    case composedLater of\n                        Node _ (Expression.OperatorApplication \">>\" _ later_ _) ->\n                            ( later_, { start = (Node.range earlier).start, end = (Node.range later_).end } )\n\n                        endLater ->\n                            ( endLater, expressionRange )\n            in\n            onlyMaybeError\n                (firstThatConstructsJust compositionChecks\n                    (toCompositionCheckInfo\n                        { direction = LeftToRight\n                        , parentRange = parentRange\n                        , earlier = earlier\n                        , later = later\n                        }\n                    )\n                )\n\n        ----------\n        -- (<<) --\n        ----------\n        Expression.OperatorApplication \"<<\" _ composedLater earlier ->\n            let\n                ( later, parentRange ) =\n                    case composedLater of\n                        Node _ (Expression.OperatorApplication \"<<\" _ _ later_) ->\n                            ( later_, { start = (Node.range later_).start, end = (Node.range earlier).end } )\n\n                        endLater ->\n                            ( endLater, expressionRange )\n            in\n            onlyMaybeError\n                (firstThatConstructsJust compositionChecks\n                    (toCompositionCheckInfo\n                        { direction = RightToLeft\n                        , parentRange = parentRange\n                        , earlier = earlier\n                        , later = later\n                        }\n                    )\n                )\n\n        ---------------------\n        -- OTHER OPERATION --\n        ---------------------\n        Expression.OperatorApplication operator _ left right ->\n            case Dict.get operator operatorApplicationChecks of\n                Just checkFn ->\n                    { error =\n                        let\n                            leftRange : Range\n                            leftRange =\n                                Node.range left\n\n                            rightRange : Range\n                            rightRange =\n                                Node.range right\n                        in\n                        checkFn\n                            { lookupTable = context.lookupTable\n                            , extractSourceCode = context.extractSourceCode\n                            , expectNaN = config.expectNaN\n                            , importLookup = context.importLookup\n                            , moduleBindings = context.moduleBindings\n                            , localBindings = context.localBindings\n                            , inferredConstants = context.inferredConstants\n                            , parentRange = expressionRange\n                            , operator = operator\n                            , operatorRange =\n                                findOperatorRange\n                                    { operator = operator\n                                    , commentRanges = context.commentRanges\n                                    , extractSourceCode = context.extractSourceCode\n                                    , leftRange = leftRange\n                                    , rightRange = rightRange\n                                    }\n                            , left = left\n                            , leftRange = leftRange\n                            , right = right\n                            , rightRange = rightRange\n                            , isOnTheRightSideOfPlusPlus = RangeDict.member expressionRange context.rightSidesOfPlusPlus\n                            }\n                    , rangesToIgnore = RangeDict.empty\n                    , rightSidesOfPlusPlus =\n                        case operator of\n                            \"++\" ->\n                                RangeDict.singleton (Node.range (AstHelpers.removeParens right)) ()\n\n                            _ ->\n                                RangeDict.empty\n                    , inferredConstants = []\n                    }\n\n                Nothing ->\n                    onlyMaybeError Nothing\n\n        --------------\n        -- NEGATION --\n        --------------\n        Expression.Negation negatedExpression ->\n            onlyMaybeError\n                (negationChecks { parentRange = expressionRange, negatedExpression = negatedExpression })\n\n        -------------------\n        -- RECORD ACCESS --\n        -------------------\n        Expression.RecordAccess record (Node fieldRange fieldName) ->\n            let\n                dotFieldRange : Range\n                dotFieldRange =\n                    { start = (Node.range record).end, end = fieldRange.end }\n\n                maybeErrorInfoAndFix : Maybe ErrorInfoAndFix\n                maybeErrorInfoAndFix =\n                    case Node.value (AstHelpers.removeParens record) of\n                        Expression.RecordExpr setters ->\n                            recordAccessChecks\n                                { nodeRange = expressionRange\n                                , maybeRecordNameRange = Nothing\n                                , fieldName = fieldName\n                                , setters = setters\n                                }\n\n                        Expression.RecordUpdateExpression (Node recordNameRange _) setters ->\n                            recordAccessChecks\n                                { nodeRange = expressionRange\n                                , maybeRecordNameRange = Just recordNameRange\n                                , fieldName = fieldName\n                                , setters = setters\n                                }\n\n                        Expression.LetExpression letIn ->\n                            Just (injectRecordAccessIntoLetExpression dotFieldRange letIn.expression fieldName)\n\n                        Expression.IfBlock _ thenBranch elseBranch ->\n                            distributeFieldAccess \"an if/then/else\" dotFieldRange [ thenBranch, elseBranch ] fieldName\n\n                        Expression.CaseExpression caseOf ->\n                            distributeFieldAccess \"a case/of\" dotFieldRange (List.map Tuple.second caseOf.cases) fieldName\n\n                        _ ->\n                            Nothing\n            in\n            onlyMaybeError\n                (maybeErrorInfoAndFix\n                    |> Maybe.map (\\e -> Rule.errorWithFix e.info dotFieldRange e.fix)\n                )\n\n        --------\n        -- IF --\n        --------\n        Expression.IfBlock condition trueBranch falseBranch ->\n            let\n                ifCheckInfo : IfCheckInfo\n                ifCheckInfo =\n                    { nodeRange = expressionRange\n                    , condition = condition\n                    , trueBranch = trueBranch\n                    , falseBranch = falseBranch\n                    , lookupTable = context.lookupTable\n                    , inferredConstants = context.inferredConstants\n                    , importLookup = context.importLookup\n                    , moduleBindings = context.moduleBindings\n                    , localBindings = context.localBindings\n                    }\n            in\n            case ifChecks ifCheckInfo of\n                Just ifErrors ->\n                    maybeErrorAndRangesToIgnore (Just ifErrors.errors) ifErrors.rangesToIgnore\n\n                Nothing ->\n                    { error = Nothing\n                    , rangesToIgnore = RangeDict.empty\n                    , rightSidesOfPlusPlus = RangeDict.empty\n                    , inferredConstants =\n                        Infer.inferForIfCondition\n                            (Node.value (Normalize.normalize context condition))\n                            { trueBranchRange = Node.range trueBranch\n                            , falseBranchRange = Node.range falseBranch\n                            }\n                            (Tuple.first context.inferredConstants)\n                    }\n\n        -------------\n        -- CASE OF --\n        -------------\n        Expression.CaseExpression caseBlock ->\n            onlyMaybeError\n                (firstThatConstructsJust caseOfChecks\n                    { lookupTable = context.lookupTable\n                    , extractSourceCode = context.extractSourceCode\n                    , customTypesToReportInCases = context.customTypesToReportInCases\n                    , inferredConstants = context.inferredConstants\n                    , parentRange = expressionRange\n                    , caseOf = caseBlock\n                    }\n                )\n\n        ------------\n        -- LET IN --\n        ------------\n        Expression.LetExpression caseBlock ->\n            onlyMaybeError (letInChecks caseBlock)\n\n        -------------------\n        -- RECORD UPDATE --\n        -------------------\n        Expression.RecordUpdateExpression variable fields ->\n            onlyMaybeError (recordUpdateChecks expressionRange variable fields)\n\n        --------------------\n        -- NOT SIMPLIFIED --\n        --------------------\n        Expression.UnitExpr ->\n            onlyMaybeError Nothing\n\n        Expression.CharLiteral _ ->\n            onlyMaybeError Nothing\n\n        Expression.Integer _ ->\n            onlyMaybeError Nothing\n\n        Expression.Hex _ ->\n            onlyMaybeError Nothing\n\n        Expression.Floatable _ ->\n            onlyMaybeError Nothing\n\n        Expression.Literal _ ->\n            onlyMaybeError Nothing\n\n        Expression.GLSLExpression _ ->\n            onlyMaybeError Nothing\n\n        Expression.PrefixOperator _ ->\n            onlyMaybeError Nothing\n\n        Expression.RecordAccessFunction _ ->\n            onlyMaybeError Nothing\n\n        Expression.FunctionOrValue _ _ ->\n            onlyMaybeError Nothing\n\n        Expression.ParenthesizedExpression _ ->\n            onlyMaybeError Nothing\n\n        Expression.TupledExpression _ ->\n            onlyMaybeError Nothing\n\n        Expression.ListExpr _ ->\n            onlyMaybeError Nothing\n\n        Expression.RecordExpr _ ->\n            onlyMaybeError Nothing\n\n        Expression.LambdaExpression _ ->\n            onlyMaybeError Nothing\n\n        ----------------------\n        -- IMPOSSIBLE CASES --\n        ----------------------\n        Expression.Operator _ ->\n            onlyMaybeError Nothing\n\n        Expression.Application [] ->\n            onlyMaybeError Nothing\n\n        Expression.Application (_ :: []) ->\n            onlyMaybeError Nothing\n\n\ntype alias CheckInfo =\n    { lookupTable : ModuleNameLookupTable\n    , expectNaN : Bool\n    , importLookup : ImportLookup\n    , extractSourceCode : Range -> String\n    , commentRanges : List Range\n    , moduleBindings : Set String\n    , localBindings : RangeDict (Set String)\n    , inferredConstants : ( Infer.Inferred, List Infer.Inferred )\n    , parentRange : Range\n    , fnRange : Range\n    , fn : ( ModuleName, String )\n    , argCount : Int\n    , callStyle : FunctionCallStyle\n    , firstArg : Node Expression\n    , argsAfterFirst : List (Node Expression)\n\n    -- stored for quick access since usage is very common\n    -- prefer using secondArg and thirdArg functions\n    -- because the optimization could change in the future\n    , secondArg : Maybe (Node Expression)\n    , thirdArg : Maybe (Node Expression)\n    }\n\n\n{-| How an argument is given as input to a function:\n\n  - `Pipe RightToLeft`: `function <| argument`\n  - `Pipe LeftToRight`: `argument |> function`\n  - `Application`: `function argument`\n\n-}\ntype FunctionCallStyle\n    = Application\n    | Pipe LeftOrRightDirection\n\n\ntype LeftOrRightDirection\n    = RightToLeft\n    | LeftToRight\n\n\nsecondArg : CheckInfo -> Maybe (Node Expression)\nsecondArg checkInfo =\n    checkInfo.secondArg\n\n\nthirdArg : CheckInfo -> Maybe (Node Expression)\nthirdArg checkInfo =\n    checkInfo.thirdArg\n\n\ntype alias ErrorInfoAndFix =\n    { info : { message : String, details : List String }\n    , fix : List Fix\n    }\n\n\nfunctionCallChecks : Dict ( ModuleName, String ) ( Int, CheckInfo -> Maybe (Error {}) )\nfunctionCallChecks =\n    -- The number of arguments is used to determine how many arguments to pass to the check function.\n    -- This corresponds to the number of arguments that the function to check is expected to have.\n    -- Any additional arguments will be ignored in order to avoid removing too many arguments\n    -- when replacing the entire argument, which is quite common.\n    Dict.fromList\n        [ ( ( [ \"Basics\" ], \"identity\" ), ( 1, basicsIdentityChecks ) )\n        , ( ( [ \"Basics\" ], \"always\" ), ( 2, basicsAlwaysChecks ) )\n        , ( ( [ \"Basics\" ], \"not\" ), ( 1, basicsNotChecks ) )\n        , ( ( [ \"Basics\" ], \"negate\" ), ( 1, basicsNegateChecks ) )\n        , ( ( [ \"Tuple\" ], \"first\" ), ( 1, tupleFirstChecks ) )\n        , ( ( [ \"Tuple\" ], \"second\" ), ( 1, tupleSecondChecks ) )\n        , ( ( [ \"Tuple\" ], \"pair\" ), ( 2, tuplePairChecks ) )\n        , ( ( [ \"Maybe\" ], \"map\" ), ( 2, maybeMapChecks ) )\n        , ( ( [ \"Maybe\" ], \"andThen\" ), ( 2, maybeAndThenChecks ) )\n        , ( ( [ \"Maybe\" ], \"withDefault\" ), ( 2, withDefaultChecks maybeWithJustAsWrap ) )\n        , ( ( [ \"Result\" ], \"map\" ), ( 2, resultMapChecks ) )\n        , ( ( [ \"Result\" ], \"map2\" ), ( 3, resultMapNChecks { n = 2 } ) )\n        , ( ( [ \"Result\" ], \"map3\" ), ( 4, resultMapNChecks { n = 3 } ) )\n        , ( ( [ \"Result\" ], \"map4\" ), ( 5, resultMapNChecks { n = 4 } ) )\n        , ( ( [ \"Result\" ], \"map5\" ), ( 6, resultMapNChecks { n = 5 } ) )\n        , ( ( [ \"Result\" ], \"mapError\" ), ( 2, resultMapErrorChecks ) )\n        , ( ( [ \"Result\" ], \"andThen\" ), ( 2, resultAndThenChecks ) )\n        , ( ( [ \"Result\" ], \"withDefault\" ), ( 2, withDefaultChecks resultWithOkAsWrap ) )\n        , ( ( [ \"Result\" ], \"toMaybe\" ), ( 1, unwrapToMaybeChecks resultWithOkAsWrap ) )\n        , ( ( [ \"List\" ], \"append\" ), ( 2, collectionUnionChecks listCollection ) )\n        , ( ( [ \"List\" ], \"head\" ), ( 1, listHeadChecks ) )\n        , ( ( [ \"List\" ], \"tail\" ), ( 1, listTailChecks ) )\n        , ( ( [ \"List\" ], \"member\" ), ( 2, listMemberChecks ) )\n        , ( ( [ \"List\" ], \"map\" ), ( 2, listMapChecks ) )\n        , ( ( [ \"List\" ], \"filter\" ), ( 2, emptiableFilterChecks listCollection ) )\n        , ( ( [ \"List\" ], \"filterMap\" ), ( 2, listFilterMapChecks ) )\n        , ( ( [ \"List\" ], \"concat\" ), ( 1, listConcatChecks ) )\n        , ( ( [ \"List\" ], \"concatMap\" ), ( 2, listConcatMapChecks ) )\n        , ( ( [ \"List\" ], \"indexedMap\" ), ( 2, listIndexedMapChecks ) )\n        , ( ( [ \"List\" ], \"intersperse\" ), ( 2, listIntersperseChecks ) )\n        , ( ( [ \"List\" ], \"sum\" ), ( 1, listSumChecks ) )\n        , ( ( [ \"List\" ], \"product\" ), ( 1, listProductChecks ) )\n        , ( ( [ \"List\" ], \"minimum\" ), ( 1, listMinimumChecks ) )\n        , ( ( [ \"List\" ], \"maximum\" ), ( 1, listMaximumChecks ) )\n        , ( ( [ \"List\" ], \"foldl\" ), ( 3, listFoldlChecks ) )\n        , ( ( [ \"List\" ], \"foldr\" ), ( 3, listFoldrChecks ) )\n        , ( ( [ \"List\" ], \"all\" ), ( 2, listAllChecks ) )\n        , ( ( [ \"List\" ], \"any\" ), ( 2, listAnyChecks ) )\n        , ( ( [ \"List\" ], \"range\" ), ( 2, listRangeChecks ) )\n        , ( ( [ \"List\" ], \"length\" ), ( 1, collectionSizeChecks listCollection ) )\n        , ( ( [ \"List\" ], \"repeat\" ), ( 2, listRepeatChecks ) )\n        , ( ( [ \"List\" ], \"isEmpty\" ), ( 1, collectionIsEmptyChecks listCollection ) )\n        , ( ( [ \"List\" ], \"partition\" ), ( 2, collectionPartitionChecks listCollection ) )\n        , ( ( [ \"List\" ], \"reverse\" ), ( 1, listReverseChecks ) )\n        , ( ( [ \"List\" ], \"sort\" ), ( 1, listSortChecks ) )\n        , ( ( [ \"List\" ], \"sortBy\" ), ( 2, listSortByChecks ) )\n        , ( ( [ \"List\" ], \"sortWith\" ), ( 2, listSortWithChecks ) )\n        , ( ( [ \"List\" ], \"take\" ), ( 2, listTakeChecks ) )\n        , ( ( [ \"List\" ], \"drop\" ), ( 2, listDropChecks ) )\n        , ( ( [ \"List\" ], \"map2\" ), ( 3, emptiableMapNChecks { n = 2 } listCollection ) )\n        , ( ( [ \"List\" ], \"map3\" ), ( 4, emptiableMapNChecks { n = 3 } listCollection ) )\n        , ( ( [ \"List\" ], \"map4\" ), ( 5, emptiableMapNChecks { n = 4 } listCollection ) )\n        , ( ( [ \"List\" ], \"map5\" ), ( 6, emptiableMapNChecks { n = 5 } listCollection ) )\n        , ( ( [ \"List\" ], \"unzip\" ), ( 1, listUnzipChecks ) )\n        , ( ( [ \"Array\" ], \"toList\" ), ( 1, arrayToListChecks ) )\n        , ( ( [ \"Array\" ], \"fromList\" ), ( 1, arrayFromListChecks ) )\n        , ( ( [ \"Array\" ], \"map\" ), ( 2, emptiableMapChecks arrayCollection ) )\n        , ( ( [ \"Array\" ], \"indexedMap\" ), ( 2, arrayIndexedMapChecks ) )\n        , ( ( [ \"Array\" ], \"filter\" ), ( 2, emptiableFilterChecks arrayCollection ) )\n        , ( ( [ \"Array\" ], \"isEmpty\" ), ( 1, collectionIsEmptyChecks arrayCollection ) )\n        , ( ( [ \"Array\" ], \"length\" ), ( 1, arrayLengthChecks ) )\n        , ( ( [ \"Array\" ], \"repeat\" ), ( 2, arrayRepeatChecks ) )\n        , ( ( [ \"Array\" ], \"initialize\" ), ( 2, arrayInitializeChecks ) )\n        , ( ( [ \"Array\" ], \"append\" ), ( 2, collectionUnionChecks arrayCollection ) )\n        , ( ( [ \"Array\" ], \"get\" ), ( 2, getChecks arrayCollection ) )\n        , ( ( [ \"Array\" ], \"set\" ), ( 3, setChecks arrayCollection ) )\n        , ( ( [ \"Set\" ], \"map\" ), ( 2, emptiableMapChecks setCollection ) )\n        , ( ( [ \"Set\" ], \"filter\" ), ( 2, emptiableFilterChecks setCollection ) )\n        , ( ( [ \"Set\" ], \"remove\" ), ( 2, collectionRemoveChecks setCollection ) )\n        , ( ( [ \"Set\" ], \"isEmpty\" ), ( 1, collectionIsEmptyChecks setCollection ) )\n        , ( ( [ \"Set\" ], \"size\" ), ( 1, collectionSizeChecks setCollection ) )\n        , ( ( [ \"Set\" ], \"member\" ), ( 2, collectionMemberChecks setCollection ) )\n        , ( ( [ \"Set\" ], \"fromList\" ), ( 1, setFromListChecks ) )\n        , ( ( [ \"Set\" ], \"toList\" ), ( 1, emptiableToListChecks setCollection ) )\n        , ( ( [ \"Set\" ], \"partition\" ), ( 2, collectionPartitionChecks setCollection ) )\n        , ( ( [ \"Set\" ], \"intersect\" ), ( 2, collectionIntersectChecks setCollection ) )\n        , ( ( [ \"Set\" ], \"diff\" ), ( 2, collectionDiffChecks setCollection ) )\n        , ( ( [ \"Set\" ], \"union\" ), ( 2, collectionUnionChecks setCollection ) )\n        , ( ( [ \"Set\" ], \"insert\" ), ( 2, collectionInsertChecks setCollection ) )\n        , ( ( [ \"Dict\" ], \"isEmpty\" ), ( 1, collectionIsEmptyChecks dictCollection ) )\n        , ( ( [ \"Dict\" ], \"fromList\" ), ( 1, dictFromListChecks ) )\n        , ( ( [ \"Dict\" ], \"toList\" ), ( 1, emptiableToListChecks dictCollection ) )\n        , ( ( [ \"Dict\" ], \"size\" ), ( 1, collectionSizeChecks dictCollection ) )\n        , ( ( [ \"Dict\" ], \"member\" ), ( 2, collectionMemberChecks dictCollection ) )\n        , ( ( [ \"Dict\" ], \"partition\" ), ( 2, collectionPartitionChecks dictCollection ) )\n        , ( ( [ \"Dict\" ], \"intersect\" ), ( 2, collectionIntersectChecks dictCollection ) )\n        , ( ( [ \"Dict\" ], \"diff\" ), ( 2, collectionDiffChecks dictCollection ) )\n        , ( ( [ \"Dict\" ], \"union\" ), ( 2, collectionUnionChecks dictCollection ) )\n        , ( ( [ \"String\" ], \"toList\" ), ( 1, stringToListChecks ) )\n        , ( ( [ \"String\" ], \"fromList\" ), ( 1, stringFromListChecks ) )\n        , ( ( [ \"String\" ], \"isEmpty\" ), ( 1, collectionIsEmptyChecks stringCollection ) )\n        , ( ( [ \"String\" ], \"concat\" ), ( 1, stringConcatChecks ) )\n        , ( ( [ \"String\" ], \"join\" ), ( 2, stringJoinChecks ) )\n        , ( ( [ \"String\" ], \"length\" ), ( 1, collectionSizeChecks stringCollection ) )\n        , ( ( [ \"String\" ], \"repeat\" ), ( 2, stringRepeatChecks ) )\n        , ( ( [ \"String\" ], \"replace\" ), ( 3, stringReplaceChecks ) )\n        , ( ( [ \"String\" ], \"words\" ), ( 1, stringWordsChecks ) )\n        , ( ( [ \"String\" ], \"lines\" ), ( 1, stringLinesChecks ) )\n        , ( ( [ \"String\" ], \"reverse\" ), ( 1, stringReverseChecks ) )\n        , ( ( [ \"String\" ], \"slice\" ), ( 3, stringSliceChecks ) )\n        , ( ( [ \"String\" ], \"left\" ), ( 2, stringLeftChecks ) )\n        , ( ( [ \"String\" ], \"right\" ), ( 2, stringRightChecks ) )\n        , ( ( [ \"String\" ], \"append\" ), ( 2, collectionUnionChecks stringCollection ) )\n        , ( ( [ \"Platform\", \"Cmd\" ], \"batch\" ), ( 1, subAndCmdBatchChecks cmdCollection ) )\n        , ( ( [ \"Platform\", \"Cmd\" ], \"map\" ), ( 2, emptiableMapChecks cmdCollection ) )\n        , ( ( [ \"Platform\", \"Sub\" ], \"batch\" ), ( 1, subAndCmdBatchChecks subCollection ) )\n        , ( ( [ \"Platform\", \"Sub\" ], \"map\" ), ( 2, emptiableMapChecks subCollection ) )\n        , ( ( [ \"Task\" ], \"map\" ), ( 2, taskMapChecks ) )\n        , ( ( [ \"Task\" ], \"map2\" ), ( 3, taskMapNChecks { n = 2 } ) )\n        , ( ( [ \"Task\" ], \"map3\" ), ( 4, taskMapNChecks { n = 3 } ) )\n        , ( ( [ \"Task\" ], \"map4\" ), ( 5, taskMapNChecks { n = 4 } ) )\n        , ( ( [ \"Task\" ], \"map5\" ), ( 6, taskMapNChecks { n = 5 } ) )\n        , ( ( [ \"Task\" ], \"andThen\" ), ( 2, taskAndThenChecks ) )\n        , ( ( [ \"Task\" ], \"mapError\" ), ( 2, taskMapErrorChecks ) )\n        , ( ( [ \"Task\" ], \"onError\" ), ( 2, taskOnErrorChecks ) )\n        , ( ( [ \"Task\" ], \"sequence\" ), ( 1, taskSequenceChecks ) )\n        , ( ( [ \"Json\", \"Decode\" ], \"oneOf\" ), ( 1, oneOfChecks ) )\n        , ( ( [ \"Html\", \"Attributes\" ], \"classList\" ), ( 1, htmlAttributesClassListChecks ) )\n        , ( ( [ \"Parser\" ], \"oneOf\" ), ( 1, oneOfChecks ) )\n        , ( ( [ \"Parser\", \"Advanced\" ], \"oneOf\" ), ( 1, oneOfChecks ) )\n        , ( ( [ \"Random\" ], \"uniform\" ), ( 2, randomUniformChecks ) )\n        , ( ( [ \"Random\" ], \"weighted\" ), ( 2, randomWeightedChecks ) )\n        , ( ( [ \"Random\" ], \"list\" ), ( 2, randomListChecks ) )\n        , ( ( [ \"Random\" ], \"map\" ), ( 2, randomMapChecks ) )\n        , ( ( [ \"Random\" ], \"andThen\" ), ( 2, randomAndThenChecks ) )\n        ]\n\n\ntype alias OperatorCheckInfo =\n    { lookupTable : ModuleNameLookupTable\n    , extractSourceCode : Range -> String\n    , expectNaN : Bool\n    , importLookup : ImportLookup\n    , moduleBindings : Set String\n    , localBindings : RangeDict (Set String)\n    , inferredConstants : ( Infer.Inferred, List Infer.Inferred )\n    , parentRange : Range\n    , operator : String\n    , operatorRange : Range\n    , left : Node Expression\n    , leftRange : Range\n    , right : Node Expression\n    , rightRange : Range\n    , isOnTheRightSideOfPlusPlus : Bool\n    }\n\n\noperatorApplicationChecks : Dict String (OperatorCheckInfo -> Maybe (Error {}))\noperatorApplicationChecks =\n    Dict.fromList\n        [ ( \"+\", plusChecks )\n        , ( \"-\", minusChecks )\n        , ( \"*\", multiplyChecks )\n        , ( \"/\", divisionChecks )\n        , ( \"//\", intDivideChecks )\n        , ( \"++\", plusplusChecks )\n        , ( \"::\", consChecks )\n        , ( \"||\", orChecks )\n        , ( \"&&\", andChecks )\n        , ( \"==\", equalityChecks True )\n        , ( \"/=\", equalityChecks False )\n        , ( \"<\", comparisonChecks (<) )\n        , ( \">\", comparisonChecks (>) )\n        , ( \"<=\", comparisonChecks (<=) )\n        , ( \">=\", comparisonChecks (>=) )\n        ]\n\n\ntype alias CompositionCheckInfo =\n    { lookupTable : ModuleNameLookupTable\n    , importLookup : ImportLookup\n    , moduleBindings : Set String\n    , localBindings : RangeDict (Set String)\n    , direction : LeftOrRightDirection\n    , parentRange : Range\n    , earlier : Node Expression\n    , later : Node Expression\n    }\n\n\ncompositionChecks : List (CompositionCheckInfo -> Maybe (Error {}))\ncompositionChecks =\n    [ basicsIdentityCompositionChecks\n    , basicsNotCompositionChecks\n    , basicsNegateCompositionChecks\n    , toggleCompositionChecks ( [ \"String\" ], \"reverse\" )\n    , toggleCompositionChecks ( [ \"List\" ], \"reverse\" )\n    , inversesCompositionCheck { later = ( [ \"String\" ], \"toList\" ), earlier = ( [ \"String\" ], \"fromList\" ) }\n    , inversesCompositionCheck { later = ( [ \"String\" ], \"fromList\" ), earlier = ( [ \"String\" ], \"toList\" ) }\n    , inversesCompositionCheck { later = ( [ \"Array\" ], \"toList\" ), earlier = ( [ \"Array\" ], \"fromList\" ) }\n    , inversesCompositionCheck { later = ( [ \"Array\" ], \"fromList\" ), earlier = ( [ \"Array\" ], \"toList\" ) }\n    , inversesCompositionCheck { later = ( [ \"Set\" ], \"fromList\" ), earlier = ( [ \"Set\" ], \"toList\" ) }\n    , inversesCompositionCheck { later = ( [ \"Dict\" ], \"fromList\" ), earlier = ( [ \"Dict\" ], \"toList\" ) }\n    , \\checkInfo ->\n        case\n            ( AstHelpers.getValueOrFunctionOrFunctionCall checkInfo.earlier\n            , AstHelpers.getValueOrFunctionOrFunctionCall checkInfo.later\n            )\n        of\n            ( Just earlierFnOrCall, Just laterFnOrCall ) ->\n                case\n                    ( ModuleNameLookupTable.moduleNameAt checkInfo.lookupTable earlierFnOrCall.fnRange\n                    , ModuleNameLookupTable.moduleNameAt checkInfo.lookupTable laterFnOrCall.fnRange\n                    )\n                of\n                    ( Just earlierFnModuleName, Just laterFnModuleName ) ->\n                        case Dict.get ( laterFnModuleName, laterFnOrCall.fnName ) compositionIntoChecks of\n                            Just compositionIntoChecksForSpecificLater ->\n                                compositionIntoChecksForSpecificLater\n                                    { lookupTable = checkInfo.lookupTable\n                                    , importLookup = checkInfo.importLookup\n                                    , moduleBindings = checkInfo.moduleBindings\n                                    , localBindings = checkInfo.localBindings\n                                    , direction = checkInfo.direction\n                                    , parentRange = checkInfo.parentRange\n                                    , later =\n                                        { range = laterFnOrCall.nodeRange\n                                        , fn = ( laterFnModuleName, laterFnOrCall.fnName )\n                                        , fnRange = laterFnOrCall.fnRange\n                                        , args = laterFnOrCall.args\n                                        }\n                                    , earlier =\n                                        { range = earlierFnOrCall.nodeRange\n                                        , fn = ( earlierFnModuleName, earlierFnOrCall.fnName )\n                                        , fnRange = earlierFnOrCall.fnRange\n                                        , args = earlierFnOrCall.args\n                                        }\n                                    }\n                                    |> Maybe.map (\\e -> Rule.errorWithFix e.info laterFnOrCall.fnRange e.fix)\n\n                            Nothing ->\n                                Nothing\n\n                    ( Nothing, _ ) ->\n                        Nothing\n\n                    ( _, Nothing ) ->\n                        Nothing\n\n            ( Nothing, _ ) ->\n                Nothing\n\n            ( _, Nothing ) ->\n                Nothing\n    ]\n\n\ntype alias CompositionIntoCheckInfo =\n    { lookupTable : ModuleNameLookupTable\n    , importLookup : ImportLookup\n    , moduleBindings : Set String\n    , localBindings : RangeDict (Set String)\n    , direction : LeftOrRightDirection\n    , parentRange : Range\n    , later :\n        { range : Range\n        , fn : ( ModuleName, String )\n        , fnRange : Range\n        , args : List (Node Expression)\n        }\n    , earlier :\n        { range : Range\n        , fn : ( ModuleName, String )\n        , fnRange : Range\n        , args : List (Node Expression)\n        }\n    }\n\n\ncompositionIntoChecks : Dict ( ModuleName, String ) (CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix)\ncompositionIntoChecks =\n    Dict.fromList\n        [ ( ( [ \"Basics\" ], \"always\" ), basicsAlwaysCompositionChecks )\n        , ( ( [ \"String\" ], \"reverse\" ), stringReverseCompositionChecks )\n        , ( ( [ \"String\" ], \"fromList\" ), stringFromListCompositionChecks )\n        , ( ( [ \"Tuple\" ], \"first\" ), tupleFirstCompositionChecks )\n        , ( ( [ \"Tuple\" ], \"second\" ), tupleSecondCompositionChecks )\n        , ( ( [ \"Maybe\" ], \"map\" ), maybeMapCompositionChecks )\n        , ( ( [ \"Result\" ], \"map\" ), resultMapCompositionChecks )\n        , ( ( [ \"Result\" ], \"mapError\" ), resultMapErrorCompositionChecks )\n        , ( ( [ \"Result\" ], \"toMaybe\" ), resultToMaybeCompositionChecks )\n        , ( ( [ \"List\" ], \"reverse\" ), listReverseCompositionChecks )\n        , ( ( [ \"List\" ], \"map\" ), listMapCompositionChecks )\n        , ( ( [ \"List\" ], \"filterMap\" ), listFilterMapCompositionChecks )\n        , ( ( [ \"List\" ], \"intersperse\" ), listIntersperseCompositionChecks )\n        , ( ( [ \"List\" ], \"concat\" ), listConcatCompositionChecks )\n        , ( ( [ \"List\" ], \"foldl\" ), listFoldlCompositionChecks )\n        , ( ( [ \"List\" ], \"foldr\" ), listFoldrCompositionChecks )\n        , ( ( [ \"Set\" ], \"fromList\" ), setFromListCompositionChecks )\n        , ( ( [ \"Task\" ], \"map\" ), taskMapCompositionChecks )\n        , ( ( [ \"Task\" ], \"mapError\" ), taskMapErrorCompositionChecks )\n        , ( ( [ \"Task\" ], \"sequence\" ), taskSequenceCompositionChecks )\n        , ( ( [ \"Random\" ], \"map\" ), randomMapCompositionChecks )\n        ]\n\n\nremoveAlongWithOtherFunctionCheck : CheckInfo -> Maybe (Error {})\nremoveAlongWithOtherFunctionCheck checkInfo =\n    let\n        fnToFind : ( ModuleName, String )\n        fnToFind =\n            checkInfo.fn\n    in\n    case Node.value (AstHelpers.removeParens checkInfo.firstArg) of\n        Expression.Application (secondFn :: firstArgOfSecondCall :: _) ->\n            case AstHelpers.getSpecificValueOrFunction fnToFind checkInfo.lookupTable secondFn of\n                Just secondRange ->\n                    Just\n                        (Rule.errorWithFix\n                            (doubleToggleErrorInfo fnToFind)\n                            (Range.combine [ checkInfo.fnRange, secondRange ])\n                            (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.firstArg }\n                                ++ replaceBySubExpressionFix (Node.range checkInfo.firstArg)\n                                    firstArgOfSecondCall\n                            )\n                        )\n\n                Nothing ->\n                    Nothing\n\n        Expression.OperatorApplication \"|>\" _ firstArgOfSecondCall secondFn ->\n            case AstHelpers.getSpecificValueOrFunction fnToFind checkInfo.lookupTable secondFn of\n                Just secondRange ->\n                    Just\n                        (Rule.errorWithFix\n                            (doubleToggleErrorInfo fnToFind)\n                            (Range.combine [ checkInfo.fnRange, secondRange ])\n                            (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.firstArg }\n                                ++ replaceBySubExpressionFix (Node.range checkInfo.firstArg)\n                                    firstArgOfSecondCall\n                            )\n                        )\n\n                Nothing ->\n                    Nothing\n\n        Expression.OperatorApplication \"<|\" _ secondFn firstArgOfSecondCall ->\n            case AstHelpers.getSpecificValueOrFunction fnToFind checkInfo.lookupTable secondFn of\n                Just secondRange ->\n                    Just\n                        (Rule.errorWithFix\n                            (doubleToggleErrorInfo fnToFind)\n                            (Range.combine [ checkInfo.fnRange, secondRange ])\n                            (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.firstArg }\n                                ++ replaceBySubExpressionFix (Node.range checkInfo.firstArg)\n                                    firstArgOfSecondCall\n                            )\n                        )\n\n                Nothing ->\n                    Nothing\n\n        _ ->\n            Nothing\n\n\nfindOperatorRange :\n    { extractSourceCode : Range -> String\n    , commentRanges : List Range\n    , operator : String\n    , leftRange : Range\n    , rightRange : Range\n    }\n    -> Range\nfindOperatorRange context =\n    let\n        betweenOperands : String\n        betweenOperands =\n            context.extractSourceCode\n                { start = context.leftRange.end, end = context.rightRange.start }\n\n        operatorStartLocationFound : Maybe Location\n        operatorStartLocationFound =\n            String.indexes context.operator betweenOperands\n                |> findMap\n                    (\\operatorOffset ->\n                        let\n                            operatorStartLocation : Location\n                            operatorStartLocation =\n                                offsetInStringToLocation\n                                    { offset = operatorOffset\n                                    , startLocation = context.leftRange.end\n                                    , source = betweenOperands\n                                    }\n\n                            isPartOfComment : Bool\n                            isPartOfComment =\n                                List.any\n                                    (\\commentRange ->\n                                        rangeContainsLocation operatorStartLocation commentRange\n                                    )\n                                    context.commentRanges\n                        in\n                        if isPartOfComment then\n                            Nothing\n\n                        else\n                            Just operatorStartLocation\n                    )\n    in\n    case operatorStartLocationFound of\n        Just operatorStartLocation ->\n            { start = operatorStartLocation\n            , end =\n                { row = operatorStartLocation.row\n                , column = operatorStartLocation.column + String.length context.operator\n                }\n            }\n\n        -- there's a bug somewhere\n        Nothing ->\n            Range.emptyRange\n\n\noffsetInStringToLocation : { offset : Int, source : String, startLocation : Location } -> Location\noffsetInStringToLocation config =\n    case config.source |> String.left config.offset |> String.lines |> List.reverse of\n        [] ->\n            config.startLocation\n\n        onlyLine :: [] ->\n            { row = config.startLocation.row\n            , column = config.startLocation.column + String.length onlyLine\n            }\n\n        lineWithOffsetLocation :: _ :: linesBeforeBeforeWithOffsetLocation ->\n            { row = config.startLocation.row + 1 + List.length linesBeforeBeforeWithOffsetLocation\n            , column = 1 + String.length lineWithOffsetLocation\n            }\n\n\nplusChecks : OperatorCheckInfo -> Maybe (Error {})\nplusChecks checkInfo =\n    firstThatConstructsJust\n        [ addingZeroCheck\n        , addingOppositesCheck\n        ]\n        checkInfo\n\n\naddingZeroCheck : OperatorCheckInfo -> Maybe (Error {})\naddingZeroCheck checkInfo =\n    findMap\n        (\\side ->\n            if AstHelpers.getUncomputedNumberValue side.node == Just 0 then\n                Just\n                    (Rule.errorWithFix\n                        { message = \"Unnecessary addition with 0\"\n                        , details = [ \"Adding 0 does not change the value of the number.\" ]\n                        }\n                        side.errorRange\n                        [ Fix.removeRange side.removeRange ]\n                    )\n\n            else\n                Nothing\n        )\n        (operationToSides checkInfo)\n\n\naddingOppositesCheck : OperatorCheckInfo -> Maybe (Error {})\naddingOppositesCheck checkInfo =\n    if checkInfo.expectNaN then\n        Nothing\n\n    else\n        case Normalize.compare checkInfo checkInfo.left (Node Range.emptyRange (Expression.Negation checkInfo.right)) of\n            Normalize.ConfirmedEquality ->\n                Just\n                    (Rule.errorWithFix\n                        { message = \"Addition always results in 0\"\n                        , details = [ \"These two expressions have an equal absolute value but an opposite sign. This means adding them they will cancel out to 0.\" ]\n                        }\n                        checkInfo.parentRange\n                        [ Fix.replaceRangeBy checkInfo.parentRange \"0\" ]\n                    )\n\n            Normalize.ConfirmedInequality ->\n                Nothing\n\n            Normalize.Unconfirmed ->\n                Nothing\n\n\nminusChecks : OperatorCheckInfo -> Maybe (Error {})\nminusChecks checkInfo =\n    if AstHelpers.getUncomputedNumberValue checkInfo.right == Just 0 then\n        Just\n            (Rule.errorWithFix\n                { message = \"Unnecessary subtraction with 0\"\n                , details = [ \"Subtracting 0 does not change the value of the number.\" ]\n                }\n                (errorToRightRange checkInfo)\n                [ Fix.removeRange (fixToRightRange checkInfo) ]\n            )\n\n    else if AstHelpers.getUncomputedNumberValue checkInfo.left == Just 0 then\n        let\n            replacedRange : Range\n            replacedRange =\n                fixToLeftRange checkInfo\n        in\n        Just\n            (Rule.errorWithFix\n                { message = \"Unnecessary subtracting from 0\"\n                , details = [ \"You can negate the expression on the right like `-n`.\" ]\n                }\n                (errorToLeftRange checkInfo)\n                (if needsParens (Node.value checkInfo.right) then\n                    [ Fix.replaceRangeBy replacedRange \"-(\", Fix.insertAt checkInfo.rightRange.end \")\" ]\n\n                 else\n                    [ Fix.replaceRangeBy replacedRange \"-\" ]\n                )\n            )\n\n    else if checkInfo.expectNaN then\n        Nothing\n\n    else\n        checkIfMinusResultsInZero checkInfo\n\n\ncheckIfMinusResultsInZero : OperatorCheckInfo -> Maybe (Error {})\ncheckIfMinusResultsInZero checkInfo =\n    case Normalize.compare checkInfo checkInfo.left checkInfo.right of\n        Normalize.ConfirmedEquality ->\n            Just\n                (Rule.errorWithFix\n                    { message = \"Subtraction always results in 0\"\n                    , details = [ \"These two expressions have the same value, which means they will cancel add when subtracting one by the other.\" ]\n                    }\n                    checkInfo.parentRange\n                    [ Fix.replaceRangeBy checkInfo.parentRange \"0\" ]\n                )\n\n        Normalize.ConfirmedInequality ->\n            Nothing\n\n        Normalize.Unconfirmed ->\n            Nothing\n\n\nmultiplyChecks : OperatorCheckInfo -> Maybe (Error {})\nmultiplyChecks checkInfo =\n    findMap\n        (\\side ->\n            case AstHelpers.getUncomputedNumberValue side.node of\n                Just number ->\n                    if number == 1 then\n                        Just\n                            (Rule.errorWithFix\n                                { message = \"Unnecessary multiplication by 1\"\n                                , details = [ \"Multiplying by 1 does not change the value of the number.\" ]\n                                }\n                                side.errorRange\n                                [ Fix.removeRange side.removeRange ]\n                            )\n\n                    else if number == 0 then\n                        Just\n                            (Rule.errorWithFix\n                                { message = \"Multiplication by 0 should be replaced\"\n                                , details =\n                                    [ \"Multiplying by 0 will turn finite numbers into 0 and keep NaN and (-)Infinity\"\n                                    , \"Most likely, multiplying by 0 was unintentional and you had a different factor in mind.\"\n                                    , \"\"\"If you do want the described behavior, though, make your intention clear for the reader\nby explicitly checking for `Basics.isNaN` and `Basics.isInfinite`.\"\"\"\n                                    , \"\"\"Basics.isNaN: https://package.elm-lang.org/packages/elm/core/latest/Basics#isNaN\nBasics.isInfinite: https://package.elm-lang.org/packages/elm/core/latest/Basics#isInfinite\"\"\"\n                                    ]\n                                }\n                                side.errorRange\n                                (if checkInfo.expectNaN then\n                                    []\n\n                                 else\n                                    [ Fix.replaceRangeBy checkInfo.parentRange \"0\" ]\n                                )\n                            )\n\n                    else\n                        Nothing\n\n                Nothing ->\n                    Nothing\n        )\n        (operationToSides checkInfo)\n\n\noperationToSides : OperatorCheckInfo -> List { node : Node Expression, removeRange : Range, errorRange : Range }\noperationToSides checkInfo =\n    [ { node = checkInfo.right\n      , removeRange = fixToRightRange checkInfo\n      , errorRange = errorToRightRange checkInfo\n      }\n    , { node = checkInfo.left\n      , removeRange = fixToLeftRange checkInfo\n      , errorRange = errorToLeftRange checkInfo\n      }\n    ]\n\n\n{-| Sometimes, you can't use `replaceBySubExpressionFix` and `keepOnlyFix` because there is no\nexisting node that could be kept.\n\nFor example, you might want to remove `|> identity` in `f |> g |> identity`. `elm-syntax` might represent this as (simplified)\n\n    Op (Var \"f\") \"|>\" (Op (Var \"g\") \"|>\" (Var \"identity\"))\n\nIn practice, you will check this syntax tree recursively, leading to situations where we only know\n\n  - the previous/next element which we want to keep\n  - and the current element which we want to remove\n\n`removeAndBetweenFix` takes the ranges of these two elements and removes the given element and everything between them.\n\n-}\nremoveAndBetweenFix : { remove : Range, keep : Range } -> List Fix\nremoveAndBetweenFix ranges =\n    case Range.compare ranges.keep ranges.remove of\n        LT ->\n            [ Fix.removeRange { start = ranges.keep.end, end = ranges.remove.end } ]\n\n        -- GT | EQ ->\n        _ ->\n            [ Fix.removeRange { start = ranges.remove.start, end = ranges.keep.start } ]\n\n\nfixToLeftRange : { checkInfo | leftRange : Range, rightRange : Range } -> Range\nfixToLeftRange checkInfo =\n    { start = checkInfo.leftRange.start, end = checkInfo.rightRange.start }\n\n\nerrorToLeftRange : { checkInfo | leftRange : Range, operatorRange : Range } -> Range\nerrorToLeftRange checkInfo =\n    { start = checkInfo.leftRange.start, end = checkInfo.operatorRange.end }\n\n\nfixToRightRange : { checkInfo | leftRange : Range, rightRange : Range } -> Range\nfixToRightRange checkInfo =\n    { start = checkInfo.leftRange.end, end = checkInfo.rightRange.end }\n\n\nerrorToRightRange : { checkInfo | rightRange : Range, operatorRange : Range } -> Range\nerrorToRightRange checkInfo =\n    { start = checkInfo.operatorRange.start, end = checkInfo.rightRange.end }\n\n\ndivisionChecks : OperatorCheckInfo -> Maybe (Error {})\ndivisionChecks checkInfo =\n    let\n        maybeDivisorNumber : Maybe Float\n        maybeDivisorNumber =\n            AstHelpers.getUncomputedNumberValue checkInfo.right\n    in\n    if maybeDivisorNumber == Just 1 then\n        Just\n            (Rule.errorWithFix\n                { message = \"Unnecessary division by 1\"\n                , details = [ \"Dividing by 1 does not change the value of the number.\" ]\n                }\n                (errorToRightRange checkInfo)\n                [ Fix.removeRange (fixToRightRange checkInfo) ]\n            )\n\n    else if not checkInfo.expectNaN && (AstHelpers.getUncomputedNumberValue checkInfo.left == Just 0) then\n        if maybeDivisorNumber == Just 0 then\n            Just\n                (Rule.error\n                    { message = \"0 / 0 is NaN but the configuration option expectNaN is not enabled\"\n                    , details =\n                        [ \"Dividing 0 by 0 is the simplest way to obtain a NaN value in elm. NaN is a special Float value that signifies a failure of a mathematical operation and tends to spread through code.\"\n                        , \"By default, Simplify assumes that your code does not expect NaN values so it can enable a few more checks. If creating NaN here was not your intention, replace this division by a more fitting number like 0.\"\n                        , \"If you do want to use NaN here, please add expectNaN to your Simplify configuration to let it know NaN is a possible value in your code.\"\n                        , \"expectNaN: https://package.elm-lang.org/packages/jfmengels/elm-review-simplify/latest/Simplify#expectNaN\"\n                        ]\n                    }\n                    checkInfo.operatorRange\n                )\n\n        else\n            Just\n                (Rule.errorWithFix\n                    { message = \"Dividing 0 always returns 0\"\n                    , details =\n                        [ \"Dividing 0 by anything, even infinite numbers, gives 0 which means you can replace the whole division operation by 0.\"\n                        , \"Most likely, dividing 0 was unintentional and you had a different number in mind.\"\n                        ]\n                    }\n                    (errorToLeftRange checkInfo)\n                    (keepOnlyFix { parentRange = checkInfo.parentRange, keep = checkInfo.leftRange })\n                )\n\n    else\n        Nothing\n\n\nintDivideChecks : OperatorCheckInfo -> Maybe (Error {})\nintDivideChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            case AstHelpers.getUncomputedNumberValue checkInfo.right of\n                Just rightNumber ->\n                    if rightNumber == 1 then\n                        Just\n                            (Rule.errorWithFix\n                                { message = \"Unnecessary division by 1\"\n                                , details = [ \"Dividing by 1 using (//) does not change the value of the number.\" ]\n                                }\n                                checkInfo.operatorRange\n                                (keepOnlyFix { parentRange = checkInfo.parentRange, keep = checkInfo.leftRange })\n                            )\n\n                    else if rightNumber == 0 then\n                        Just\n                            (Rule.errorWithFix\n                                { message = \"Dividing by 0 always returns 0\"\n                                , details =\n                                    [ \"Dividing anything by 0 using (//) gives 0 which means you can replace the whole division operation by 0.\"\n                                    , \"Most likely, dividing by 0 was unintentional and you had a different number in mind.\"\n                                    ]\n                                }\n                                checkInfo.operatorRange\n                                (keepOnlyFix { parentRange = checkInfo.parentRange, keep = checkInfo.rightRange })\n                            )\n\n                    else\n                        Nothing\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            if AstHelpers.getUncomputedNumberValue checkInfo.left == Just 0 then\n                Just\n                    (Rule.errorWithFix\n                        { message = \"Dividing 0 always returns 0\"\n                        , details =\n                            [ \"Dividing 0 by anything using (//), even 0, gives 0 which means you can replace the whole division operation by 0.\"\n                            , \"Most likely, dividing 0 was unintentional and you had a different number in mind.\"\n                            ]\n                        }\n                        checkInfo.operatorRange\n                        (keepOnlyFix { parentRange = checkInfo.parentRange, keep = checkInfo.leftRange })\n                    )\n\n            else\n                Nothing\n        ]\n        ()\n\n\nplusplusChecks : OperatorCheckInfo -> Maybe (Error {})\nplusplusChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            case ( Node.value checkInfo.left, Node.value checkInfo.right ) of\n                ( Expression.Literal \"\", Expression.Literal _ ) ->\n                    Just\n                        (Rule.errorWithFix\n                            (concatenateEmptyErrorInfo { represents = \"string\", emptyDescription = emptyStringAsString })\n                            checkInfo.operatorRange\n                            (keepOnlyFix\n                                { keep = checkInfo.rightRange\n                                , parentRange = checkInfo.parentRange\n                                }\n                            )\n                        )\n\n                ( Expression.Literal _, Expression.Literal \"\" ) ->\n                    Just\n                        (Rule.errorWithFix\n                            (concatenateEmptyErrorInfo { represents = \"string\", emptyDescription = emptyStringAsString })\n                            checkInfo.operatorRange\n                            (keepOnlyFix\n                                { keep = checkInfo.leftRange\n                                , parentRange = checkInfo.parentRange\n                                }\n                            )\n                        )\n\n                _ ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getListLiteral checkInfo.left of\n                Just [] ->\n                    Just\n                        (Rule.errorWithFix\n                            (concatenateEmptyErrorInfo { represents = \"list\", emptyDescription = \"[]\" })\n                            checkInfo.operatorRange\n                            (keepOnlyFix\n                                { keep = checkInfo.rightRange\n                                , parentRange = checkInfo.parentRange\n                                }\n                            )\n                        )\n\n                _ ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getListLiteral checkInfo.right of\n                Just [] ->\n                    Just\n                        (Rule.errorWithFix\n                            (concatenateEmptyErrorInfo { represents = \"list\", emptyDescription = \"[]\" })\n                            checkInfo.operatorRange\n                            (keepOnlyFix\n                                { keep = checkInfo.leftRange\n                                , parentRange = checkInfo.parentRange\n                                }\n                            )\n                        )\n\n                _ ->\n                    Nothing\n        , \\() ->\n            collectionUnionWithLiteralsChecks listCollection\n                { lookupTable = checkInfo.lookupTable\n                , extractSourceCode = checkInfo.extractSourceCode\n                , parentRange = checkInfo.parentRange\n                , first = checkInfo.left\n                , second = checkInfo.right\n                , operationRange = checkInfo.operatorRange\n                , operation = \"++\"\n                }\n        , \\() ->\n            collectionUnionWithLiteralsChecks stringCollection\n                { lookupTable = checkInfo.lookupTable\n                , extractSourceCode = checkInfo.extractSourceCode\n                , parentRange = checkInfo.parentRange\n                , first = checkInfo.left\n                , second = checkInfo.right\n                , operationRange = checkInfo.operatorRange\n                , operation = \"++\"\n                }\n        , \\() ->\n            case AstHelpers.getListSingleton checkInfo.lookupTable checkInfo.left of\n                Just leftListSingleton ->\n                    if checkInfo.isOnTheRightSideOfPlusPlus then\n                        Nothing\n\n                    else\n                        Just\n                            (Rule.errorWithFix\n                                { message = \"Appending a singleton list to the beginning is the same as using (::) with the value inside\"\n                                , details = [ \"You can replace this (++) operation by using (::) with the value inside the left singleton list on the right list.\" ]\n                                }\n                                checkInfo.operatorRange\n                                (Fix.replaceRangeBy checkInfo.operatorRange\n                                    \"::\"\n                                    :: replaceBySubExpressionFix checkInfo.leftRange leftListSingleton.element\n                                )\n                            )\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\nconcatenateEmptyErrorInfo : { represents : String, emptyDescription : String } -> { message : String, details : List String }\nconcatenateEmptyErrorInfo config =\n    { message = \"Unnecessary concatenation with \" ++ config.emptyDescription\n    , details = [ \"You should remove the concatenation with the empty \" ++ config.represents ++ \".\" ]\n    }\n\n\nconsChecks : OperatorCheckInfo -> Maybe (Error {})\nconsChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            case Node.value checkInfo.right of\n                Expression.ListExpr tailElements ->\n                    let\n                        fix : List Fix\n                        fix =\n                            case tailElements of\n                                [] ->\n                                    [ Fix.insertAt checkInfo.leftRange.start \"[ \"\n                                    , Fix.replaceRangeBy\n                                        { start = checkInfo.leftRange.end\n                                        , end = checkInfo.rightRange.end\n                                        }\n                                        \" ]\"\n                                    ]\n\n                                _ :: _ ->\n                                    [ Fix.insertAt checkInfo.leftRange.start \"[ \"\n                                    , Fix.replaceRangeBy checkInfo.operatorRange \",\"\n                                    , Fix.removeRange (leftBoundaryRange checkInfo.rightRange)\n                                    ]\n                    in\n                    Just\n                        (Rule.errorWithFix\n                            { message = \"Element added to the beginning of the list could be included in the list\"\n                            , details = [ \"Try moving the element inside the list it is being added to.\" ]\n                            }\n                            checkInfo.operatorRange\n                            fix\n                        )\n\n                _ ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getListSingleton checkInfo.lookupTable checkInfo.right of\n                Just tailSingleton ->\n                    Just\n                        (Rule.errorWithFix\n                            { message = \"Element added to the beginning of the list could be included in the list\"\n                            , details = [ \"You can replace this operation by a list that contains both the added element and the value inside the singleton list.\" ]\n                            }\n                            checkInfo.operatorRange\n                            [ Fix.insertAt checkInfo.leftRange.start \"[ \"\n                            , Fix.replaceRangeBy\n                                { start = checkInfo.leftRange.end\n                                , end = (Node.range tailSingleton.element).start\n                                }\n                                \", \"\n                            , Fix.replaceRangeBy\n                                { start = (Node.range tailSingleton.element).end\n                                , end = checkInfo.parentRange.end\n                                }\n                                \" ]\"\n                            ]\n                        )\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\n{-| Chaining two operations that are inverses of each other and therefore cancel each other out.\nFor example\n\n    Array.fromList (Array.toList array)\n    --> array\n\n    Array.toList (Array.fromList list)\n    --> list\n\nTip: Add `inversesCompositionCheck` for the same thing as a composition check.\n\nThese usually exist in pairs, like above so make sure to add this check for both functions.\nBut there are exceptions!\n\n    Set.fromList (Set.toList set)\n    --> set\n\nThis will always work because `Set.toList` will never produce a list with duplicate elements. However\n\n    Set.toList (Set.fromList list)\n    --> list\n\nwould be an incorrect fix. See for example\n\n    Set.toList (Set.fromList [ 0, 0 ])\n    --> not [ 0, 0 ] bit actually [ 0 ]\n\n-}\nonCallToInverseReturnsItsArgumentCheck : ( ModuleName, String ) -> CheckInfo -> Maybe (Error {})\nonCallToInverseReturnsItsArgumentCheck inverseFn checkInfo =\n    case AstHelpers.getSpecificFunctionCall inverseFn checkInfo.lookupTable checkInfo.firstArg of\n        Just call ->\n            Just\n                (Rule.errorWithFix\n                    { message = qualifiedToString inverseFn ++ \", then \" ++ qualifiedToString checkInfo.fn ++ \" cancels each other out\"\n                    , details = [ \"You can replace this call by the argument given to \" ++ qualifiedToString inverseFn ++ \".\" ]\n                    }\n                    checkInfo.fnRange\n                    (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range call.firstArg })\n                )\n\n        Nothing ->\n            Nothing\n\n\n{-| Composing two operations that are inverses of each other and therefore cancel each other out.\nFor example\n\n    -- inversesCompositionCheck { later = ( [ \"Array\" ], \"fromList\" ), earlier = ( [ \"Array\" ], \"toList\" ) }\n    Array.toList >> Array.fromList\n    --> identity\n\n    -- inversesCompositionCheck { later = ( [ \"Array\" ], \"toList\" ) , earlier = ( [ \"Array\" ], \"fromList\" ) }\n    Array.fromList >> Array.toList\n    --> identity\n\nTip: Add `onCallToInverseReturnsItsArgumentCheck` for the same thing as a function call check.\n\nThese usually exist in pairs, like above so make sure to add this check for both functions.\nBut there are exceptions!\n\n    Set.fromList << Set.toList --> identity\n\nThis will always work because `Set.toList` will never produce a list with duplicate elements. However\n\n    Set.toList << Set.fromList --> identity\n\nwould be an incorrect fix. See for example\n\n    Set.toList (Set.fromList [ 0, 0 ])\n    --> not [ 0, 0 ] bit actually [ 0 ]\n\n-}\ninversesCompositionCheck : { later : ( ModuleName, String ), earlier : ( ModuleName, String ) } -> CompositionCheckInfo -> Maybe (Error {})\ninversesCompositionCheck inverseFn checkInfo =\n    let\n        checkFnInfosForInverses : { earlierFnInfo : { range : Range, name : String }, laterFnInfo : { range : Range, name : String }, details : List String, fix : List Fix } -> Maybe (Error {})\n        checkFnInfosForInverses config =\n            case ( ModuleNameLookupTable.moduleNameAt checkInfo.lookupTable config.earlierFnInfo.range, ModuleNameLookupTable.moduleNameAt checkInfo.lookupTable config.laterFnInfo.range ) of\n                ( Just earlierModuleName, Just laterModuleName ) ->\n                    let\n                        earlierFn : ( ModuleName, String )\n                        earlierFn =\n                            ( earlierModuleName, config.earlierFnInfo.name )\n\n                        laterFn : ( ModuleName, String )\n                        laterFn =\n                            ( laterModuleName, config.laterFnInfo.name )\n                    in\n                    if earlierFn == inverseFn.earlier && laterFn == inverseFn.later then\n                        Just\n                            (Rule.errorWithFix\n                                { message = qualifiedToString earlierFn ++ \", then \" ++ qualifiedToString laterFn ++ \" cancels each other out\"\n                                , details = config.details\n                                }\n                                config.laterFnInfo.range\n                                config.fix\n                            )\n\n                    else\n                        Nothing\n\n                _ ->\n                    Nothing\n    in\n    case ( AstHelpers.getValueOrFunction checkInfo.earlier, AstHelpers.getValueOrFunction checkInfo.later ) of\n        ( Just earlierFnInfo, Just laterFnInfo ) ->\n            checkFnInfosForInverses\n                { earlierFnInfo = earlierFnInfo\n                , laterFnInfo = laterFnInfo\n                , details = [ \"You can replace this composition by identity.\" ]\n                , fix =\n                    [ Fix.replaceRangeBy checkInfo.parentRange\n                        (qualifiedToString (qualify ( [ \"Basics\" ], \"identity\" ) checkInfo))\n                    ]\n                }\n\n        ( Just earlierFnInfo, Nothing ) ->\n            case getFullComposition checkInfo.later of\n                Just composition ->\n                    case AstHelpers.getValueOrFunction composition.earlier of\n                        Just laterFnInfo ->\n                            checkFnInfosForInverses\n                                { earlierFnInfo = earlierFnInfo\n                                , laterFnInfo = laterFnInfo\n                                , details = [ \"You can remove these two functions.\" ]\n                                , fix = replaceBySubExpressionFix checkInfo.parentRange composition.composedLater\n                                }\n\n                        Nothing ->\n                            Nothing\n\n                Nothing ->\n                    Nothing\n\n        ( Nothing, Just laterFnInfo ) ->\n            case getCompositionToLast checkInfo.earlier of\n                Just composition ->\n                    case AstHelpers.getValueOrFunction composition.last of\n                        Just earlierFnInfo ->\n                            checkFnInfosForInverses\n                                { earlierFnInfo = earlierFnInfo\n                                , laterFnInfo = laterFnInfo\n                                , details = [ \"You can remove these two functions.\" ]\n                                , fix =\n                                    keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.earlier }\n                                        ++ removeAndBetweenFix { remove = Node.range composition.last, keep = Node.range composition.earlier }\n                                }\n\n                        Nothing ->\n                            Nothing\n\n                Nothing ->\n                    Nothing\n\n        ( Nothing, Nothing ) ->\n            Nothing\n\n\n{-| The function applied later than all the others in a composition chain and the function directly before.\n\nE.g. `f << g << h` would return `Just { earlier = g, last = h }`\n\n-}\ngetCompositionToLast : Node Expression -> Maybe { earlier : Node Expression, last : Node Expression }\ngetCompositionToLast expressionNode =\n    case getFullComposition expressionNode of\n        Just fullComposition ->\n            case getCompositionToLast fullComposition.composedLater of\n                Just actualLast ->\n                    Just actualLast\n\n                Nothing ->\n                    Just { earlier = fullComposition.earlier, last = fullComposition.composedLater }\n\n        Nothing ->\n            Nothing\n\n\n{-| Unlike `AstHelpers.getComposition` which only looks at the earliest 2 composed functions, e.g. `f << g` for `f << g << h`.\n`getFullComposition` returns the later part as an expression, e.g. `{ earlier = f, composedLater = g << h }`.\n-}\ngetFullComposition : Node Expression -> Maybe { earlier : Node Expression, composedLater : Node Expression }\ngetFullComposition expressionNode =\n    case Node.value (AstHelpers.removeParens expressionNode) of\n        Expression.OperatorApplication \"<<\" _ composedLater earlier ->\n            Just { earlier = earlier, composedLater = composedLater }\n\n        Expression.OperatorApplication \">>\" _ earlier composedLater ->\n            Just { earlier = earlier, composedLater = composedLater }\n\n        _ ->\n            Nothing\n\n\ntoggleCompositionChecks : ( ModuleName, String ) -> CompositionCheckInfo -> Maybe (Error {})\ntoggleCompositionChecks toggle checkInfo =\n    let\n        getToggleFn : Node Expression -> Maybe Range\n        getToggleFn =\n            AstHelpers.getSpecificValueOrFunction toggle checkInfo.lookupTable\n\n        maybeEarlierToggleFn : Maybe Range\n        maybeEarlierToggleFn =\n            getToggleFn checkInfo.earlier\n\n        maybeLaterToggleFn : Maybe Range\n        maybeLaterToggleFn =\n            getToggleFn checkInfo.later\n\n        getToggleComposition : { earlierToLater : Bool } -> Node Expression -> Maybe { removeFix : List Fix, range : Range }\n        getToggleComposition takeFirstFunction expressionNode =\n            case AstHelpers.getComposition expressionNode of\n                Just composition ->\n                    if takeFirstFunction.earlierToLater then\n                        getToggleFn composition.earlier\n                            |> Maybe.map\n                                (\\toggleFn ->\n                                    { range = toggleFn\n                                    , removeFix = keepOnlyFix { parentRange = composition.parentRange, keep = Node.range composition.later }\n                                    }\n                                )\n\n                    else\n                        getToggleFn composition.later\n                            |> Maybe.map\n                                (\\toggleFn ->\n                                    { range = toggleFn\n                                    , removeFix = keepOnlyFix { parentRange = composition.parentRange, keep = Node.range composition.earlier }\n                                    }\n                                )\n\n                Nothing ->\n                    Nothing\n    in\n    firstThatConstructsJust\n        [ \\() ->\n            case ( maybeEarlierToggleFn, maybeLaterToggleFn ) of\n                ( Just _, Just _ ) ->\n                    Just\n                        (Rule.errorWithFix\n                            (doubleToggleErrorInfo toggle)\n                            checkInfo.parentRange\n                            [ Fix.replaceRangeBy checkInfo.parentRange\n                                (qualifiedToString (qualify ( [ \"Basics\" ], \"identity\" ) checkInfo))\n                            ]\n                        )\n\n                ( Nothing, _ ) ->\n                    Nothing\n\n                ( _, Nothing ) ->\n                    Nothing\n        , \\() ->\n            case maybeEarlierToggleFn of\n                Just earlierToggleFn ->\n                    case getToggleComposition { earlierToLater = True } checkInfo.later of\n                        Just laterToggle ->\n                            Just\n                                (Rule.errorWithFix\n                                    (doubleToggleErrorInfo toggle)\n                                    (Range.combine [ earlierToggleFn, laterToggle.range ])\n                                    (laterToggle.removeFix\n                                        ++ keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.later }\n                                    )\n                                )\n\n                        Nothing ->\n                            Nothing\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case maybeLaterToggleFn of\n                Just laterToggleFn ->\n                    case getToggleComposition { earlierToLater = False } checkInfo.earlier of\n                        Just earlierToggle ->\n                            Just\n                                (Rule.errorWithFix\n                                    (doubleToggleErrorInfo toggle)\n                                    (Range.combine [ earlierToggle.range, laterToggleFn ])\n                                    (earlierToggle.removeFix\n                                        ++ keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.earlier }\n                                    )\n                                )\n\n                        Nothing ->\n                            Nothing\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\ndoubleToggleErrorInfo : ( ModuleName, String ) -> { message : String, details : List String }\ndoubleToggleErrorInfo toggle =\n    let\n        toggleFullyQualifiedAsString : String\n        toggleFullyQualifiedAsString =\n            qualifiedToString toggle\n    in\n    { message = \"Unnecessary double \" ++ toggleFullyQualifiedAsString\n    , details = [ \"Chaining \" ++ toggleFullyQualifiedAsString ++ \" with \" ++ toggleFullyQualifiedAsString ++ \" makes both functions cancel each other out.\" ]\n    }\n\n\n\n-- NEGATE\n\n\nbasicsNegateCompositionChecks : CompositionCheckInfo -> Maybe (Error {})\nbasicsNegateCompositionChecks checkInfo =\n    toggleCompositionChecks ( [ \"Basics\" ], \"negate\" ) checkInfo\n\n\nbasicsNegateChecks : CheckInfo -> Maybe (Error {})\nbasicsNegateChecks checkInfo =\n    removeAlongWithOtherFunctionCheck checkInfo\n\n\n\n-- BOOLEAN\n\n\nbasicsNotChecks : CheckInfo -> Maybe (Error {})\nbasicsNotChecks checkInfo =\n    firstThatConstructsJust\n        [ notOnKnownBoolCheck\n        , removeAlongWithOtherFunctionCheck\n        , isNotOnBooleanOperatorCheck\n        ]\n        checkInfo\n\n\nnotOnKnownBoolCheck : CheckInfo -> Maybe (Error {})\nnotOnKnownBoolCheck checkInfo =\n    case Evaluate.getBoolean checkInfo checkInfo.firstArg of\n        Determined bool ->\n            let\n                notBoolAsString : String\n                notBoolAsString =\n                    AstHelpers.boolToString (not bool)\n            in\n            Just\n                (Rule.errorWithFix\n                    { message = wrapInBackticks \"not\" ++ \" on a bool known to be \" ++ AstHelpers.boolToString bool ++ \" can be replaced by \" ++ notBoolAsString\n                    , details = [ \"You can replace this call by \" ++ notBoolAsString ++ \".\" ]\n                    }\n                    checkInfo.fnRange\n                    [ Fix.replaceRangeBy checkInfo.parentRange\n                        (qualifiedToString (qualify ( [ \"Basics\" ], notBoolAsString ) checkInfo))\n                    ]\n                )\n\n        Undetermined ->\n            Nothing\n\n\nisNotOnBooleanOperatorCheck : CheckInfo -> Maybe (Error {})\nisNotOnBooleanOperatorCheck checkInfo =\n    case Node.value checkInfo.firstArg of\n        Expression.ParenthesizedExpression (Node _ (Expression.OperatorApplication operator _ (Node leftRange _) (Node rightRange _))) ->\n            case isNegatableOperator operator of\n                Just replacement ->\n                    let\n                        operatorRange : Range\n                        operatorRange =\n                            findOperatorRange\n                                { operator = operator\n                                , commentRanges = checkInfo.commentRanges\n                                , extractSourceCode = checkInfo.extractSourceCode\n                                , leftRange = leftRange\n                                , rightRange = rightRange\n                                }\n                    in\n                    Just\n                        (Rule.errorWithFix\n                            { message = \"`not` is used on a negatable boolean operation\"\n                            , details = [ \"You can remove the `not` call and use `\" ++ replacement ++ \"` instead.\" ]\n                            }\n                            checkInfo.fnRange\n                            [ Fix.removeRange { start = checkInfo.fnRange.start, end = (Node.range checkInfo.firstArg).start }\n                            , Fix.replaceRangeBy operatorRange replacement\n                            ]\n                        )\n\n                Nothing ->\n                    Nothing\n\n        _ ->\n            Nothing\n\n\nisNegatableOperator : String -> Maybe String\nisNegatableOperator op =\n    case op of\n        \"<\" ->\n            Just \">=\"\n\n        \">\" ->\n            Just \"<=\"\n\n        \"<=\" ->\n            Just \">\"\n\n        \">=\" ->\n            Just \"<\"\n\n        \"==\" ->\n            Just \"/=\"\n\n        \"/=\" ->\n            Just \"==\"\n\n        _ ->\n            Nothing\n\n\nbasicsNotCompositionChecks : CompositionCheckInfo -> Maybe (Error {})\nbasicsNotCompositionChecks checkInfo =\n    toggleCompositionChecks ( [ \"Basics\" ], \"not\" ) checkInfo\n\n\norChecks : OperatorCheckInfo -> Maybe (Error {})\norChecks operatorCheckInfo =\n    firstThatConstructsJust\n        [ \\() -> or_isLeftSimplifiableError operatorCheckInfo\n        , \\() -> or_isRightSimplifiableError operatorCheckInfo\n        , \\() -> findSimilarConditionsError operatorCheckInfo\n        ]\n        ()\n\n\ntype RedundantConditionResolution\n    = RemoveFrom Location\n    | ReplaceByNoop Bool\n\n\nfindSimilarConditionsError : OperatorCheckInfo -> Maybe (Error {})\nfindSimilarConditionsError operatorCheckInfo =\n    let\n        conditionsOnTheRight : List ( RedundantConditionResolution, Node Expression )\n        conditionsOnTheRight =\n            listConditions\n                operatorCheckInfo.operator\n                (RemoveFrom operatorCheckInfo.leftRange.end)\n                operatorCheckInfo.right\n\n        errorsForNode : Node Expression -> Maybe (Error {})\n        errorsForNode nodeToCompareTo =\n            findMap\n                (areSimilarConditionsError\n                    operatorCheckInfo\n                    operatorCheckInfo.operator\n                    nodeToCompareTo\n                )\n                conditionsOnTheRight\n    in\n    operatorCheckInfo.left\n        |> listConditions operatorCheckInfo.operator (RemoveFrom operatorCheckInfo.leftRange.end)\n        |> findMap (Tuple.second >> errorsForNode)\n\n\nareSimilarConditionsError :\n    QualifyResources (Infer.Resources a)\n    -> String\n    -> Node Expression\n    -> ( RedundantConditionResolution, Node Expression )\n    -> Maybe (Error {})\nareSimilarConditionsError resources operator nodeToCompareTo ( redundantConditionResolution, nodeToLookAt ) =\n    case Normalize.compare resources nodeToCompareTo nodeToLookAt of\n        Normalize.ConfirmedEquality ->\n            Just (errorForRedundantCondition operator redundantConditionResolution nodeToLookAt resources)\n\n        Normalize.ConfirmedInequality ->\n            Nothing\n\n        Normalize.Unconfirmed ->\n            Nothing\n\n\nerrorForRedundantCondition : String -> RedundantConditionResolution -> Node a -> QualifyResources b -> Error {}\nerrorForRedundantCondition operator redundantConditionResolution node qualifyResources =\n    let\n        ( range, fix ) =\n            rangeAndFixForRedundantCondition redundantConditionResolution node qualifyResources\n    in\n    Rule.errorWithFix\n        { message = \"Condition is redundant\"\n        , details =\n            [ \"This condition is the same as another one found on the left side of the (\" ++ operator ++ \") operator, therefore one of them can be removed.\"\n            ]\n        }\n        range\n        fix\n\n\nrangeAndFixForRedundantCondition : RedundantConditionResolution -> Node a -> QualifyResources b -> ( Range, List Fix )\nrangeAndFixForRedundantCondition redundantConditionResolution (Node nodeRange _) qualifyResources =\n    case redundantConditionResolution of\n        RemoveFrom locationOfPrevElement ->\n            let\n                range : Range\n                range =\n                    { start = locationOfPrevElement\n                    , end = nodeRange.end\n                    }\n            in\n            ( range\n            , [ Fix.removeRange range ]\n            )\n\n        ReplaceByNoop noopValue ->\n            ( nodeRange\n            , [ Fix.replaceRangeBy nodeRange\n                    (qualifiedToString (qualify ( [ \"Basics\" ], AstHelpers.boolToString noopValue ) qualifyResources))\n              ]\n            )\n\n\nlistConditions : String -> RedundantConditionResolution -> Node Expression -> List ( RedundantConditionResolution, Node Expression )\nlistConditions operatorToLookFor redundantConditionResolution expressionNode =\n    case Node.value expressionNode of\n        Expression.ParenthesizedExpression expr ->\n            let\n                noopValue : Bool\n                noopValue =\n                    operatorToLookFor == \"&&\"\n            in\n            listConditions operatorToLookFor (ReplaceByNoop noopValue) expr\n\n        Expression.OperatorApplication operator _ left right ->\n            if operator == operatorToLookFor then\n                listConditions operatorToLookFor redundantConditionResolution left\n                    ++ listConditions operatorToLookFor (RemoveFrom (Node.range left).end) right\n\n            else\n                [ ( redundantConditionResolution, expressionNode ) ]\n\n        _ ->\n            [ ( redundantConditionResolution, expressionNode ) ]\n\n\nor_isLeftSimplifiableError : OperatorCheckInfo -> Maybe (Error {})\nor_isLeftSimplifiableError checkInfo =\n    case Evaluate.getBoolean checkInfo checkInfo.left of\n        Determined True ->\n            Just\n                (Rule.errorWithFix\n                    { message = \"Comparison is always True\"\n                    , details = alwaysSameDetails\n                    }\n                    checkInfo.parentRange\n                    [ Fix.removeRange\n                        { start = checkInfo.leftRange.end\n                        , end = checkInfo.rightRange.end\n                        }\n                    ]\n                )\n\n        Determined False ->\n            Just\n                (Rule.errorWithFix\n                    { message = unnecessaryMessage\n                    , details = unnecessaryDetails\n                    }\n                    checkInfo.parentRange\n                    [ Fix.removeRange\n                        { start = checkInfo.leftRange.start\n                        , end = checkInfo.rightRange.start\n                        }\n                    ]\n                )\n\n        Undetermined ->\n            Nothing\n\n\nor_isRightSimplifiableError : OperatorCheckInfo -> Maybe (Error {})\nor_isRightSimplifiableError checkInfo =\n    case Evaluate.getBoolean checkInfo checkInfo.right of\n        Determined True ->\n            Just\n                (Rule.errorWithFix\n                    { message = unnecessaryMessage\n                    , details = unnecessaryDetails\n                    }\n                    checkInfo.parentRange\n                    [ Fix.removeRange\n                        { start = checkInfo.leftRange.start\n                        , end = checkInfo.rightRange.start\n                        }\n                    ]\n                )\n\n        Determined False ->\n            Just\n                (Rule.errorWithFix\n                    { message = unnecessaryMessage\n                    , details = unnecessaryDetails\n                    }\n                    checkInfo.parentRange\n                    [ Fix.removeRange\n                        { start = checkInfo.leftRange.end\n                        , end = checkInfo.rightRange.end\n                        }\n                    ]\n                )\n\n        Undetermined ->\n            Nothing\n\n\nandChecks : OperatorCheckInfo -> Maybe (Error {})\nandChecks operatorCheckInfo =\n    firstThatConstructsJust\n        [ \\() -> and_isLeftSimplifiableError operatorCheckInfo\n        , \\() -> and_isRightSimplifiableError operatorCheckInfo\n        , \\() -> findSimilarConditionsError operatorCheckInfo\n        ]\n        ()\n\n\nand_isLeftSimplifiableError : OperatorCheckInfo -> Maybe (Error {})\nand_isLeftSimplifiableError checkInfo =\n    case Evaluate.getBoolean checkInfo checkInfo.left of\n        Determined True ->\n            Just\n                (Rule.errorWithFix\n                    { message = unnecessaryMessage\n                    , details = unnecessaryDetails\n                    }\n                    checkInfo.parentRange\n                    [ Fix.removeRange\n                        { start = checkInfo.leftRange.start\n                        , end = checkInfo.rightRange.start\n                        }\n                    ]\n                )\n\n        Determined False ->\n            Just\n                (Rule.errorWithFix\n                    { message = \"Comparison is always False\"\n                    , details = alwaysSameDetails\n                    }\n                    checkInfo.parentRange\n                    [ Fix.removeRange\n                        { start = checkInfo.leftRange.end\n                        , end = checkInfo.rightRange.end\n                        }\n                    ]\n                )\n\n        Undetermined ->\n            Nothing\n\n\nand_isRightSimplifiableError : OperatorCheckInfo -> Maybe (Error {})\nand_isRightSimplifiableError checkInfo =\n    case Evaluate.getBoolean checkInfo checkInfo.right of\n        Determined True ->\n            Just\n                (Rule.errorWithFix\n                    { message = unnecessaryMessage\n                    , details = unnecessaryDetails\n                    }\n                    checkInfo.parentRange\n                    [ Fix.removeRange\n                        { start = checkInfo.leftRange.end\n                        , end = checkInfo.rightRange.end\n                        }\n                    ]\n                )\n\n        Determined False ->\n            Just\n                (Rule.errorWithFix\n                    { message = \"Comparison is always False\"\n                    , details = alwaysSameDetails\n                    }\n                    checkInfo.parentRange\n                    [ Fix.removeRange\n                        { start = checkInfo.leftRange.start\n                        , end = checkInfo.rightRange.start\n                        }\n                    ]\n                )\n\n        Undetermined ->\n            Nothing\n\n\n\n-- EQUALITY\n\n\nequalityChecks : Bool -> OperatorCheckInfo -> Maybe (Error {})\nequalityChecks isEqual checkInfo =\n    if Evaluate.getBoolean checkInfo checkInfo.right == Determined isEqual then\n        Just\n            (Rule.errorWithFix\n                { message = \"Unnecessary comparison with boolean\"\n                , details = [ \"The result of the expression will be the same with or without the comparison.\" ]\n                }\n                (errorToRightRange checkInfo)\n                [ Fix.removeRange (fixToRightRange checkInfo) ]\n            )\n\n    else if Evaluate.getBoolean checkInfo checkInfo.left == Determined isEqual then\n        Just\n            (Rule.errorWithFix\n                { message = \"Unnecessary comparison with boolean\"\n                , details = [ \"The result of the expression will be the same with or without the comparison.\" ]\n                }\n                (errorToLeftRange checkInfo)\n                [ Fix.removeRange (fixToLeftRange checkInfo) ]\n            )\n\n    else\n        case\n            Maybe.map2 Tuple.pair\n                (AstHelpers.getSpecificFunctionCall ( [ \"Basics\" ], \"not\" ) checkInfo.lookupTable checkInfo.left)\n                (AstHelpers.getSpecificFunctionCall ( [ \"Basics\" ], \"not\" ) checkInfo.lookupTable checkInfo.right)\n        of\n            Just ( leftNot, rightNot ) ->\n                Just\n                    (Rule.errorWithFix\n                        { message = \"Unnecessary negation on both sides\"\n                        , details = [ \"Since both sides are negated using `not`, they are redundant and can be removed.\" ]\n                        }\n                        checkInfo.parentRange\n                        [ Fix.removeRange leftNot.fnRange, Fix.removeRange rightNot.fnRange ]\n                    )\n\n            _ ->\n                let\n                    inferred : Infer.Inferred\n                    inferred =\n                        Tuple.first checkInfo.inferredConstants\n\n                    normalizeAndInfer : Node Expression -> Node Expression\n                    normalizeAndInfer expressionNode =\n                        let\n                            normalizedExpressionNode : Node Expression\n                            normalizedExpressionNode =\n                                Normalize.normalize checkInfo expressionNode\n                        in\n                        case Infer.get (Node.value normalizedExpressionNode) inferred of\n                            Just expr ->\n                                Node Range.emptyRange expr\n\n                            Nothing ->\n                                normalizedExpressionNode\n\n                    normalizedLeft : Node Expression\n                    normalizedLeft =\n                        normalizeAndInfer checkInfo.left\n\n                    normalizedRight : Node Expression\n                    normalizedRight =\n                        normalizeAndInfer checkInfo.right\n                in\n                case Normalize.compareWithoutNormalization normalizedLeft normalizedRight of\n                    Normalize.ConfirmedEquality ->\n                        if checkInfo.expectNaN then\n                            Nothing\n\n                        else\n                            Just (comparisonError isEqual checkInfo)\n\n                    Normalize.ConfirmedInequality ->\n                        Just (comparisonError (not isEqual) checkInfo)\n\n                    Normalize.Unconfirmed ->\n                        Nothing\n\n\nalwaysSameDetails : List String\nalwaysSameDetails =\n    [ \"This condition will always result in the same value. You may have hardcoded a value or mistyped a condition.\"\n    ]\n\n\nunnecessaryMessage : String\nunnecessaryMessage =\n    \"Part of the expression is unnecessary\"\n\n\nunnecessaryDetails : List String\nunnecessaryDetails =\n    [ \"A part of this condition is unnecessary. You can remove it and it would not impact the behavior of the program.\"\n    ]\n\n\n\n-- COMPARISONS\n\n\ncomparisonChecks : (Float -> Float -> Bool) -> OperatorCheckInfo -> Maybe (Error {})\ncomparisonChecks operatorFunction operatorCheckInfo =\n    case\n        Maybe.map2 operatorFunction\n            (Normalize.getNumberValue operatorCheckInfo.left)\n            (Normalize.getNumberValue operatorCheckInfo.right)\n    of\n        Just bool ->\n            Just (comparisonError bool operatorCheckInfo)\n\n        Nothing ->\n            Nothing\n\n\ncomparisonError : Bool -> QualifyResources { a | parentRange : Range } -> Error {}\ncomparisonError bool checkInfo =\n    let\n        boolAsString : String\n        boolAsString =\n            AstHelpers.boolToString bool\n    in\n    Rule.errorWithFix\n        { message = \"Comparison is always \" ++ boolAsString\n        , details =\n            [ \"Based on the values and/or the context, we can determine that the value of this operation will always be \" ++ boolAsString ++ \".\"\n            ]\n        }\n        checkInfo.parentRange\n        [ Fix.replaceRangeBy checkInfo.parentRange\n            (qualifiedToString (qualify ( [ \"Basics\" ], boolAsString ) checkInfo))\n        ]\n\n\n\n-- BASICS\n\n\nbasicsIdentityChecks : CheckInfo -> Maybe (Error {})\nbasicsIdentityChecks checkInfo =\n    Just\n        (Rule.errorWithFix\n            { message = \"`identity` should be removed\"\n            , details = [ \"`identity` can be a useful function to be passed as arguments to other functions, but calling it manually with an argument is the same thing as writing the argument on its own.\" ]\n            }\n            checkInfo.fnRange\n            (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.firstArg })\n        )\n\n\nbasicsIdentityCompositionErrorMessage : { message : String, details : List String }\nbasicsIdentityCompositionErrorMessage =\n    { message = \"`identity` should be removed\"\n    , details = [ \"Composing a function with `identity` is the same as simplify referencing the function.\" ]\n    }\n\n\nbasicsIdentityCompositionChecks : CompositionCheckInfo -> Maybe (Error {})\nbasicsIdentityCompositionChecks checkInfo =\n    if AstHelpers.isIdentity checkInfo.lookupTable checkInfo.later then\n        Just\n            (Rule.errorWithFix\n                basicsIdentityCompositionErrorMessage\n                (Node.range checkInfo.later)\n                (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.earlier })\n            )\n\n    else if AstHelpers.isIdentity checkInfo.lookupTable checkInfo.earlier then\n        Just\n            (Rule.errorWithFix\n                basicsIdentityCompositionErrorMessage\n                (Node.range checkInfo.earlier)\n                (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.later })\n            )\n\n    else\n        Nothing\n\n\nbasicsAlwaysChecks : CheckInfo -> Maybe (Error {})\nbasicsAlwaysChecks checkInfo =\n    case secondArg checkInfo of\n        Just (Node secondArgRange _) ->\n            Just\n                (Rule.errorWithFix\n                    { message = \"Expression can be replaced by the first argument given to `always`\"\n                    , details = [ \"The second argument will be ignored because of the `always` call.\" ]\n                    }\n                    checkInfo.fnRange\n                    (replaceBySubExpressionFix\n                        (Range.combine [ checkInfo.fnRange, Node.range checkInfo.firstArg, secondArgRange ])\n                        checkInfo.firstArg\n                    )\n                )\n\n        Nothing ->\n            Nothing\n\n\nbasicsAlwaysCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nbasicsAlwaysCompositionChecks checkInfo =\n    case checkInfo.later.args of\n        _ :: [] ->\n            Just\n                { info =\n                    { message = \"Function composed with always will be ignored\"\n                    , details = [ \"`always` will swallow the function composed into it.\" ]\n                    }\n                , fix =\n                    keepOnlyFix { parentRange = checkInfo.parentRange, keep = checkInfo.later.range }\n                }\n\n        _ ->\n            Nothing\n\n\n\n-- TUPLE\n\n\ntuplePairChecks : CheckInfo -> Maybe (Error {})\ntuplePairChecks checkInfo =\n    case checkInfo.argsAfterFirst of\n        tuplePairCallSecondArg :: _ ->\n            let\n                firstRange : Range\n                firstRange =\n                    Node.range checkInfo.firstArg\n\n                secondRange : Range\n                secondRange =\n                    Node.range tuplePairCallSecondArg\n            in\n            case Range.compareLocations firstRange.end secondRange.start of\n                LT ->\n                    Just\n                        (Rule.errorWithFix\n                            { message = \"Fully constructed \" ++ qualifiedToString (qualify checkInfo.fn defaultQualifyResources) ++ \" can be replaced by tuple literal\"\n                            , details = [ \"You can replace this call by a tuple literal ( _, _ ). Consistently using ( _, _ ) to create a tuple is more idiomatic in elm.\" ]\n                            }\n                            checkInfo.fnRange\n                            (if checkInfo.parentRange.start.row /= checkInfo.parentRange.end.row then\n                                [ Fix.replaceRangeBy { start = checkInfo.parentRange.start, end = firstRange.start }\n                                    (\"(\\n\" ++ String.repeat (firstRange.start.column - 1) \" \")\n                                , Fix.replaceRangeBy { start = firstRange.end, end = secondRange.start }\n                                    (\"\\n\"\n                                        ++ String.repeat (checkInfo.parentRange.start.column - 1) \" \"\n                                        ++ \",\\n\"\n                                        ++ String.repeat (secondRange.start.column - 1) \" \"\n                                    )\n                                , Fix.replaceRangeBy { start = secondRange.end, end = checkInfo.parentRange.end }\n                                    (\"\\n\"\n                                        ++ String.repeat (checkInfo.parentRange.start.column - 1) \" \"\n                                        ++ \")\"\n                                    )\n                                ]\n\n                             else\n                                [ Fix.replaceRangeBy { start = checkInfo.parentRange.start, end = firstRange.start } \"( \"\n                                , Fix.replaceRangeBy { start = firstRange.end, end = secondRange.start } \", \"\n                                , Fix.replaceRangeBy { start = secondRange.end, end = checkInfo.parentRange.end } \" )\"\n                                ]\n                            )\n                        )\n\n                EQ ->\n                    Nothing\n\n                GT ->\n                    Nothing\n\n        [] ->\n            Nothing\n\n\ntupleFirstChecks : CheckInfo -> Maybe (Error {})\ntupleFirstChecks checkInfo =\n    tuplePartChecks { access = .first, description = \"first\" } checkInfo\n\n\ntupleFirstCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\ntupleFirstCompositionChecks checkInfo =\n    case ( checkInfo.earlier.fn, checkInfo.earlier.args ) of\n        ( ( [ \"Tuple\" ], \"pair\" ), first :: [] ) ->\n            Just\n                { info =\n                    { message = qualifiedToString (qualify checkInfo.earlier.fn defaultQualifyResources) ++ \" with a first part, then \" ++ qualifiedToString (qualify checkInfo.later.fn defaultQualifyResources) ++ \" will always result in that first part\"\n                    , details = [ \"You can replace this call by always with the first argument given to \" ++ qualifiedToString (qualify checkInfo.earlier.fn defaultQualifyResources) ++ \".\" ]\n                    }\n                , fix =\n                    replaceBySubExpressionFix checkInfo.parentRange first\n                        ++ [ Fix.insertAt checkInfo.parentRange.start\n                                (qualifiedToString (qualify ( [ \"Basics\" ], \"always\" ) checkInfo) ++ \" \")\n                           ]\n                }\n\n        _ ->\n            Nothing\n\n\ntupleSecondChecks : CheckInfo -> Maybe (Error {})\ntupleSecondChecks checkInfo =\n    tuplePartChecks { access = .second, description = \"second\" } checkInfo\n\n\ntupleSecondCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\ntupleSecondCompositionChecks checkInfo =\n    case ( checkInfo.earlier.fn, checkInfo.earlier.args ) of\n        ( ( [ \"Tuple\" ], \"pair\" ), _ :: [] ) ->\n            Just\n                { info =\n                    { message = qualifiedToString (qualify checkInfo.earlier.fn defaultQualifyResources) ++ \" with a first part, then \" ++ qualifiedToString (qualify checkInfo.later.fn defaultQualifyResources) ++ \" will always result in the incoming second part\"\n                    , details = [ \"You can replace this call by identity.\" ]\n                    }\n                , fix =\n                    [ Fix.replaceRangeBy checkInfo.parentRange\n                        (qualifiedToString (qualify ( [ \"Basics\" ], \"identity\" ) checkInfo))\n                    ]\n                }\n\n        _ ->\n            Nothing\n\n\ntuplePartChecks :\n    { access : { first : Node Expression, second : Node Expression } -> Node Expression\n    , description : String\n    }\n    -> CheckInfo\n    -> Maybe (Error {})\ntuplePartChecks partConfig checkInfo =\n    Maybe.map\n        (\\tuple ->\n            Rule.errorWithFix\n                { message = qualifiedToString (qualify checkInfo.fn defaultQualifyResources) ++ \" on a known tuple will result in the tuple's \" ++ partConfig.description ++ \" part\"\n                , details = [ \"You can replace this call by the tuple's \" ++ partConfig.description ++ \" part.\" ]\n                }\n                checkInfo.fnRange\n                (replaceBySubExpressionFix checkInfo.parentRange (tuple |> partConfig.access))\n        )\n        (AstHelpers.getTuple2 checkInfo.firstArg checkInfo.lookupTable)\n\n\n\n-- STRING\n\n\nstringToListChecks : CheckInfo -> Maybe (Error {})\nstringToListChecks checkInfo =\n    onCallToInverseReturnsItsArgumentCheck ( [ \"String\" ], \"fromList\" ) checkInfo\n\n\nstringFromListChecks : CheckInfo -> Maybe (Error {})\nstringFromListChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            callOnEmptyReturnsCheck { on = checkInfo.firstArg, resultAsString = \\_ -> emptyStringAsString }\n                listCollection\n                checkInfo\n        , \\() -> wrapperFromListSingletonChecks stringCollection checkInfo\n        , \\() -> onCallToInverseReturnsItsArgumentCheck ( [ \"String\" ], \"toList\" ) checkInfo\n        ]\n        ()\n\n\nstringFromListCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nstringFromListCompositionChecks checkInfo =\n    wrapperFromListSingletonCompositionChecks stringCollection checkInfo\n\n\nstringConcatChecks : CheckInfo -> Maybe (Error {})\nstringConcatChecks checkInfo =\n    callOnEmptyReturnsCheck { on = checkInfo.firstArg, resultAsString = \\_ -> emptyStringAsString } listCollection checkInfo\n\n\nstringWordsChecks : CheckInfo -> Maybe (Error {})\nstringWordsChecks checkInfo =\n    callOnEmptyReturnsCheck { on = checkInfo.firstArg, resultAsString = \\_ -> \"[]\" }\n        stringCollection\n        checkInfo\n\n\nstringLinesChecks : CheckInfo -> Maybe (Error {})\nstringLinesChecks checkInfo =\n    callOnEmptyReturnsCheck { on = checkInfo.firstArg, resultAsString = \\_ -> \"[]\" }\n        stringCollection\n        checkInfo\n\n\nstringReverseChecks : CheckInfo -> Maybe (Error {})\nstringReverseChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> emptiableReverseChecks stringCollection checkInfo\n        , \\() -> callOnWrappedDoesNotChangeItCheck checkInfo.firstArg stringCollection checkInfo\n        ]\n        ()\n\n\nstringReverseCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nstringReverseCompositionChecks checkInfo =\n    compositionAfterWrapIsUnnecessaryCheck stringCollection checkInfo\n\n\nstringSliceChecks : CheckInfo -> Maybe (Error {})\nstringSliceChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\stringArg ->\n                    callOnEmptyReturnsEmptyCheck stringArg stringCollection checkInfo\n                )\n                (thirdArg checkInfo)\n        , \\() ->\n            case secondArg checkInfo of\n                Just endArg ->\n                    firstThatConstructsJust\n                        [ \\() ->\n                            if Normalize.areAllTheSame checkInfo checkInfo.firstArg [ endArg ] then\n                                Just\n                                    (alwaysResultsInUnparenthesizedConstantError \"String.slice with equal start and end index\"\n                                        { replacement = \\_ -> emptyStringAsString, lastArg = thirdArg checkInfo }\n                                        checkInfo\n                                    )\n\n                            else\n                                Nothing\n                        , \\() ->\n                            case Evaluate.getInt checkInfo endArg of\n                                Just endInt ->\n                                    firstThatConstructsJust\n                                        [ \\() ->\n                                            case endInt of\n                                                0 ->\n                                                    Just\n                                                        (alwaysResultsInUnparenthesizedConstantError \"String.slice with end index 0\"\n                                                            { replacement = \\_ -> emptyStringAsString, lastArg = thirdArg checkInfo }\n                                                            checkInfo\n                                                        )\n\n                                                _ ->\n                                                    Nothing\n                                        , \\() ->\n                                            case Evaluate.getInt checkInfo checkInfo.firstArg of\n                                                Just startInt ->\n                                                    if startInt > endInt then\n                                                        if startInt >= 0 && endInt >= 0 then\n                                                            Just\n                                                                (alwaysResultsInUnparenthesizedConstantError \"String.slice with a start index greater than the end index\"\n                                                                    { replacement = \\_ -> emptyStringAsString, lastArg = thirdArg checkInfo }\n                                                                    checkInfo\n                                                                )\n\n                                                        else if startInt <= -1 && endInt <= -1 then\n                                                            Just\n                                                                (alwaysResultsInUnparenthesizedConstantError \"String.slice with a negative start index closer to the right than the negative end index\"\n                                                                    { replacement = \\_ -> emptyStringAsString, lastArg = thirdArg checkInfo }\n                                                                    checkInfo\n                                                                )\n\n                                                        else\n                                                            Nothing\n\n                                                    else\n                                                        Nothing\n\n                                                Nothing ->\n                                                    Nothing\n                                        ]\n                                        ()\n\n                                Nothing ->\n                                    Nothing\n                        ]\n                        ()\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\nstringLeftChecks : CheckInfo -> Maybe (Error {})\nstringLeftChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\wrapperArg -> callOnEmptyReturnsEmptyCheck wrapperArg stringCollection checkInfo)\n                (secondArg checkInfo)\n        , \\() ->\n            case Evaluate.getInt checkInfo checkInfo.firstArg of\n                Just length ->\n                    callWithNonPositiveIntCanBeReplacedByCheck\n                        { int = length\n                        , intDescription = \"length\"\n                        , replacement = \\_ -> emptyStringAsString\n                        , lastArg = secondArg checkInfo\n                        }\n                        checkInfo\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\ncallWithNonPositiveIntCanBeReplacedByCheck :\n    { int : number\n    , intDescription : String\n    , replacement : QualifyResources {} -> String\n    , lastArg : Maybe a\n    }\n    -> CheckInfo\n    -> Maybe (Error {})\ncallWithNonPositiveIntCanBeReplacedByCheck config checkInfo =\n    if config.int <= 0 then\n        let\n            lengthDescription : String\n            lengthDescription =\n                if config.int < 0 then\n                    \"negative \" ++ config.intDescription\n\n                else\n                    config.intDescription ++ \" 0\"\n        in\n        Just\n            (alwaysResultsInUnparenthesizedConstantError (qualifiedToString checkInfo.fn ++ \" with \" ++ lengthDescription)\n                { replacement = config.replacement, lastArg = config.lastArg }\n                checkInfo\n            )\n\n    else\n        Nothing\n\n\nstringRightChecks : CheckInfo -> Maybe (Error {})\nstringRightChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\stringArg -> callOnEmptyReturnsEmptyCheck stringArg stringCollection checkInfo)\n                (secondArg checkInfo)\n        , \\() ->\n            case Evaluate.getInt checkInfo checkInfo.firstArg of\n                Just length ->\n                    callWithNonPositiveIntCanBeReplacedByCheck\n                        { int = length\n                        , intDescription = \"length\"\n                        , replacement = \\_ -> emptyStringAsString\n                        , lastArg = secondArg checkInfo\n                        }\n                        checkInfo\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\nstringJoinChecks : CheckInfo -> Maybe (Error {})\nstringJoinChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\listArg ->\n                    callOnEmptyReturnsCheck { on = listArg, resultAsString = \\_ -> emptyStringAsString } listCollection checkInfo\n                )\n                (secondArg checkInfo)\n        , \\() ->\n            case Node.value checkInfo.firstArg of\n                Expression.Literal \"\" ->\n                    let\n                        replacementFn : ( ModuleName, String )\n                        replacementFn =\n                            ( [ \"String\" ], \"concat\" )\n                    in\n                    Just\n                        (Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" with separator \\\"\\\" is the same as \" ++ qualifiedToString replacementFn\n                            , details = [ \"You can replace this call by \" ++ qualifiedToString replacementFn ++ \".\" ]\n                            }\n                            checkInfo.fnRange\n                            [ Fix.replaceRangeBy { start = checkInfo.fnRange.start, end = (Node.range checkInfo.firstArg).end }\n                                (qualifiedToString (qualify replacementFn checkInfo))\n                            ]\n                        )\n\n                _ ->\n                    Nothing\n        ]\n        ()\n\n\nstringRepeatChecks : CheckInfo -> Maybe (Error {})\nstringRepeatChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            case secondArg checkInfo of\n                Just (Node _ (Expression.Literal \"\")) ->\n                    Just\n                        (Rule.errorWithFix\n                            { message = \"String.repeat with \" ++ emptyStringAsString ++ \" will result in \" ++ emptyStringAsString\n                            , details = [ \"You can replace this call by \" ++ emptyStringAsString ++ \".\" ]\n                            }\n                            checkInfo.fnRange\n                            [ Fix.replaceRangeBy checkInfo.parentRange emptyStringAsString ]\n                        )\n\n                _ ->\n                    Nothing\n        , \\() ->\n            case Evaluate.getInt checkInfo checkInfo.firstArg of\n                Just intValue ->\n                    firstThatConstructsJust\n                        [ \\() ->\n                            case intValue of\n                                1 ->\n                                    Just\n                                        (alwaysReturnsLastArgError \"String.repeat 1\"\n                                            { represents = \"string to repeat\" }\n                                            checkInfo\n                                        )\n\n                                _ ->\n                                    Nothing\n                        , \\() ->\n                            callWithNonPositiveIntCanBeReplacedByCheck\n                                { int = intValue\n                                , intDescription = \"length\"\n                                , replacement = \\_ -> emptyStringAsString\n                                , lastArg = secondArg checkInfo\n                                }\n                                checkInfo\n                        ]\n                        ()\n\n                _ ->\n                    Nothing\n        ]\n        ()\n\n\nstringReplaceChecks : CheckInfo -> Maybe (Error {})\nstringReplaceChecks checkInfo =\n    case secondArg checkInfo of\n        Just replacementArg ->\n            firstThatConstructsJust\n                [ \\() ->\n                    Maybe.andThen\n                        (\\stringArg ->\n                            firstThatConstructsJust\n                                [ \\() -> callOnEmptyReturnsEmptyCheck stringArg stringCollection checkInfo\n                                , \\() ->\n                                    case ( checkInfo.firstArg, stringArg ) of\n                                        ( Node _ (Expression.Literal toReplace), Node _ (Expression.Literal third) ) ->\n                                            if not (String.contains \"\\u{000D}\" toReplace) && not (String.contains toReplace third) then\n                                                Just\n                                                    (Rule.errorWithFix\n                                                        { message = \"String.replace with a pattern not present in the given string will result in the given string\"\n                                                        , details = [ \"You can replace this call by the given string itself.\" ]\n                                                        }\n                                                        checkInfo.fnRange\n                                                        (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range stringArg })\n                                                    )\n\n                                            else\n                                                Nothing\n\n                                        _ ->\n                                            Nothing\n                                ]\n                                ()\n                        )\n                        (thirdArg checkInfo)\n                , \\() ->\n                    case Normalize.compare checkInfo checkInfo.firstArg replacementArg of\n                        Normalize.ConfirmedEquality ->\n                            Just\n                                (alwaysReturnsLastArgError\n                                    (qualifiedToString checkInfo.fn ++ \" where the pattern to replace and the replacement are equal\")\n                                    { represents = \"string\" }\n                                    checkInfo\n                                )\n\n                        _ ->\n                            Nothing\n                ]\n                ()\n\n        Nothing ->\n            Nothing\n\n\n\n-- MAYBE FUNCTIONS\n\n\nmaybeMapChecks : CheckInfo -> Maybe (Error {})\nmaybeMapChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> emptiableMapChecks maybeWithJustAsWrap checkInfo\n        , \\() -> mapWrapChecks maybeWithJustAsWrap checkInfo\n        ]\n        ()\n\n\nmaybeMapCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nmaybeMapCompositionChecks checkInfo =\n    wrapToMapCompositionChecks maybeWithJustAsWrap checkInfo\n\n\n\n-- RESULT FUNCTIONS\n\n\nresultMapChecks : CheckInfo -> Maybe (Error {})\nresultMapChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> emptiableMapChecks resultWithOkAsWrap checkInfo\n        , \\() -> mapWrapChecks resultWithOkAsWrap checkInfo\n        ]\n        ()\n\n\nresultMapCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nresultMapCompositionChecks checkInfo =\n    wrapToMapCompositionChecks resultWithOkAsWrap checkInfo\n\n\nresultMapNChecks : { n : Int } -> CheckInfo -> Maybe (Error {})\nresultMapNChecks config checkInfo =\n    firstThatConstructsJust\n        [ \\() -> wrapperMapNChecks config resultWithOkAsWrap checkInfo\n        , \\() -> mapNOrFirstEmptyConstructionChecks config resultWithOkAsWrap checkInfo\n        ]\n        ()\n\n\nmapWrapErrorInfo :\n    ( ModuleName, String )\n    -> WrapperProperties otherProperties\n    -> { message : String, details : List String }\nmapWrapErrorInfo mapFn wrapper =\n    let\n        wrapFnInErrorInfo : String\n        wrapFnInErrorInfo =\n            qualifiedToString (qualify ( wrapper.moduleName, wrapper.wrap.fnName ) defaultQualifyResources)\n    in\n    { message = qualifiedToString mapFn ++ \" on \" ++ descriptionForIndefinite wrapper.wrap.description ++ \" will result in \" ++ wrapFnInErrorInfo ++ \" with the function applied to the value inside\"\n    , details = [ \"You can replace this call by \" ++ wrapFnInErrorInfo ++ \" with the function directly applied to the value inside \" ++ descriptionForDefinite \"the\" wrapper.wrap.description ++ \" itself.\" ]\n    }\n\n\nresultMapErrorChecks : CheckInfo -> Maybe (Error {})\nresultMapErrorChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> emptiableMapChecks resultWithErrAsWrap checkInfo\n        , \\() -> mapWrapChecks resultWithErrAsWrap checkInfo\n        ]\n        ()\n\n\nresultMapErrorCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nresultMapErrorCompositionChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> wrapToMapCompositionChecks resultWithErrAsWrap checkInfo\n        , \\() ->\n            case checkInfo.later.args of\n                _ :: [] ->\n                    case checkInfo.earlier.fn of\n                        ( [ \"Result\" ], \"Ok\" ) ->\n                            Just\n                                { info =\n                                    operationDoesNotChangeSpecificLastArgErrorInfo\n                                        { fn = ( [ \"Result\" ], \"mapError\" )\n                                        , specific = resultWithErrAsWrap.empty.description\n                                        }\n                                , fix =\n                                    keepOnlyFix { parentRange = checkInfo.parentRange, keep = checkInfo.earlier.fnRange }\n                                }\n\n                        _ ->\n                            Nothing\n\n                _ ->\n                    Nothing\n        ]\n        ()\n\n\n\n-- LIST FUNCTIONS\n\n\nlistConcatChecks : CheckInfo -> Maybe (Error {})\nlistConcatChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> callOnEmptyReturnsEmptyCheck checkInfo.firstArg listCollection checkInfo\n        , \\() -> callOnWrapReturnsItsValue checkInfo.firstArg listCollection checkInfo\n        , \\() -> irrelevantEmptyElementInGivenListArgCheck checkInfo.firstArg listCollection checkInfo\n        , \\() ->\n            case Node.value checkInfo.firstArg of\n                Expression.ListExpr list ->\n                    case list of\n                        firstListElement :: restOfListElements ->\n                            firstThatConstructsJust\n                                [ \\() ->\n                                    case traverse AstHelpers.getListLiteral list of\n                                        Just _ ->\n                                            Just\n                                                (Rule.errorWithFix\n                                                    { message = \"Expression could be simplified to be a single List\"\n                                                    , details = [ \"Try moving all the elements into a single list.\" ]\n                                                    }\n                                                    checkInfo.fnRange\n                                                    (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.firstArg }\n                                                        ++ List.concatMap removeBoundariesFix (firstListElement :: restOfListElements)\n                                                    )\n                                                )\n\n                                        Nothing ->\n                                            Nothing\n                                , \\() ->\n                                    case findConsecutiveListLiterals firstListElement restOfListElements of\n                                        firstFix :: fixesAfterFirst ->\n                                            Just\n                                                (Rule.errorWithFix\n                                                    { message = \"Consecutive literal lists can be merged\"\n                                                    , details = [ \"Try moving all the elements from consecutive list literals so that they form a single list.\" ]\n                                                    }\n                                                    checkInfo.fnRange\n                                                    (firstFix :: fixesAfterFirst)\n                                                )\n\n                                        [] ->\n                                            Nothing\n                                ]\n                                ()\n\n                        _ ->\n                            Nothing\n\n                _ ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getSpecificFunctionCall ( [ \"List\" ], \"map\" ) checkInfo.lookupTable checkInfo.firstArg of\n                Just listMapArg ->\n                    let\n                        combinedFn : ( ModuleName, String )\n                        combinedFn =\n                            ( [ \"List\" ], \"concatMap\" )\n                    in\n                    Just\n                        (Rule.errorWithFix\n                            { message = qualifiedToString ( [ \"List\" ], \"map\" ) ++ \" and \" ++ qualifiedToString checkInfo.fn ++ \" can be combined using \" ++ qualifiedToString combinedFn\n                            , details = [ qualifiedToString combinedFn ++ \" is meant for this exact purpose and will also be faster.\" ]\n                            }\n                            checkInfo.fnRange\n                            (keepOnlyFix { parentRange = checkInfo.parentRange, keep = listMapArg.nodeRange }\n                                ++ [ Fix.replaceRangeBy listMapArg.fnRange\n                                        (qualifiedToString (qualify combinedFn checkInfo))\n                                   ]\n                            )\n                        )\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\nirrelevantEmptyElementInGivenListArgCheck :\n    Node Expression\n    ->\n        { otherProperties\n            | empty :\n                { empty\n                    | description : Description\n                    , is : ModuleNameLookupTable -> Node Expression -> Bool\n                }\n        }\n    -> CheckInfo\n    -> Maybe (Error {})\nirrelevantEmptyElementInGivenListArgCheck listArg emptiableElement checkInfo =\n    case AstHelpers.getListLiteral listArg of\n        Just list ->\n            case findMapNeighboring (getEmpty checkInfo.lookupTable emptiableElement) list of\n                Just emptyLiteralAndNeighbors ->\n                    Just\n                        (Rule.errorWithFix\n                            { message = qualifiedToString (qualify checkInfo.fn defaultQualifyResources) ++ \" on a list containing an irrelevant \" ++ descriptionWithoutArticle emptiableElement.empty.description\n                            , details = [ \"Including \" ++ descriptionForDefinite \"the\" emptiableElement.empty.description ++ \" in the list does not change the result of this call. You can remove the \" ++ descriptionWithoutArticle emptiableElement.empty.description ++ \" element.\" ]\n                            }\n                            emptyLiteralAndNeighbors.found.range\n                            (listLiteralElementRemoveFix emptyLiteralAndNeighbors)\n                        )\n\n                Nothing ->\n                    Nothing\n\n        Nothing ->\n            Nothing\n\n\nfindConsecutiveListLiterals : Node Expression -> List (Node Expression) -> List Fix\nfindConsecutiveListLiterals firstListElement restOfListElements =\n    case ( firstListElement, restOfListElements ) of\n        ( Node firstRange (Expression.ListExpr _), ((Node secondRange (Expression.ListExpr _)) as second) :: rest ) ->\n            Fix.replaceRangeBy\n                { start = { row = firstRange.end.row, column = firstRange.end.column - 1 }\n                , end = { row = secondRange.start.row, column = secondRange.start.column + 1 }\n                }\n                \", \"\n                :: findConsecutiveListLiterals second rest\n\n        ( _, x :: xs ) ->\n            findConsecutiveListLiterals x xs\n\n        _ ->\n            []\n\n\nlistConcatMapChecks : CheckInfo -> Maybe (Error {})\nlistConcatMapChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            operationWithIdentityCanBeReplacedChecks { replacementFn = ( [ \"List\" ], \"concat\" ) } checkInfo\n        , \\() -> emptiableAndThenChecks listCollection checkInfo\n        , \\() -> wrapperAndThenChecks listCollection checkInfo\n        ]\n        ()\n\n\n{-| Turn `yourFn identity` into `replacementFn`. If `replacementFn` should be `identity`, use `alwaysReturnsLastArgError` instead\n\nCan be used to for example\n\n  - turn `traverse identity` into `sequence`\n  - turn `List.filterMap identity` into `Maybe.Extra.values`\n  - turn `List.Extra.minimumBy identity` into `List.minimum`\n\n-}\noperationWithIdentityCanBeReplacedChecks : { replacementFn : ( ModuleName, String ) } -> CheckInfo -> Maybe (Error {})\noperationWithIdentityCanBeReplacedChecks config checkInfo =\n    if AstHelpers.isIdentity checkInfo.lookupTable checkInfo.firstArg then\n        Just\n            (Rule.errorWithFix\n                { message = qualifiedToString checkInfo.fn ++ \" with an identity function is the same as \" ++ qualifiedToString config.replacementFn\n                , details = [ \"You can replace this call by \" ++ qualifiedToString config.replacementFn ++ \".\" ]\n                }\n                checkInfo.fnRange\n                [ Fix.replaceRangeBy\n                    { start = checkInfo.fnRange.start, end = (Node.range checkInfo.firstArg).end }\n                    (qualifiedToString (qualify config.replacementFn checkInfo))\n                ]\n            )\n\n    else\n        Nothing\n\n\nlistConcatCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nlistConcatCompositionChecks checkInfo =\n    mapToOperationCanBeCombinedCompositionChecks\n        { mapFn = ( [ \"List\" ], \"map\" ), combinedFn = ( [ \"List\" ], \"concatMap\" ) }\n        checkInfo\n\n\n{-| Turn `map f >> yourOperation` into `combinedOperation f`.\n\nCan be used to for example\nturn `map f >> sequence` into `traverse f`\nor `map f >> Maybe.Extra.values` into `List.filterMap f`.\n\n-}\nmapToOperationCanBeCombinedCompositionChecks : { mapFn : ( ModuleName, String ), combinedFn : ( ModuleName, String ) } -> CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nmapToOperationCanBeCombinedCompositionChecks config checkInfo =\n    case ( checkInfo.earlier.fn == config.mapFn, checkInfo.earlier.args ) of\n        ( True, _ :: [] ) ->\n            Just\n                { info =\n                    { message = qualifiedToString config.mapFn ++ \" and \" ++ qualifiedToString checkInfo.later.fn ++ \" can be combined using \" ++ qualifiedToString config.combinedFn\n                    , details = [ qualifiedToString config.combinedFn ++ \" is meant for this exact purpose and will also be faster.\" ]\n                    }\n                , fix =\n                    Fix.replaceRangeBy checkInfo.earlier.fnRange\n                        (qualifiedToString (qualify config.combinedFn checkInfo))\n                        :: keepOnlyFix { parentRange = checkInfo.parentRange, keep = checkInfo.earlier.range }\n                }\n\n        _ ->\n            Nothing\n\n\nlistIndexedMapChecks : CheckInfo -> Maybe (Error {})\nlistIndexedMapChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\listArg ->\n                    callOnEmptyReturnsEmptyCheck listArg listCollection checkInfo\n                )\n                (secondArg checkInfo)\n        , \\() -> operationWithExtraArgChecks { operationWithoutExtraArg = ( [ \"List\" ], \"map\" ) } checkInfo\n        ]\n        ()\n\n\n{-| Map where the usual map function has an extra argument with special information.\n\nFor example `indexedMap` also supplied an index. Not using the index would be identical to `map`.\n\nAnother example would be [`List.Extra.indexedFoldl`](https://package.elm-lang.org/packages/elm-community/list-extra/latest/List-Extra#indexedFoldl) which also supplies the current index.\nNot using the path would be identical to `List.foldl`.\n\n-}\noperationWithExtraArgChecks : { operationWithoutExtraArg : ( ModuleName, String ) } -> CheckInfo -> Maybe (Error {})\noperationWithExtraArgChecks config checkInfo =\n    case getReplaceAlwaysByItsResultFix checkInfo.lookupTable checkInfo.firstArg of\n        Just replaceAlwaysByFunctionResult ->\n            Just\n                (Rule.errorWithFix\n                    { message = qualifiedToString checkInfo.fn ++ \" with a function that ignores the first argument is the same as \" ++ qualifiedToString config.operationWithoutExtraArg\n                    , details = [ \"You can replace this call by \" ++ qualifiedToString config.operationWithoutExtraArg ++ \".\" ]\n                    }\n                    checkInfo.fnRange\n                    (Fix.replaceRangeBy checkInfo.fnRange\n                        (qualifiedToString (qualify config.operationWithoutExtraArg checkInfo))\n                        :: replaceAlwaysByFunctionResult\n                    )\n                )\n\n        Nothing ->\n            Nothing\n\n\ngetReplaceAlwaysByItsResultFix : ModuleNameLookupTable -> Node Expression -> Maybe (List Fix)\ngetReplaceAlwaysByItsResultFix lookupTable expressionNode =\n    case AstHelpers.removeParens expressionNode of\n        Node _ (Expression.LambdaExpression lambda) ->\n            case lambda.args of\n                firstArg :: argsAfterFirst ->\n                    case AstHelpers.removeParensFromPattern firstArg of\n                        Node _ Pattern.AllPattern ->\n                            case argsAfterFirst of\n                                [] ->\n                                    Just (keepOnlyFix { parentRange = Node.range expressionNode, keep = Node.range lambda.expression })\n\n                                (Node secondRange _) :: _ ->\n                                    Just\n                                        [ Fix.removeRange { start = (Node.range firstArg).start, end = secondRange.start } ]\n\n                        _ ->\n                            Nothing\n\n                [] ->\n                    Nothing\n\n        _ ->\n            case AstHelpers.getSpecificFunctionCall ( [ \"Basics\" ], \"always\" ) lookupTable expressionNode of\n                Just alwaysCall ->\n                    Just\n                        (replaceBySubExpressionFix alwaysCall.nodeRange alwaysCall.firstArg)\n\n                Nothing ->\n                    Nothing\n\n\nlistIntersperseChecks : CheckInfo -> Maybe (Error {})\nlistIntersperseChecks checkInfo =\n    case secondArg checkInfo of\n        Just listArg ->\n            firstThatConstructsJust\n                [ \\() -> callOnEmptyReturnsEmptyCheck listArg listCollection checkInfo\n                , \\() -> callOnWrappedDoesNotChangeItCheck listArg listCollection checkInfo\n                ]\n                ()\n\n        Nothing ->\n            Nothing\n\n\nlistIntersperseCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nlistIntersperseCompositionChecks checkInfo =\n    compositionAfterWrapIsUnnecessaryCheck listCollection checkInfo\n\n\nlistHeadChecks : CheckInfo -> Maybe (Error {})\nlistHeadChecks checkInfo =\n    let\n        listArg : Node Expression\n        listArg =\n            checkInfo.firstArg\n    in\n    firstThatConstructsJust\n        [ \\() ->\n            callOnEmptyReturnsCheck { on = listArg, resultAsString = maybeWithJustAsWrap.empty.asString } listCollection checkInfo\n        , \\() ->\n            Maybe.map\n                (\\listArgHead ->\n                    Rule.errorWithFix\n                        { message = qualifiedToString checkInfo.fn ++ \" on a list with a first element will result in Just that element\"\n                        , details = [ \"You can replace this call by Just the first list element.\" ]\n                        }\n                        checkInfo.fnRange\n                        (replaceBySubExpressionFix (Node.range listArg) listArgHead\n                            ++ [ Fix.replaceRangeBy checkInfo.fnRange\n                                    (qualifiedToString (qualify ( [ \"Maybe\" ], \"Just\" ) checkInfo))\n                               ]\n                        )\n                )\n                (getListHead checkInfo.lookupTable listArg)\n        ]\n        ()\n\n\ngetListHead : ModuleNameLookupTable -> Node Expression -> Maybe (Node Expression)\ngetListHead lookupTable expressionNode =\n    case Node.value (AstHelpers.removeParens expressionNode) of\n        Expression.ListExpr (head :: _) ->\n            Just head\n\n        Expression.OperatorApplication \"::\" _ head _ ->\n            Just head\n\n        _ ->\n            case AstHelpers.getListSingleton lookupTable expressionNode of\n                Just single ->\n                    Just single.element\n\n                Nothing ->\n                    Nothing\n\n\nlistTailChecks : CheckInfo -> Maybe (Error {})\nlistTailChecks checkInfo =\n    let\n        listArg : Node Expression\n        listArg =\n            checkInfo.firstArg\n\n        listTailExistsError : List Fix -> Error {}\n        listTailExistsError replaceListArgByTailFix =\n            Rule.errorWithFix\n                { message = qualifiedToString checkInfo.fn ++ \" on a list with some elements will result in Just the elements after the first\"\n                , details = [ \"You can replace this call by Just the list elements after the first.\" ]\n                }\n                checkInfo.fnRange\n                (replaceListArgByTailFix\n                    ++ [ Fix.replaceRangeBy checkInfo.fnRange\n                            (qualifiedToString (qualify ( [ \"Maybe\" ], \"Just\" ) checkInfo))\n                       ]\n                )\n    in\n    firstThatConstructsJust\n        [ \\() ->\n            callOnEmptyReturnsCheck { on = listArg, resultAsString = maybeWithJustAsWrap.empty.asString } listCollection checkInfo\n        , \\() ->\n            case Node.value (AstHelpers.removeParens listArg) of\n                Expression.ListExpr ((Node headRange _) :: (Node tailFirstRange _) :: _) ->\n                    Just\n                        (listTailExistsError\n                            [ Fix.removeRange { start = headRange.start, end = tailFirstRange.start }\n                            ]\n                        )\n\n                Expression.OperatorApplication \"::\" _ _ tail ->\n                    Just\n                        (listTailExistsError\n                            (replaceBySubExpressionFix (Node.range listArg) tail)\n                        )\n\n                _ ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getListSingleton checkInfo.lookupTable listArg of\n                Just _ ->\n                    Just\n                        (Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" on a list with a single element will result in Just []\"\n                            , details = [ \"You can replace this call by Just [].\" ]\n                            }\n                            checkInfo.fnRange\n                            [ Fix.replaceRangeBy (Node.range checkInfo.firstArg) \"[]\"\n                            , Fix.replaceRangeBy checkInfo.fnRange\n                                (qualifiedToString (qualify ( [ \"Maybe\" ], \"Just\" ) checkInfo))\n                            ]\n                        )\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\nlistMapChecks : CheckInfo -> Maybe (Error {})\nlistMapChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> emptiableMapChecks listCollection checkInfo\n        , \\() -> listMapOnSingletonCheck checkInfo\n        , \\() -> dictToListMapChecks checkInfo\n        ]\n        ()\n\n\nlistMapOnSingletonCheck : CheckInfo -> Maybe (Error {})\nlistMapOnSingletonCheck checkInfo =\n    case secondArg checkInfo of\n        Just listArg ->\n            case sameInAllBranches (getValueWithNodeRange (listCollection.wrap.getValue checkInfo.lookupTable)) listArg of\n                Determined wraps ->\n                    let\n                        mappingArgRange : Range\n                        mappingArgRange =\n                            Node.range checkInfo.firstArg\n                    in\n                    Just\n                        (Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" on a singleton list will result in a singleton list with the function applied to the value inside\"\n                            , details = [ \"You can replace this call by a singleton list containing the function directly applied to the value inside the given singleton list.\" ]\n                            }\n                            checkInfo.fnRange\n                            (keepOnlyFix\n                                { parentRange = Range.combine [ checkInfo.fnRange, mappingArgRange ]\n                                , keep = mappingArgRange\n                                }\n                                ++ List.concatMap\n                                    (\\wrap -> replaceBySubExpressionFix wrap.nodeRange wrap.value)\n                                    wraps\n                                ++ [ Fix.insertAt checkInfo.parentRange.start \"[ \"\n                                   , Fix.insertAt checkInfo.parentRange.end \" ]\"\n                                   ]\n                            )\n                        )\n\n                Undetermined ->\n                    Nothing\n\n        Nothing ->\n            Nothing\n\n\ndictToListMapErrorInfo : { toEntryAspectList : String, tuplePart : String } -> { message : String, details : List String }\ndictToListMapErrorInfo info =\n    let\n        toEntryAspectListAsQualifiedString : String\n        toEntryAspectListAsQualifiedString =\n            qualifiedToString ( [ \"Dict\" ], info.toEntryAspectList )\n    in\n    { message = qualifiedToString ( [ \"Dict\" ], \"toList\" ) ++ \", then \" ++ qualifiedToString ( [ \"List\" ], \"map\" ) ++ \" \" ++ qualifiedToString ( [ \"Tuple\" ], info.tuplePart ) ++ \" is the same as \" ++ toEntryAspectListAsQualifiedString\n    , details = [ \"Using \" ++ toEntryAspectListAsQualifiedString ++ \" directly is meant for this exact purpose and will also be faster.\" ]\n    }\n\n\ndictToListMapChecks : CheckInfo -> Maybe (Error {})\ndictToListMapChecks listMapCheckInfo =\n    case secondArg listMapCheckInfo of\n        Just listArgument ->\n            case AstHelpers.getSpecificFunctionCall ( [ \"Dict\" ], \"toList\" ) listMapCheckInfo.lookupTable listArgument of\n                Just dictToListCall ->\n                    let\n                        error : { toEntryAspectList : String, tuplePart : String } -> Error {}\n                        error info =\n                            Rule.errorWithFix\n                                (dictToListMapErrorInfo info)\n                                listMapCheckInfo.fnRange\n                                (keepOnlyFix { parentRange = Node.range listArgument, keep = Node.range dictToListCall.firstArg }\n                                    ++ [ Fix.replaceRangeBy\n                                            (Range.combine [ listMapCheckInfo.fnRange, Node.range listMapCheckInfo.firstArg ])\n                                            (qualifiedToString (qualify ( [ \"Dict\" ], info.toEntryAspectList ) listMapCheckInfo))\n                                       ]\n                                )\n                    in\n                    if AstHelpers.isTupleFirstAccess listMapCheckInfo.lookupTable listMapCheckInfo.firstArg then\n                        Just (error { tuplePart = \"first\", toEntryAspectList = \"keys\" })\n\n                    else if AstHelpers.isTupleSecondAccess listMapCheckInfo.lookupTable listMapCheckInfo.firstArg then\n                        Just (error { tuplePart = \"second\", toEntryAspectList = \"values\" })\n\n                    else\n                        Nothing\n\n                Nothing ->\n                    Nothing\n\n        Nothing ->\n            Nothing\n\n\nlistMapCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nlistMapCompositionChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> wrapToMapCompositionChecks listCollection checkInfo\n        , \\() -> dictToListIntoListMapCompositionCheck checkInfo\n        ]\n        ()\n\n\ndictToListIntoListMapCompositionCheck : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\ndictToListIntoListMapCompositionCheck checkInfo =\n    case\n        ( ( checkInfo.earlier.fn, checkInfo.earlier.args )\n        , checkInfo.later.args\n        )\n    of\n        ( ( ( [ \"Dict\" ], \"toList\" ), [] ), elementMappingArg :: [] ) ->\n            let\n                error : { toEntryAspectList : String, tuplePart : String } -> ErrorInfoAndFix\n                error info =\n                    { info = dictToListMapErrorInfo info\n                    , fix = [ Fix.replaceRangeBy checkInfo.parentRange (qualifiedToString (qualify ( [ \"Dict\" ], info.toEntryAspectList ) checkInfo)) ]\n                    }\n            in\n            if AstHelpers.isTupleFirstAccess checkInfo.lookupTable elementMappingArg then\n                Just (error { tuplePart = \"first\", toEntryAspectList = \"keys\" })\n\n            else if AstHelpers.isTupleSecondAccess checkInfo.lookupTable elementMappingArg then\n                Just (error { tuplePart = \"second\", toEntryAspectList = \"values\" })\n\n            else\n                Nothing\n\n        _ ->\n            Nothing\n\n\nlistMemberChecks : CheckInfo -> Maybe (Error {})\nlistMemberChecks checkInfo =\n    case secondArg checkInfo of\n        Just listArg ->\n            let\n                needleArg : Node Expression\n                needleArg =\n                    checkInfo.firstArg\n\n                needleRange : Range\n                needleRange =\n                    Node.range needleArg\n            in\n            firstThatConstructsJust\n                [ \\() ->\n                    callOnEmptyReturnsCheck\n                        { on = listArg, resultAsString = \\res -> qualifiedToString (qualify ( [ \"Basics\" ], \"False\" ) res) }\n                        listCollection\n                        checkInfo\n                , \\() ->\n                    if checkInfo.expectNaN then\n                        Nothing\n\n                    else\n                        let\n                            needleArgNormalized : Node Expression\n                            needleArgNormalized =\n                                Normalize.normalize checkInfo needleArg\n\n                            isNeedle : Node Expression -> Bool\n                            isNeedle element =\n                                Normalize.compareWithoutNormalization\n                                    (Normalize.normalize checkInfo element)\n                                    needleArgNormalized\n                                    == Normalize.ConfirmedEquality\n                        in\n                        if List.any isNeedle (listKnownElements checkInfo.lookupTable listArg) then\n                            Just\n                                (resultsInConstantError\n                                    (qualifiedToString checkInfo.fn ++ \" on a list which contains the given element\")\n                                    (\\res -> qualifiedToString (qualify ( [ \"Basics\" ], \"True\" ) res))\n                                    checkInfo\n                                )\n\n                        else\n                            Nothing\n                , \\() ->\n                    case AstHelpers.getListSingleton checkInfo.lookupTable listArg of\n                        Just single ->\n                            let\n                                elementRange : Range\n                                elementRange =\n                                    Node.range single.element\n                            in\n                            Just\n                                (Rule.errorWithFix\n                                    { message = qualifiedToString checkInfo.fn ++ \" on an list with a single element is the same as directly checking for equality\"\n                                    , details = [ \"You can replace this call by checking whether the member to find and the list element are equal.\" ]\n                                    }\n                                    checkInfo.fnRange\n                                    (List.concat\n                                        [ keepOnlyFix\n                                            { parentRange = checkInfo.parentRange\n                                            , keep = Range.combine [ needleRange, elementRange ]\n                                            }\n                                        , [ Fix.replaceRangeBy\n                                                (rangeBetweenExclusive ( needleRange, elementRange ))\n                                                \" == \"\n                                          ]\n                                        , parenthesizeIfNeededFix single.element\n                                        ]\n                                    )\n                                )\n\n                        Nothing ->\n                            Nothing\n                ]\n                ()\n\n        Nothing ->\n            Nothing\n\n\nlistKnownElements : ModuleNameLookupTable -> Node Expression -> List (Node Expression)\nlistKnownElements lookupTable expressionNode =\n    case Node.value (AstHelpers.removeParens expressionNode) of\n        Expression.ListExpr (el0 :: el1 :: el2Up) ->\n            el0 :: el1 :: el2Up\n\n        Expression.OperatorApplication \"::\" _ head tail ->\n            case AstHelpers.getCollapsedCons tail of\n                Nothing ->\n                    [ head ]\n\n                Just collapsedCons ->\n                    head :: collapsedCons.consed\n\n        _ ->\n            case AstHelpers.getListSingleton lookupTable expressionNode of\n                Nothing ->\n                    []\n\n                Just singletonList ->\n                    [ singletonList.element ]\n\n\nlistSumChecks : CheckInfo -> Maybe (Error {})\nlistSumChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            callOnEmptyReturnsCheck { on = checkInfo.firstArg, resultAsString = \\_ -> \"0\" } listCollection checkInfo\n        , \\() -> callOnWrapReturnsItsValue checkInfo.firstArg listCollection checkInfo\n        ]\n        ()\n\n\nlistProductChecks : CheckInfo -> Maybe (Error {})\nlistProductChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            callOnEmptyReturnsCheck { on = checkInfo.firstArg, resultAsString = \\_ -> \"1\" } listCollection checkInfo\n        , \\() -> callOnWrapReturnsItsValue checkInfo.firstArg listCollection checkInfo\n        ]\n        ()\n\n\nlistMinimumChecks : CheckInfo -> Maybe (Error {})\nlistMinimumChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            callOnEmptyReturnsCheck { on = checkInfo.firstArg, resultAsString = maybeWithJustAsWrap.empty.asString } listCollection checkInfo\n        , \\() -> callOnWrapReturnsJustItsValue checkInfo.firstArg listCollection checkInfo\n        ]\n        ()\n\n\nlistMaximumChecks : CheckInfo -> Maybe (Error {})\nlistMaximumChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            callOnEmptyReturnsCheck { on = checkInfo.firstArg, resultAsString = maybeWithJustAsWrap.empty.asString } listCollection checkInfo\n        , \\() -> callOnWrapReturnsJustItsValue checkInfo.firstArg listCollection checkInfo\n        ]\n        ()\n\n\nlistFoldlChecks : CheckInfo -> Maybe (Error {})\nlistFoldlChecks checkInfo =\n    listFoldAnyDirectionChecks checkInfo\n\n\nlistFoldrChecks : CheckInfo -> Maybe (Error {})\nlistFoldrChecks checkInfo =\n    listFoldAnyDirectionChecks checkInfo\n\n\nlistFoldAnyDirectionChecks : CheckInfo -> Maybe (Error {})\nlistFoldAnyDirectionChecks checkInfo =\n    case secondArg checkInfo of\n        Nothing ->\n            Nothing\n\n        Just initialArg ->\n            let\n                maybeListArg : Maybe (Node Expression)\n                maybeListArg =\n                    thirdArg checkInfo\n\n                numberBinaryOperationChecks : { identity : Int, two : String, list : String } -> Maybe (Error {})\n                numberBinaryOperationChecks operation =\n                    let\n                        fixWith : List Fix -> Error {}\n                        fixWith fixes =\n                            let\n                                replacementOperationAsString : String\n                                replacementOperationAsString =\n                                    qualifiedToString ( [ \"List\" ], operation.list )\n                            in\n                            Rule.errorWithFix\n                                { message = qualifiedToString checkInfo.fn ++ \" (\" ++ operation.two ++ \") \" ++ String.fromInt operation.identity ++ \" is the same as \" ++ replacementOperationAsString\n                                , details = [ \"You can replace this call by \" ++ replacementOperationAsString ++ \" which is meant for this exact purpose.\" ]\n                                }\n                                checkInfo.fnRange\n                                fixes\n                    in\n                    if AstHelpers.getUncomputedNumberValue initialArg == Just (Basics.toFloat operation.identity) then\n                        Just\n                            (fixWith\n                                [ Fix.replaceRangeBy\n                                    { start = checkInfo.fnRange.start\n                                    , end = (Node.range initialArg).end\n                                    }\n                                    (qualifiedToString (qualify ( [ \"List\" ], operation.list ) checkInfo))\n                                ]\n                            )\n\n                    else\n                        case maybeListArg of\n                            Nothing ->\n                                Nothing\n\n                            Just _ ->\n                                case checkInfo.callStyle of\n                                    Pipe LeftToRight ->\n                                        -- list |> fold op initial --> ((list |> List.op) op initial)\n                                        Just\n                                            (fixWith\n                                                [ Fix.insertAt (Node.range initialArg).end \")\"\n                                                , Fix.insertAt (Node.range initialArg).start (operation.two ++ \" \")\n                                                , Fix.replaceRangeBy\n                                                    { start = checkInfo.fnRange.start\n                                                    , end = (Node.range checkInfo.firstArg).end\n                                                    }\n                                                    (qualifiedToString (qualify ( [ \"List\" ], operation.list ) checkInfo) ++ \")\")\n                                                , Fix.insertAt checkInfo.parentRange.start \"((\"\n                                                ]\n                                            )\n\n                                    -- Pipe RightToLeft | Application ->\n                                    _ ->\n                                        -- fold op initial list --> (initial op (List.op list))\n                                        Just\n                                            (fixWith\n                                                [ Fix.insertAt checkInfo.parentRange.end \")\"\n                                                , Fix.insertAt (Node.range initialArg).end\n                                                    (\" \"\n                                                        ++ operation.two\n                                                        ++ \" (\"\n                                                        ++ qualifiedToString (qualify ( [ \"List\" ], operation.list ) checkInfo)\n                                                    )\n                                                , Fix.removeRange\n                                                    { start = checkInfo.fnRange.start\n                                                    , end = (Node.range initialArg).start\n                                                    }\n                                                ]\n                                            )\n\n                boolBinaryOperationChecks : { two : String, list : String, determining : Bool } -> Bool -> Error {}\n                boolBinaryOperationChecks operation initialIsDetermining =\n                    if initialIsDetermining == operation.determining then\n                        let\n                            determiningAsString : String\n                            determiningAsString =\n                                AstHelpers.boolToString operation.determining\n                        in\n                        alwaysResultsInUnparenthesizedConstantError\n                            (qualifiedToString checkInfo.fn ++ \" with (\" ++ operation.two ++ \") and the initial accumulator \" ++ determiningAsString)\n                            { replacement = \\res -> qualifiedToString (qualify ( [ \"Basics\" ], determiningAsString ) res)\n                            , lastArg = thirdArg checkInfo\n                            }\n                            checkInfo\n\n                    else\n                        -- initialIsTrue /= operation.determining\n                        let\n                            replacementOperationAsString : String\n                            replacementOperationAsString =\n                                qualifiedToString ( [ \"List\" ], operation.list ) ++ \" identity\"\n                        in\n                        Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" (\" ++ operation.two ++ \") \" ++ AstHelpers.boolToString (not operation.determining) ++ \" is the same as \" ++ replacementOperationAsString\n                            , details = [ \"You can replace this call by \" ++ replacementOperationAsString ++ \" which is meant for this exact purpose.\" ]\n                            }\n                            checkInfo.fnRange\n                            [ Fix.replaceRangeBy\n                                { start = checkInfo.fnRange.start, end = (Node.range initialArg).end }\n                                (qualifiedToString (qualify ( [ \"List\" ], operation.list ) checkInfo)\n                                    ++ \" \"\n                                    ++ qualifiedToString (qualify ( [ \"Basics\" ], \"identity\" ) checkInfo)\n                                )\n                            ]\n            in\n            firstThatConstructsJust\n                [ \\() ->\n                    case maybeListArg of\n                        Just listArg ->\n                            firstThatConstructsJust\n                                [ \\() ->\n                                    case AstHelpers.getSpecificFunctionCall ( [ \"Set\" ], \"toList\" ) checkInfo.lookupTable listArg of\n                                        Just setToListCall ->\n                                            Just\n                                                (Rule.errorWithFix\n                                                    { message = \"To fold a set, you don't need to convert to a List\"\n                                                    , details = [ \"Using \" ++ qualifiedToString ( [ \"Set\" ], AstHelpers.qualifiedName checkInfo.fn ) ++ \" directly is meant for this exact purpose and will also be faster.\" ]\n                                                    }\n                                                    checkInfo.fnRange\n                                                    (replaceBySubExpressionFix setToListCall.nodeRange setToListCall.firstArg\n                                                        ++ [ Fix.replaceRangeBy checkInfo.fnRange\n                                                                (qualifiedToString (qualify ( [ \"Set\" ], AstHelpers.qualifiedName checkInfo.fn ) checkInfo))\n                                                           ]\n                                                    )\n                                                )\n\n                                        Nothing ->\n                                            Nothing\n                                , \\() ->\n                                    if listCollection.empty.is checkInfo.lookupTable listArg then\n                                        Just\n                                            (returnsArgError\n                                                (qualifiedToString checkInfo.fn ++ \" on \" ++ descriptionForIndefinite listCollection.empty.description)\n                                                { argRepresents = \"initial accumulator\"\n                                                , arg = initialArg\n                                                }\n                                                checkInfo\n                                            )\n\n                                    else\n                                        Nothing\n                                ]\n                                ()\n\n                        Nothing ->\n                            Nothing\n                , \\() ->\n                    case AstHelpers.getAlwaysResult checkInfo.lookupTable checkInfo.firstArg of\n                        Just reduceAlwaysResult ->\n                            if AstHelpers.isIdentity checkInfo.lookupTable reduceAlwaysResult then\n                                Just\n                                    (Rule.errorWithFix\n                                        { message = qualifiedToString checkInfo.fn ++ \" with a function that always returns the unchanged accumulator will result in the initial accumulator\"\n                                        , details = [ \"You can replace this call by the initial accumulator.\" ]\n                                        }\n                                        checkInfo.fnRange\n                                        (case maybeListArg of\n                                            Nothing ->\n                                                [ Fix.replaceRangeBy\n                                                    { start = checkInfo.fnRange.start\n                                                    , end = (Node.range checkInfo.firstArg).end\n                                                    }\n                                                    (qualifiedToString (qualify ( [ \"Basics\" ], \"always\" ) checkInfo))\n                                                ]\n\n                                            Just _ ->\n                                                keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range initialArg }\n                                        )\n                                    )\n\n                            else\n                                Nothing\n\n                        Nothing ->\n                            Nothing\n                , \\() ->\n                    if AstHelpers.isSpecificUnappliedBinaryOperation \"*\" checkInfo checkInfo.firstArg then\n                        numberBinaryOperationChecks { two = \"*\", list = \"product\", identity = 1 }\n\n                    else\n                        Nothing\n                , \\() ->\n                    if AstHelpers.isSpecificUnappliedBinaryOperation \"+\" checkInfo checkInfo.firstArg then\n                        numberBinaryOperationChecks { two = \"+\", list = \"sum\", identity = 0 }\n\n                    else\n                        Nothing\n                , \\() ->\n                    case Evaluate.getBoolean checkInfo initialArg of\n                        Undetermined ->\n                            Nothing\n\n                        Determined initialBool ->\n                            if AstHelpers.isSpecificUnappliedBinaryOperation \"&&\" checkInfo checkInfo.firstArg then\n                                Just (boolBinaryOperationChecks { two = \"&&\", list = \"all\", determining = False } initialBool)\n\n                            else if AstHelpers.isSpecificUnappliedBinaryOperation \"||\" checkInfo checkInfo.firstArg then\n                                Just (boolBinaryOperationChecks { two = \"||\", list = \"any\", determining = True } initialBool)\n\n                            else\n                                Nothing\n                ]\n                ()\n\n\nlistFoldlCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nlistFoldlCompositionChecks checkInfo =\n    foldAndSetToListCompositionChecks checkInfo\n\n\nlistFoldrCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nlistFoldrCompositionChecks checkInfo =\n    foldAndSetToListCompositionChecks checkInfo\n\n\nfoldAndSetToListCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nfoldAndSetToListCompositionChecks checkInfo =\n    case checkInfo.earlier.fn of\n        ( [ \"Set\" ], \"toList\" ) ->\n            Just\n                { info =\n                    { message = \"To fold a set, you don't need to convert to a List\"\n                    , details = [ \"Using \" ++ qualifiedToString ( [ \"Set\" ], AstHelpers.qualifiedName checkInfo.later.fn ) ++ \" directly is meant for this exact purpose and will also be faster.\" ]\n                    }\n                , fix =\n                    keepOnlyFix { parentRange = checkInfo.parentRange, keep = checkInfo.later.range }\n                        ++ [ Fix.replaceRangeBy checkInfo.later.fnRange\n                                (qualifiedToString (qualify ( [ \"Set\" ], AstHelpers.qualifiedName checkInfo.later.fn ) checkInfo))\n                           ]\n                }\n\n        _ ->\n            Nothing\n\n\nlistAllChecks : CheckInfo -> Maybe (Error {})\nlistAllChecks checkInfo =\n    emptiableAllChecks listCollection checkInfo\n\n\nemptiableAllChecks : EmptiableProperties otherProperties -> CheckInfo -> Maybe (Error {})\nemptiableAllChecks emptiable checkInfo =\n    let\n        maybeEmptiableArg : Maybe (Node Expression)\n        maybeEmptiableArg =\n            secondArg checkInfo\n    in\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\listArg ->\n                    callOnEmptyReturnsCheck\n                        { on = listArg, resultAsString = \\res -> qualifiedToString (qualify ( [ \"Basics\" ], \"True\" ) res) }\n                        emptiable\n                        checkInfo\n                )\n                maybeEmptiableArg\n        , \\() ->\n            case Evaluate.isAlwaysBoolean checkInfo checkInfo.firstArg of\n                Determined True ->\n                    Just\n                        (alwaysResultsInUnparenthesizedConstantError\n                            (qualifiedToString checkInfo.fn ++ \" with a function that will always return True\")\n                            { replacement = \\res -> qualifiedToString (qualify ( [ \"Basics\" ], \"True\" ) res)\n                            , lastArg = maybeEmptiableArg\n                            }\n                            checkInfo\n                        )\n\n                _ ->\n                    Nothing\n        ]\n        ()\n\n\nlistAnyChecks : CheckInfo -> Maybe (Error {})\nlistAnyChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> emptiableAnyChecks listCollection checkInfo\n        , \\() ->\n            case Evaluate.isEqualToSomethingFunction checkInfo.firstArg of\n                Nothing ->\n                    Nothing\n\n                Just equatedTo ->\n                    let\n                        replacementFn : ( ModuleName, String )\n                        replacementFn =\n                            ( [ \"List\" ], \"member\" )\n                    in\n                    Just\n                        (Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" with a check for equality with a specific value can be replaced by \" ++ qualifiedToString replacementFn ++ \" with that value\"\n                            , details = [ \"You can replace this call by \" ++ qualifiedToString replacementFn ++ \" with the specific value to find which meant for this exact purpose.\" ]\n                            }\n                            checkInfo.fnRange\n                            (Fix.replaceRangeBy checkInfo.fnRange (qualifiedToString (qualify replacementFn checkInfo))\n                                :: replaceBySubExpressionFix (Node.range checkInfo.firstArg) equatedTo.something\n                            )\n                        )\n        ]\n        ()\n\n\nemptiableAnyChecks : EmptiableProperties otherProperties -> CheckInfo -> Maybe (Error {})\nemptiableAnyChecks emptiable checkInfo =\n    let\n        maybeEmptiableArg : Maybe (Node Expression)\n        maybeEmptiableArg =\n            secondArg checkInfo\n    in\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\listArg ->\n                    callOnEmptyReturnsCheck\n                        { on = listArg, resultAsString = \\res -> qualifiedToString (qualify ( [ \"Basics\" ], \"False\" ) res) }\n                        emptiable\n                        checkInfo\n                )\n                maybeEmptiableArg\n        , \\() ->\n            case Evaluate.isAlwaysBoolean checkInfo checkInfo.firstArg of\n                Determined False ->\n                    Just\n                        (alwaysResultsInUnparenthesizedConstantError\n                            (qualifiedToString checkInfo.fn ++ \" with a function that will always return False\")\n                            { replacement = \\res -> qualifiedToString (qualify ( [ \"Basics\" ], \"False\" ) res)\n                            , lastArg = maybeEmptiableArg\n                            }\n                            checkInfo\n                        )\n\n                _ ->\n                    Nothing\n        ]\n        ()\n\n\nlistFilterMapChecks : CheckInfo -> Maybe (Error {})\nlistFilterMapChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> emptiableWrapperFilterMapChecks listCollection checkInfo\n        , \\() ->\n            if AstHelpers.isIdentity checkInfo.lookupTable checkInfo.firstArg then\n                case secondArg checkInfo of\n                    Just listArg ->\n                        firstThatConstructsJust\n                            [ \\() -> irrelevantEmptyElementInGivenListArgCheck listArg maybeWithJustAsWrap checkInfo\n                            , \\() ->\n                                case AstHelpers.getListLiteral listArg of\n                                    Just list ->\n                                        case\n                                            traverse\n                                                (AstHelpers.getSpecificFunctionCall ( [ \"Maybe\" ], \"Just\" ) checkInfo.lookupTable)\n                                                list\n                                        of\n                                            Just justCalls ->\n                                                Just\n                                                    (Rule.errorWithFix\n                                                        { message = \"Unnecessary use of \" ++ qualifiedToString checkInfo.fn ++ \" identity\"\n                                                        , details = [ \"All of the elements in the list are `Just`s, which can be simplified by removing all of the `Just`s.\" ]\n                                                        }\n                                                        checkInfo.fnRange\n                                                        (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range listArg }\n                                                            ++ List.concatMap\n                                                                (\\just -> keepOnlyFix { parentRange = just.nodeRange, keep = Node.range just.firstArg })\n                                                                justCalls\n                                                        )\n                                                    )\n\n                                            Nothing ->\n                                                Nothing\n\n                                    Nothing ->\n                                        Nothing\n                            ]\n                            ()\n\n                    Nothing ->\n                        Nothing\n\n            else\n                Nothing\n        ]\n        ()\n\n\nemptiableWrapperFilterMapChecks : EmptiableProperties (WrapperProperties otherProperties) -> CheckInfo -> Maybe (Error {})\nemptiableWrapperFilterMapChecks emptiableWrapper checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            case constructs (sameInAllBranches (AstHelpers.getSpecificFunctionCall ( [ \"Maybe\" ], \"Just\" ) checkInfo.lookupTable)) checkInfo.lookupTable checkInfo.firstArg of\n                Determined justCalls ->\n                    Just\n                        (Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" with a function that will always return Just is the same as \" ++ qualifiedToString ( emptiableWrapper.moduleName, \"map\" )\n                            , details = [ \"You can remove the `Just`s and replace the call by \" ++ qualifiedToString ( emptiableWrapper.moduleName, \"map\" ) ++ \".\" ]\n                            }\n                            checkInfo.fnRange\n                            (Fix.replaceRangeBy checkInfo.fnRange\n                                (qualifiedToString (qualify ( emptiableWrapper.moduleName, \"map\" ) checkInfo))\n                                :: List.concatMap (\\call -> replaceBySubExpressionFix call.nodeRange call.firstArg) justCalls\n                            )\n                        )\n\n                Undetermined ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getSpecificValueOrFunction ( [ \"Maybe\" ], \"Just\" ) checkInfo.lookupTable checkInfo.firstArg of\n                Just _ ->\n                    Just\n                        (alwaysReturnsLastArgError\n                            (qualifiedToString checkInfo.fn ++ \" with a function that will always return Just\")\n                            emptiableWrapper\n                            checkInfo\n                        )\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case constructs (sameInAllBranches (AstHelpers.getSpecificValueOrFunction ( [ \"Maybe\" ], \"Nothing\" ) checkInfo.lookupTable)) checkInfo.lookupTable checkInfo.firstArg of\n                Determined _ ->\n                    Just\n                        (alwaysResultsInUnparenthesizedConstantError\n                            (qualifiedToString checkInfo.fn ++ \" with a function that will always return Nothing\")\n                            { replacement = emptiableWrapper.empty.asString, lastArg = secondArg checkInfo }\n                            checkInfo\n                        )\n\n                Undetermined ->\n                    Nothing\n        , \\() ->\n            mapToOperationWithIdentityCanBeCombinedToOperationChecks { mapFn = ( emptiableWrapper.moduleName, \"map\" ) } checkInfo\n        , \\() ->\n            Maybe.andThen\n                (\\listArg -> callOnEmptyReturnsEmptyCheck listArg emptiableWrapper checkInfo)\n                (secondArg checkInfo)\n        ]\n        ()\n\n\nmapToOperationWithIdentityCanBeCombinedToOperationChecks : { mapFn : ( ModuleName, String ) } -> CheckInfo -> Maybe (Error {})\nmapToOperationWithIdentityCanBeCombinedToOperationChecks config checkInfo =\n    case secondArg checkInfo of\n        Just mappableArg ->\n            if AstHelpers.isIdentity checkInfo.lookupTable checkInfo.firstArg then\n                case AstHelpers.getSpecificFunctionCall config.mapFn checkInfo.lookupTable mappableArg of\n                    Just mapCall ->\n                        Just\n                            (Rule.errorWithFix\n                                { message = qualifiedToString config.mapFn ++ \" and \" ++ qualifiedToString checkInfo.fn ++ \" identity can be combined using \" ++ qualifiedToString checkInfo.fn\n                                , details = [ qualifiedToString checkInfo.fn ++ \" is meant for this exact purpose and will also be faster.\" ]\n                                }\n                                checkInfo.fnRange\n                                (replaceBySubExpressionFix checkInfo.parentRange mappableArg\n                                    ++ [ Fix.replaceRangeBy mapCall.fnRange\n                                            (qualifiedToString (qualify checkInfo.fn checkInfo))\n                                       ]\n                                )\n                            )\n\n                    Nothing ->\n                        Nothing\n\n            else\n                Nothing\n\n        Nothing ->\n            Nothing\n\n\nlistFilterMapCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nlistFilterMapCompositionChecks checkInfo =\n    mapToOperationWithIdentityCanBeCombinedToOperationCompositionChecks { mapFn = ( [ \"List\" ], \"map\" ) } checkInfo\n\n\nmapToOperationWithIdentityCanBeCombinedToOperationCompositionChecks : { mapFn : ( ModuleName, String ) } -> CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nmapToOperationWithIdentityCanBeCombinedToOperationCompositionChecks config checkInfo =\n    case checkInfo.later.args of\n        elementToMaybeMappingArg :: [] ->\n            if AstHelpers.isIdentity checkInfo.lookupTable elementToMaybeMappingArg then\n                case ( checkInfo.earlier.fn == config.mapFn, checkInfo.earlier.args ) of\n                    ( True, _ :: [] ) ->\n                        Just\n                            { info =\n                                { message = qualifiedToString config.mapFn ++ \" and \" ++ qualifiedToString checkInfo.later.fn ++ \" identity can be combined using \" ++ qualifiedToString checkInfo.later.fn\n                                , details = [ qualifiedToString checkInfo.later.fn ++ \" is meant for this exact purpose and will also be faster.\" ]\n                                }\n                            , fix =\n                                Fix.replaceRangeBy checkInfo.earlier.fnRange\n                                    (qualifiedToString (qualify checkInfo.later.fn checkInfo))\n                                    :: keepOnlyFix { parentRange = checkInfo.parentRange, keep = checkInfo.earlier.range }\n                            }\n\n                    _ ->\n                        Nothing\n\n            else\n                Nothing\n\n        _ ->\n            Nothing\n\n\nlistRangeChecks : CheckInfo -> Maybe (Error {})\nlistRangeChecks checkInfo =\n    case secondArg checkInfo of\n        Just rangeEndArg ->\n            case ( Evaluate.getInt checkInfo checkInfo.firstArg, Evaluate.getInt checkInfo rangeEndArg ) of\n                ( Just rangeStartValue, Just rangeEndValue ) ->\n                    if rangeStartValue > rangeEndValue then\n                        Just\n                            (resultsInConstantError\n                                (qualifiedToString checkInfo.fn ++ \" with a start index greater than the end index\")\n                                (\\_ -> \"[]\")\n                                checkInfo\n                            )\n\n                    else\n                        Nothing\n\n                ( Nothing, _ ) ->\n                    Nothing\n\n                ( _, Nothing ) ->\n                    Nothing\n\n        Nothing ->\n            Nothing\n\n\nlistRepeatChecks : CheckInfo -> Maybe (Error {})\nlistRepeatChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> emptiableRepeatChecks listCollection checkInfo\n        , \\() -> wrapperRepeatChecks listCollection checkInfo\n        ]\n        ()\n\n\narrayToListChecks : CheckInfo -> Maybe (Error {})\narrayToListChecks checkInfo =\n    onCallToInverseReturnsItsArgumentCheck ( [ \"Array\" ], \"fromList\" ) checkInfo\n\n\narrayFromListChecks : CheckInfo -> Maybe (Error {})\narrayFromListChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> collectionFromListChecks arrayCollection checkInfo\n        , \\() -> onCallToInverseReturnsItsArgumentCheck ( [ \"Array\" ], \"toList\" ) checkInfo\n        ]\n        ()\n\n\narrayRepeatChecks : CheckInfo -> Maybe (Error {})\narrayRepeatChecks checkInfo =\n    emptiableRepeatChecks arrayCollection checkInfo\n\n\narrayInitializeChecks : CheckInfo -> Maybe (Error {})\narrayInitializeChecks checkInfo =\n    emptiableRepeatChecks arrayCollection checkInfo\n\n\narrayIndexedMapChecks : CheckInfo -> Maybe (Error {})\narrayIndexedMapChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\arrayArg ->\n                    callOnEmptyReturnsEmptyCheck arrayArg arrayCollection checkInfo\n                )\n                (secondArg checkInfo)\n        , \\() -> operationWithExtraArgChecks { operationWithoutExtraArg = ( [ \"Array\" ], \"map\" ) } checkInfo\n        ]\n        ()\n\n\nemptiableRepeatChecks : CollectionProperties otherProperties -> CheckInfo -> Maybe (Error {})\nemptiableRepeatChecks collection checkInfo =\n    case Evaluate.getInt checkInfo checkInfo.firstArg of\n        Just intValue ->\n            callWithNonPositiveIntCanBeReplacedByCheck\n                { int = intValue\n                , intDescription = collection.nameForSize\n                , replacement = collection.empty.asString\n                , lastArg = secondArg checkInfo\n                }\n                checkInfo\n\n        Nothing ->\n            Nothing\n\n\nwrapperRepeatChecks : CollectionProperties (WrapperProperties otherProperties) -> CheckInfo -> Maybe (Error {})\nwrapperRepeatChecks wrapper checkInfo =\n    case Evaluate.getInt checkInfo checkInfo.firstArg of\n        Just 1 ->\n            let\n                wrapFn : ( ModuleName, String )\n                wrapFn =\n                    ( wrapper.moduleName, wrapper.wrap.fnName )\n            in\n            Just\n                (Rule.errorWithFix\n                    { message = qualifiedToString checkInfo.fn ++ \" with \" ++ wrapper.nameForSize ++ \" 1 will result in \" ++ qualifiedToString wrapFn\n                    , details = [ \"You can replace this call by \" ++ qualifiedToString wrapFn ++ \".\" ]\n                    }\n                    checkInfo.fnRange\n                    [ Fix.replaceRangeBy\n                        (Range.combine [ checkInfo.fnRange, Node.range checkInfo.firstArg ])\n                        (qualifiedToString (qualify wrapFn checkInfo))\n                    ]\n                )\n\n        Just _ ->\n            Nothing\n\n        Nothing ->\n            Nothing\n\n\narrayLengthChecks : CheckInfo -> Maybe (Error {})\narrayLengthChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> collectionSizeChecks arrayCollection checkInfo\n        , \\() -> arrayLengthOnArrayRepeatOrInitializeChecks checkInfo\n        ]\n        ()\n\n\narrayLengthOnArrayRepeatOrInitializeChecks : CheckInfo -> Maybe (Error {})\narrayLengthOnArrayRepeatOrInitializeChecks checkInfo =\n    let\n        maybeCall : Maybe ( String, { nodeRange : Range, fnRange : Range, firstArg : Node Expression, argsAfterFirst : List (Node Expression) } )\n        maybeCall =\n            firstThatConstructsJust\n                [ \\() ->\n                    AstHelpers.getSpecificFunctionCall ( [ \"Array\" ], \"repeat\" ) checkInfo.lookupTable checkInfo.firstArg\n                        |> Maybe.map (Tuple.pair \"repeat\")\n                , \\() ->\n                    AstHelpers.getSpecificFunctionCall ( [ \"Array\" ], \"initialize\" ) checkInfo.lookupTable checkInfo.firstArg\n                        |> Maybe.map (Tuple.pair \"initialize\")\n                ]\n                ()\n    in\n    case maybeCall of\n        Just ( fnName, call ) ->\n            let\n                maxFn : String\n                maxFn =\n                    qualifiedToString (qualify ( [ \"Basics\" ], \"max\" ) defaultQualifyResources)\n            in\n            Just\n                (Rule.errorWithFix\n                    { message = qualifiedToString (qualify checkInfo.fn checkInfo) ++ \" on an array created by \" ++ qualifiedToString (qualify ( [ \"Array\" ], fnName ) defaultQualifyResources) ++ \" with a given length will result in that length\"\n                    , details = [ \"You can replace this call by \" ++ maxFn ++ \" 0 with the given length. \" ++ maxFn ++ \" 0 makes sure that negative given lengths return 0.\" ]\n                    }\n                    checkInfo.fnRange\n                    (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range call.firstArg }\n                        ++ [ Fix.insertAt checkInfo.parentRange.start (qualifiedToString (qualify ( [ \"Basics\" ], \"max\" ) checkInfo) ++ \" 0 \") ]\n                    )\n                )\n\n        Nothing ->\n            Nothing\n\n\ngetChecks : EmptiableProperties (IndexableProperties otherProperties) -> CheckInfo -> Maybe (Error {})\ngetChecks collection checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            case checkInfo.secondArg of\n                Just arg ->\n                    callOnEmptyReturnsCheck { on = arg, resultAsString = maybeWithJustAsWrap.empty.asString }\n                        collection\n                        checkInfo\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            Evaluate.getInt checkInfo checkInfo.firstArg\n                |> Maybe.andThen (indexAccessChecks collection checkInfo)\n        ]\n        ()\n\n\nindexAccessChecks : IndexableProperties otherProperties -> CheckInfo -> Int -> Maybe (Error {})\nindexAccessChecks collection checkInfo n =\n    if n < 0 then\n        Just\n            (alwaysResultsInUnparenthesizedConstantError (qualifiedToString checkInfo.fn ++ \" with negative index\")\n                { replacement = maybeWithJustAsWrap.empty.asString, lastArg = secondArg checkInfo }\n                checkInfo\n            )\n\n    else\n        case secondArg checkInfo of\n            Just arg ->\n                case collection.literalElements checkInfo.lookupTable arg of\n                    Just literalElements ->\n                        case List.drop n literalElements |> List.head of\n                            Just element ->\n                                Just\n                                    (Rule.errorWithFix\n                                        { message = \"The element returned by \" ++ qualifiedToString checkInfo.fn ++ \" is known\"\n                                        , details = [ \"You can replace this call by Just the targeted element.\" ]\n                                        }\n                                        checkInfo.fnRange\n                                        (replaceBySubExpressionFix (Node.range arg) element\n                                            ++ [ Fix.replaceRangeBy (Range.combine [ checkInfo.fnRange, Node.range checkInfo.firstArg ])\n                                                    (qualifiedToString (qualify ( [ \"Maybe\" ], \"Just\" ) checkInfo))\n                                               ]\n                                        )\n                                    )\n\n                            Nothing ->\n                                Just\n                                    (Rule.errorWithFix\n                                        { message = qualifiedToString checkInfo.fn ++ \" with an index out of bounds of the given \" ++ collection.represents ++ \" will always return \" ++ qualifiedToString (qualify ( [ \"Maybe\" ], \"Nothing\" ) checkInfo)\n                                        , details = [ \"You can replace this call by Nothing.\" ]\n                                        }\n                                        checkInfo.fnRange\n                                        [ Fix.replaceRangeBy checkInfo.parentRange (qualifiedToString (qualify ( [ \"Maybe\" ], \"Nothing\" ) checkInfo)) ]\n                                    )\n\n                    Nothing ->\n                        Nothing\n\n            Nothing ->\n                Nothing\n\n\nsetChecks : CollectionProperties (FromListProperties (IndexableProperties {})) -> CheckInfo -> Maybe (Error {})\nsetChecks collection checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\emptiableArg -> callOnEmptyReturnsEmptyCheck emptiableArg collection checkInfo)\n                (thirdArg checkInfo)\n        , \\() ->\n            case Evaluate.getInt checkInfo checkInfo.firstArg of\n                Just n ->\n                    if n < 0 then\n                        Just\n                            (alwaysReturnsLastArgError\n                                (qualifiedToString checkInfo.fn ++ \" with negative index\")\n                                collection\n                                checkInfo\n                            )\n\n                    else\n                        case secondArg checkInfo of\n                            Just replacementArg ->\n                                setOnKnownElementChecks collection checkInfo n (Node.range replacementArg)\n\n                            Nothing ->\n                                Nothing\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\nsetOnKnownElementChecks :\n    CollectionProperties (FromListProperties (IndexableProperties {}))\n    -> CheckInfo\n    -> Int\n    -> Range\n    -> Maybe (Error {})\nsetOnKnownElementChecks collection checkInfo n replacementArgRange =\n    case thirdArg checkInfo of\n        Just collectionArg ->\n            case collection.literalElements checkInfo.lookupTable collectionArg of\n                Just literalElements ->\n                    case List.drop n literalElements |> List.head of\n                        Just element ->\n                            Just\n                                (Rule.errorWithFix\n                                    { message = qualifiedToString checkInfo.fn ++ \" will replace a known element in the \" ++ collection.fromListLiteralDescription\n                                    , details = [ \"You can move the replacement argument directly into the \" ++ collection.fromListLiteralDescription ++ \".\" ]\n                                    }\n                                    checkInfo.fnRange\n                                    (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range collectionArg }\n                                        ++ [ Fix.replaceRangeBy (Node.range element) (checkInfo.extractSourceCode replacementArgRange) ]\n                                    )\n                                )\n\n                        Nothing ->\n                            Just\n                                (Rule.errorWithFix\n                                    { message = qualifiedToString checkInfo.fn ++ \" with an index out of bounds of the given \" ++ collection.represents ++ \" will always return the same given \" ++ collection.represents\n                                    , details = [ \"You can replace this call by the given \" ++ collection.represents ++ \".\" ]\n                                    }\n                                    checkInfo.fnRange\n                                    (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range collectionArg })\n                                )\n\n                Nothing ->\n                    Nothing\n\n        Nothing ->\n            Nothing\n\n\nemptiableReverseChecks : EmptiableProperties otherProperties -> CheckInfo -> Maybe (Error {})\nemptiableReverseChecks emptiable checkInfo =\n    firstThatConstructsJust\n        [ \\() -> callOnEmptyReturnsEmptyCheck checkInfo.firstArg emptiable checkInfo\n        , \\() -> removeAlongWithOtherFunctionCheck checkInfo\n        ]\n        ()\n\n\nlistReverseChecks : CheckInfo -> Maybe (Error {})\nlistReverseChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> emptiableReverseChecks listCollection checkInfo\n        , \\() -> callOnSingletonListDoesNotChangeItCheck checkInfo.firstArg checkInfo\n        ]\n        ()\n\n\nlistReverseCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nlistReverseCompositionChecks checkInfo =\n    compositionAfterWrapIsUnnecessaryCheck listCollection checkInfo\n\n\nlistSortChecks : CheckInfo -> Maybe (Error {})\nlistSortChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> callOnEmptyReturnsEmptyCheck checkInfo.firstArg listCollection checkInfo\n        , \\() -> callOnSingletonListDoesNotChangeItCheck checkInfo.firstArg checkInfo\n        ]\n        ()\n\n\nlistSortByChecks : CheckInfo -> Maybe (Error {})\nlistSortByChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            case secondArg checkInfo of\n                Just listArg ->\n                    firstThatConstructsJust\n                        [ \\() -> callOnEmptyReturnsEmptyCheck listArg listCollection checkInfo\n                        , \\() -> callOnSingletonListDoesNotChangeItCheck listArg checkInfo\n                        ]\n                        ()\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getAlwaysResult checkInfo.lookupTable checkInfo.firstArg of\n                Just _ ->\n                    Just\n                        (alwaysReturnsLastArgError\n                            (qualifiedToString checkInfo.fn ++ \" (always a)\")\n                            { represents = \"list\" }\n                            checkInfo\n                        )\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            operationWithIdentityCanBeReplacedChecks { replacementFn = ( [ \"List\" ], \"sort\" ) } checkInfo\n        ]\n        ()\n\n\nlistSortWithChecks : CheckInfo -> Maybe (Error {})\nlistSortWithChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            case secondArg checkInfo of\n                Just listArg ->\n                    firstThatConstructsJust\n                        [ \\() -> callOnEmptyReturnsEmptyCheck listArg listCollection checkInfo\n                        , \\() -> callOnSingletonListDoesNotChangeItCheck listArg checkInfo\n                        ]\n                        ()\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            let\n                alwaysAlwaysOrder : Maybe Order\n                alwaysAlwaysOrder =\n                    AstHelpers.getAlwaysResult checkInfo.lookupTable checkInfo.firstArg\n                        |> Maybe.andThen (AstHelpers.getAlwaysResult checkInfo.lookupTable)\n                        |> Maybe.andThen (AstHelpers.getOrder checkInfo.lookupTable)\n            in\n            case alwaysAlwaysOrder of\n                Just order ->\n                    let\n                        fixToIdentity : Error {}\n                        fixToIdentity =\n                            alwaysReturnsLastArgError\n                                (qualifiedToString checkInfo.fn ++ \" (\\\\_ _ -> \" ++ AstHelpers.orderToString order ++ \")\")\n                                { represents = \"list\" }\n                                checkInfo\n                    in\n                    case order of\n                        LT ->\n                            Just\n                                (Rule.errorWithFix\n                                    { message = qualifiedToString checkInfo.fn ++ \" (\\\\_ _ -> LT) is the same as \" ++ qualifiedToString ( [ \"List\" ], \"reverse\" )\n                                    , details = [ \"You can replace this call by \" ++ qualifiedToString ( [ \"List\" ], \"reverse\" ) ++ \".\" ]\n                                    }\n                                    checkInfo.fnRange\n                                    [ Fix.replaceRangeBy\n                                        { start = checkInfo.fnRange.start\n                                        , end = (Node.range checkInfo.firstArg).end\n                                        }\n                                        (qualifiedToString (qualify ( [ \"List\" ], \"reverse\" ) checkInfo))\n                                    ]\n                                )\n\n                        EQ ->\n                            Just fixToIdentity\n\n                        GT ->\n                            Just fixToIdentity\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\nlistTakeChecks : CheckInfo -> Maybe (Error {})\nlistTakeChecks checkInfo =\n    let\n        maybeListArg : Maybe (Node Expression)\n        maybeListArg =\n            secondArg checkInfo\n    in\n    firstThatConstructsJust\n        [ \\() ->\n            case Evaluate.getInt checkInfo checkInfo.firstArg of\n                Just length ->\n                    callWithNonPositiveIntCanBeReplacedByCheck\n                        { int = length\n                        , intDescription = \"length\"\n                        , replacement = \\_ -> \"[]\"\n                        , lastArg = maybeListArg\n                        }\n                        checkInfo\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            Maybe.andThen\n                (\\listArg -> callOnEmptyReturnsEmptyCheck listArg listCollection checkInfo)\n                maybeListArg\n        ]\n        ()\n\n\nlistDropChecks : CheckInfo -> Maybe (Error {})\nlistDropChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            case Evaluate.getInt checkInfo checkInfo.firstArg of\n                Just 0 ->\n                    Just\n                        (alwaysReturnsLastArgError\n                            (qualifiedToString checkInfo.fn ++ \" 0\")\n                            { represents = \"list\" }\n                            checkInfo\n                        )\n\n                _ ->\n                    Nothing\n        , \\() ->\n            Maybe.andThen\n                (\\listArg -> callOnEmptyReturnsEmptyCheck listArg listCollection checkInfo)\n                (secondArg checkInfo)\n        ]\n        ()\n\n\nemptiableMapNChecks : { n : Int } -> EmptiableProperties otherProperties -> CheckInfo -> Maybe (Error {})\nemptiableMapNChecks { n } emptiable checkInfo =\n    if List.any (emptiable.empty.is checkInfo.lookupTable) checkInfo.argsAfterFirst then\n        let\n            callReplacement : QualifyResources a -> String\n            callReplacement resources =\n                multiAlways (n - List.length checkInfo.argsAfterFirst) (emptyAsString resources emptiable) resources\n        in\n        Just\n            (Rule.errorWithFix\n                { message = qualifiedToString checkInfo.fn ++ \" with any \" ++ emptiable.represents ++ \" being \" ++ emptiable.empty.asString defaultQualifyResources ++ \" will result in \" ++ emptiable.empty.asString defaultQualifyResources\n                , details = [ \"You can replace this call by \" ++ callReplacement defaultQualifyResources ++ \".\" ]\n                }\n                checkInfo.fnRange\n                [ Fix.replaceRangeBy checkInfo.parentRange (callReplacement checkInfo) ]\n            )\n\n    else\n        Nothing\n\n\n{-| When all arguments of a fully applied `mapN` are wrapped,\napply the given function to the values inside and wrap the whole thing again:\n\n    map2 f (wrap first) (wrap second)\n    --> wrap (f first second)\n\nFor example given `resultWithOkAsWrap`:\n\n    Result.map2 f (Ok first) (Ok second)\n    --> Ok (f first second)\n\nThis is pretty similar to `wrapperSequenceChecks` where we look at arguments instead of list elements.\n\n-}\nwrapperMapNChecks : { n : Int } -> WrapperProperties otherProperties -> CheckInfo -> Maybe (Error {})\nwrapperMapNChecks config wrapper checkInfo =\n    if List.length checkInfo.argsAfterFirst == config.n then\n        -- fully applied\n        case traverse (getValueWithNodeRange (wrapper.wrap.getValue checkInfo.lookupTable)) checkInfo.argsAfterFirst of\n            Just wraps ->\n                let\n                    wrapFn : ( ModuleName, String )\n                    wrapFn =\n                        ( wrapper.moduleName, wrapper.wrap.fnName )\n\n                    wrapFnDescription : String\n                    wrapFnDescription =\n                        qualifiedToString (qualify wrapFn defaultQualifyResources)\n                in\n                Just\n                    (Rule.errorWithFix\n                        { message = qualifiedToString checkInfo.fn ++ \" where each \" ++ wrapper.represents ++ \" is \" ++ descriptionForIndefinite wrapper.wrap.description ++ \" will result in \" ++ wrapFnDescription ++ \" on the values inside\"\n                        , details = [ \"You can replace this call by \" ++ wrapFnDescription ++ \" with the function applied to the values inside each \" ++ descriptionWithoutArticle wrapper.wrap.description ++ \".\" ]\n                        }\n                        checkInfo.fnRange\n                        (keepOnlyFix\n                            { parentRange = Range.combine [ checkInfo.fnRange, Node.range checkInfo.firstArg ]\n                            , keep = Node.range checkInfo.firstArg\n                            }\n                            ++ List.concatMap (\\wrap -> replaceBySubExpressionFix wrap.nodeRange wrap.value) wraps\n                            ++ (case checkInfo.callStyle of\n                                    Pipe LeftToRight ->\n                                        [ Fix.insertAt checkInfo.parentRange.end\n                                            (\" |> \" ++ qualifiedToString (qualify wrapFn checkInfo))\n                                        ]\n\n                                    Pipe RightToLeft ->\n                                        [ Fix.insertAt checkInfo.parentRange.start\n                                            (qualifiedToString (qualify wrapFn checkInfo) ++ \" <| \")\n                                        ]\n\n                                    Application ->\n                                        [ Fix.insertAt checkInfo.parentRange.end \")\"\n                                        , Fix.insertAt checkInfo.parentRange.start (qualifiedToString (qualify wrapFn checkInfo) ++ \" (\")\n                                        ]\n                               )\n                        )\n                    )\n\n            Nothing ->\n                Nothing\n\n    else\n        Nothing\n\n\n{-| If we find an empty argument given to the `mapN`, we either\n\n  - replace the whole call by the first empty argument if all earlier arguments are wrapped\n\n        map3 f (wrap first) empty thirdWrapper\n        --> empty\n\n        map2 f empty secondWrapper\n        --> empty\n\n    For example given `resultWithOkAsWrap`:\n\n        Result.map3 f (Ok x) (Err y) thirdResult\n        --> Err y\n\n  - ignore arguments after the known empty argument because they will never have an effect on the result\n\n        map3 f emptyOrWrappedWeDoNotKnow empty thirdWrapper\n        --> map2 f emptyOrWrappedWeDoNotKnow empty\n\n    For example given `resultWithOkAsWrap`:\n\n        Result.map3 f errorOrOkWeDoNotKnow (Err x) thirdResult\n        --> Result.map2 f errorOrOkWeDoNotKnow (Err x)\n\nThis is pretty similar to `sequenceOrFirstEmptyChecks` where we look at arguments instead of list elements.\n\n-}\nmapNOrFirstEmptyConstructionChecks :\n    { n : Int }\n    ->\n        WrapperProperties\n            { otherProperties\n                | empty :\n                    { empty\n                        | is : ModuleNameLookupTable -> Node Expression -> Bool\n                        , description : Description\n                    }\n            }\n    -> CheckInfo\n    -> Maybe (Error {})\nmapNOrFirstEmptyConstructionChecks config emptiable checkInfo =\n    case findMapAndAllBefore (getEmptyExpressionNode checkInfo.lookupTable emptiable) checkInfo.argsAfterFirst of\n        -- no empty arg found\n        Nothing ->\n            Nothing\n\n        Just emptyAndBefore ->\n            case traverse (\\el -> emptiable.wrap.getValue checkInfo.lookupTable el) emptyAndBefore.before of\n                -- all args before are known to not be empty\n                Just _ ->\n                    let\n                        replacement : { description : String, fix : List Fix }\n                        replacement =\n                            case config.n - List.length checkInfo.argsAfterFirst of\n                                -- fully applied\n                                0 ->\n                                    { description = descriptionForDefinite \"the first\" emptiable.empty.description\n                                    , fix = replaceBySubExpressionFix checkInfo.parentRange emptyAndBefore.found\n                                    }\n\n                                -- one arg curried\n                                1 ->\n                                    { description =\n                                        \"always with \" ++ descriptionForDefinite \"the first\" emptiable.empty.description\n                                    , fix =\n                                        replaceBySubExpressionFix checkInfo.parentRange emptyAndBefore.found\n                                            ++ [ Fix.insertAt checkInfo.parentRange.start (qualifiedToString (qualify ( [ \"Basics\" ], \"always\" ) checkInfo) ++ \" \") ]\n                                    }\n\n                                -- multiple args curried\n                                atLeast2 ->\n                                    let\n                                        lambdaStart : String\n                                        lambdaStart =\n                                            \"\\\\\" ++ String.repeat atLeast2 \"_ \" ++ \"-> \"\n                                    in\n                                    { description =\n                                        lambdaStart ++ \"with \" ++ descriptionForDefinite \"the first\" emptiable.empty.description\n                                    , fix =\n                                        replaceBySubExpressionFix checkInfo.parentRange emptyAndBefore.found\n                                            ++ [ Fix.insertAt checkInfo.parentRange.start (\"(\" ++ lambdaStart)\n                                               , Fix.insertAt checkInfo.parentRange.end \")\"\n                                               ]\n                                    }\n                    in\n                    Just\n                        (Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" where we know \" ++ descriptionForDefinite \"the first\" emptiable.empty.description ++ \" will result in \" ++ descriptionForDefinite \"that\" emptiable.empty.description\n                            , details = [ \"You can replace this call by \" ++ replacement.description ++ \".\" ]\n                            }\n                            checkInfo.fnRange\n                            replacement.fix\n                        )\n\n                -- some args before could be empty\n                Nothing ->\n                    let\n                        keptArgCount : Int\n                        keptArgCount =\n                            List.length emptyAndBefore.before + 1\n                    in\n                    if keptArgCount == config.n then\n                        -- last arg is empty\n                        Nothing\n\n                    else\n                        -- there are args (curried or present) after the known empty arg\n                        let\n                            replacementMap : ( ModuleName, String )\n                            replacementMap =\n                                ( AstHelpers.qualifiedModuleName checkInfo.fn, \"map\" ++ String.fromInt keptArgCount )\n\n                            keptRange : Range\n                            keptRange =\n                                Range.combine\n                                    (checkInfo.fnRange\n                                        :: Node.range emptyAndBefore.found\n                                        :: List.map Node.range emptyAndBefore.before\n                                    )\n\n                            replacement : { description : String, fix : List Fix }\n                            replacement =\n                                case config.n - List.length checkInfo.argsAfterFirst of\n                                    -- fully applied\n                                    0 ->\n                                        { fix =\n                                            [ Fix.removeRange\n                                                { start = keptRange.end, end = checkInfo.parentRange.end }\n                                            , Fix.replaceRangeBy checkInfo.fnRange (qualifiedToString (qualify replacementMap checkInfo))\n                                            , Fix.removeRange\n                                                { start = checkInfo.parentRange.start, end = keptRange.start }\n                                            ]\n                                        , description =\n                                            qualifiedToString replacementMap ++ \" with the same arguments until \" ++ descriptionForDefinite \"the first\" emptiable.empty.description\n                                        }\n\n                                    -- one arg curried\n                                    1 ->\n                                        { fix =\n                                            [ Fix.replaceRangeBy\n                                                { start = keptRange.end, end = checkInfo.parentRange.end }\n                                                \")\"\n                                            , Fix.replaceRangeBy checkInfo.fnRange (qualifiedToString (qualify replacementMap checkInfo))\n                                            , Fix.replaceRangeBy\n                                                { start = checkInfo.parentRange.start\n                                                , end = keptRange.start\n                                                }\n                                                (qualifiedToString (qualify ( [ \"Basics\" ], \"always\" ) checkInfo) ++ \" (\")\n                                            ]\n                                        , description =\n                                            \"always with \" ++ qualifiedToString replacementMap ++ \" with the same arguments until \" ++ descriptionForDefinite \"the first\" emptiable.empty.description\n                                        }\n\n                                    -- multiple args curried\n                                    atLeast2 ->\n                                        let\n                                            lambdaStart : String\n                                            lambdaStart =\n                                                \"\\\\\" ++ String.repeat atLeast2 \"_ \" ++ \"-> \"\n                                        in\n                                        { fix =\n                                            [ Fix.replaceRangeBy\n                                                { start = keptRange.end, end = checkInfo.parentRange.end }\n                                                \")\"\n                                            , Fix.replaceRangeBy checkInfo.fnRange (qualifiedToString (qualify replacementMap checkInfo))\n                                            , Fix.replaceRangeBy\n                                                { start = checkInfo.parentRange.start, end = keptRange.start }\n                                                (\"(\" ++ lambdaStart)\n                                            ]\n                                        , description =\n                                            lambdaStart ++ \"with \" ++ qualifiedToString replacementMap ++ \" with the same arguments until \" ++ descriptionForDefinite \"the first\" emptiable.empty.description\n                                        }\n                        in\n                        Just\n                            (Rule.errorWithFix\n                                { message = qualifiedToString checkInfo.fn ++ \" with \" ++ descriptionForIndefinite emptiable.empty.description ++ \" early will ignore later arguments\"\n                                , details = [ \"You can replace this call by \" ++ replacement.description ++ \".\" ]\n                                }\n                                checkInfo.fnRange\n                                replacement.fix\n                            )\n\n\nlistUnzipChecks : CheckInfo -> Maybe (Error {})\nlistUnzipChecks checkInfo =\n    callOnEmptyReturnsCheck { on = checkInfo.firstArg, resultAsString = \\_ -> \"( [], [] )\" } listCollection checkInfo\n\n\nsetFromListChecks : CheckInfo -> Maybe (Error {})\nsetFromListChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> collectionFromListChecks setCollection checkInfo\n        , \\() -> wrapperFromListSingletonChecks setCollection checkInfo\n        , \\() -> onCallToInverseReturnsItsArgumentCheck ( [ \"Set\" ], \"toList\" ) checkInfo\n        ]\n        ()\n\n\nsetFromListCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nsetFromListCompositionChecks checkInfo =\n    wrapperFromListSingletonCompositionChecks setCollection checkInfo\n\n\ndictFromListChecks : CheckInfo -> Maybe (Error {})\ndictFromListChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> collectionFromListChecks dictCollection checkInfo\n        , \\() -> onCallToInverseReturnsItsArgumentCheck ( [ \"Dict\" ], \"toList\" ) checkInfo\n        ]\n        ()\n\n\nsubAndCmdBatchChecks :\n    EmptiableProperties otherProperties\n    -> CheckInfo\n    -> Maybe (Error {})\nsubAndCmdBatchChecks batchable checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            callOnEmptyReturnsCheck { on = checkInfo.firstArg, resultAsString = batchable.empty.asString }\n                listCollection\n                checkInfo\n        , \\() -> callOnWrapReturnsItsValue checkInfo.firstArg listCollection checkInfo\n        , \\() -> irrelevantEmptyElementInGivenListArgCheck checkInfo.firstArg batchable checkInfo\n        ]\n        ()\n\n\n\n-- TASK\n\n\ntaskMapChecks : CheckInfo -> Maybe (Error {})\ntaskMapChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> emptiableMapChecks taskWithSucceedAsWrap checkInfo\n        , \\() -> mapWrapChecks taskWithSucceedAsWrap checkInfo\n        ]\n        ()\n\n\ntaskMapCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\ntaskMapCompositionChecks checkInfo =\n    wrapToMapCompositionChecks taskWithSucceedAsWrap checkInfo\n\n\ntaskMapNChecks : { n : Int } -> CheckInfo -> Maybe (Error {})\ntaskMapNChecks config checkInfo =\n    firstThatConstructsJust\n        [ \\() -> wrapperMapNChecks config taskWithSucceedAsWrap checkInfo\n        , \\() -> mapNOrFirstEmptyConstructionChecks config taskWithSucceedAsWrap checkInfo\n        ]\n        ()\n\n\ntaskAndThenChecks : CheckInfo -> Maybe (Error {})\ntaskAndThenChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\taskArg -> callOnEmptyReturnsEmptyCheck taskArg taskWithSucceedAsWrap checkInfo)\n                (secondArg checkInfo)\n        , \\() -> wrapperAndThenChecks taskWithSucceedAsWrap checkInfo\n        ]\n        ()\n\n\ntaskMapErrorChecks : CheckInfo -> Maybe (Error {})\ntaskMapErrorChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> emptiableMapChecks taskWithFailAsWrap checkInfo\n        , \\() -> mapWrapChecks taskWithFailAsWrap checkInfo\n        ]\n        ()\n\n\ntaskMapErrorCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\ntaskMapErrorCompositionChecks checkInfo =\n    wrapToMapCompositionChecks taskWithFailAsWrap checkInfo\n\n\ntaskOnErrorChecks : CheckInfo -> Maybe (Error {})\ntaskOnErrorChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\taskArg -> callOnEmptyReturnsEmptyCheck taskArg taskWithFailAsWrap checkInfo)\n                (secondArg checkInfo)\n        , \\() -> wrapperAndThenChecks taskWithFailAsWrap checkInfo\n        ]\n        ()\n\n\ntaskSequenceChecks : CheckInfo -> Maybe (Error {})\ntaskSequenceChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> wrapperSequenceChecks taskWithSucceedAsWrap checkInfo\n        , \\() -> sequenceOrFirstEmptyChecks taskWithSucceedAsWrap checkInfo\n        ]\n        ()\n\n\ntaskSequenceCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\ntaskSequenceCompositionChecks checkInfo =\n    mappableSequenceCompositionChecks taskWithSucceedAsWrap checkInfo\n\n\nsequenceOrFirstEmptyChecks :\n    WrapperProperties\n        { otherProperties\n            | empty :\n                { empty\n                    | is : ModuleNameLookupTable -> Node Expression -> Bool\n                    , description : Description\n                }\n        }\n    -> CheckInfo\n    -> Maybe (Error {})\nsequenceOrFirstEmptyChecks emptiable checkInfo =\n    case AstHelpers.getListLiteral checkInfo.firstArg of\n        Just list ->\n            firstThatConstructsJust\n                [ \\() ->\n                    case List.filter (\\el -> isNothing (emptiable.wrap.getValue checkInfo.lookupTable el)) list of\n                        firstNonWrappedElement :: _ ->\n                            if emptiable.empty.is checkInfo.lookupTable firstNonWrappedElement then\n                                Just\n                                    (Rule.errorWithFix\n                                        { message = qualifiedToString checkInfo.fn ++ \" on a list containing \" ++ descriptionForIndefinite emptiable.empty.description ++ \" will result in \" ++ descriptionForDefinite \"the first\" emptiable.empty.description\n                                        , details = [ \"You can replace this call by \" ++ descriptionForDefinite \"the first\" emptiable.empty.description ++ \" in the list.\" ]\n                                        }\n                                        checkInfo.fnRange\n                                        (replaceBySubExpressionFix checkInfo.parentRange firstNonWrappedElement)\n                                    )\n\n                            else\n                                Nothing\n\n                        [] ->\n                            Nothing\n                , \\() ->\n                    case findMapNeighboring (\\el -> getEmpty checkInfo.lookupTable emptiable el) list of\n                        Just emptyAndNeighbors ->\n                            case emptyAndNeighbors.after of\n                                Just _ ->\n                                    Just\n                                        (Rule.errorWithFix\n                                            { message = qualifiedToString checkInfo.fn ++ \" on a list containing \" ++ descriptionForIndefinite emptiable.empty.description ++ \" early will ignore later elements\"\n                                            , details = [ \"You can remove all list elements after \" ++ descriptionForDefinite \"the first\" emptiable.empty.description ++ \".\" ]\n                                            }\n                                            checkInfo.fnRange\n                                            [ Fix.removeRange\n                                                { start = emptyAndNeighbors.found.range.end\n                                                , end = endWithoutBoundary (Node.range checkInfo.firstArg)\n                                                }\n                                            ]\n                                        )\n\n                                Nothing ->\n                                    Nothing\n\n                        Nothing ->\n                            Nothing\n                ]\n                ()\n\n        Nothing ->\n            Nothing\n\n\nwrapperSequenceChecks : WrapperProperties { otherProperties | mapFnName : String } -> CheckInfo -> Maybe (Error {})\nwrapperSequenceChecks wrapper checkInfo =\n    let\n        wrapFn : ( ModuleName, String )\n        wrapFn =\n            ( wrapper.moduleName, wrapper.wrap.fnName )\n    in\n    firstThatConstructsJust\n        [ \\() ->\n            callOnEmptyReturnsCheck\n                { on = checkInfo.firstArg\n                , resultAsString =\n                    \\res ->\n                        qualifiedToString (qualify wrapFn res)\n                            ++ \" []\"\n                }\n                listCollection\n                checkInfo\n        , \\() ->\n            case AstHelpers.getListSingleton checkInfo.lookupTable checkInfo.firstArg of\n                Just singletonList ->\n                    let\n                        mapFn : ( ModuleName, String )\n                        mapFn =\n                            ( wrapper.moduleName, wrapper.mapFnName )\n\n                        replacement : QualifyResources a -> String\n                        replacement qualifyResources =\n                            qualifiedToString (qualify mapFn qualifyResources)\n                                ++ \" \"\n                                ++ qualifiedToString (qualify ( [ \"List\" ], \"singleton\" ) qualifyResources)\n                    in\n                    Just\n                        (Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" on a singleton list is the same as \" ++ replacement defaultQualifyResources ++ \" on the value inside\"\n                            , details = [ \"You can replace this call by \" ++ replacement defaultQualifyResources ++ \" on the value inside the singleton list.\" ]\n                            }\n                            checkInfo.fnRange\n                            (Fix.replaceRangeBy checkInfo.fnRange\n                                (replacement checkInfo)\n                                :: replaceBySubExpressionFix (Node.range checkInfo.firstArg) singletonList.element\n                            )\n                        )\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getListLiteral checkInfo.firstArg of\n                Just list ->\n                    case traverse (getValueWithNodeRange (wrapper.wrap.getValue checkInfo.lookupTable)) list of\n                        Just wraps ->\n                            Just\n                                (Rule.errorWithFix\n                                    { message = qualifiedToString checkInfo.fn ++ \" on a list where each element is \" ++ descriptionForIndefinite wrapper.wrap.description ++ \" will result in \" ++ qualifiedToString ( wrapper.moduleName, wrapper.wrap.fnName ) ++ \" on the values inside\"\n                                    , details = [ \"You can replace this call by \" ++ qualifiedToString wrapFn ++ \" on a list where each element is replaced by its value inside \" ++ descriptionForDefinite \"the\" wrapper.wrap.description ++ \".\" ]\n                                    }\n                                    checkInfo.fnRange\n                                    (Fix.replaceRangeBy\n                                        checkInfo.fnRange\n                                        (qualifiedToString (qualify wrapFn checkInfo))\n                                        :: List.concatMap\n                                            (\\wrap -> keepOnlyFix { parentRange = wrap.nodeRange, keep = Node.range wrap.value })\n                                            wraps\n                                    )\n                                )\n\n                        Nothing ->\n                            Nothing\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\nmappableSequenceCompositionChecks : TypeProperties { otherProperties | mapFnName : String } -> CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nmappableSequenceCompositionChecks mappable checkInfo =\n    case checkInfo.earlier.fn of\n        ( [ \"List\" ], \"singleton\" ) ->\n            let\n                mapFn : ( ModuleName, String )\n                mapFn =\n                    ( mappable.moduleName, mappable.mapFnName )\n\n                replacement : QualifyResources a -> String\n                replacement qualifyResources =\n                    qualifiedToString (qualify mapFn qualifyResources)\n                        ++ \" \"\n                        ++ qualifiedToString (qualify ( [ \"List\" ], \"singleton\" ) qualifyResources)\n            in\n            Just\n                { info =\n                    { message = qualifiedToString checkInfo.later.fn ++ \" on a singleton list is the same as \" ++ replacement defaultQualifyResources ++ \" on the value inside\"\n                    , details = [ \"You can replace this call by \" ++ replacement defaultQualifyResources ++ \".\" ]\n                    }\n                , fix = [ Fix.replaceRangeBy checkInfo.parentRange (replacement checkInfo) ]\n                }\n\n        _ ->\n            Nothing\n\n\n\n-- HTML.ATTRIBUTES\n\n\nhtmlAttributesClassListChecks : CheckInfo -> Maybe (Error {})\nhtmlAttributesClassListChecks checkInfo =\n    let\n        listArg : Node Expression\n        listArg =\n            checkInfo.firstArg\n\n        getTupleWithSpecificSecond : Bool -> Node Expression -> Maybe { range : Range, first : Node Expression }\n        getTupleWithSpecificSecond specificBool expressionNode =\n            case AstHelpers.getTuple2Literal expressionNode of\n                Just tuple ->\n                    case AstHelpers.getSpecificBool specificBool checkInfo.lookupTable tuple.second of\n                        Just _ ->\n                            Just { range = tuple.range, first = tuple.first }\n\n                        Nothing ->\n                            Nothing\n\n                Nothing ->\n                    Nothing\n\n        htmlAttributesClassListFalseElementError : { message : String, details : List String }\n        htmlAttributesClassListFalseElementError =\n            { message = \"In a \" ++ qualifiedToString checkInfo.fn ++ \", a tuple paired with False can be removed\"\n            , details = [ \"You can remove the tuple list element where the second part is False.\" ]\n            }\n    in\n    firstThatConstructsJust\n        [ \\() ->\n            case AstHelpers.getListSingleton checkInfo.lookupTable listArg of\n                Just single ->\n                    case AstHelpers.getTuple2Literal single.element of\n                        Just tuple ->\n                            case AstHelpers.getBool checkInfo.lookupTable tuple.second of\n                                Just bool ->\n                                    if bool then\n                                        let\n                                            replacementFn : ( ModuleName, String )\n                                            replacementFn =\n                                                ( [ \"Html\", \"Attributes\" ], \"class\" )\n                                        in\n                                        Just\n                                            (Rule.errorWithFix\n                                                { message = qualifiedToString checkInfo.fn ++ \" with a single tuple paired with True can be replaced with \" ++ qualifiedToString replacementFn\n                                                , details = [ \"You can replace this call by \" ++ qualifiedToString replacementFn ++ \" with the String from the single tuple list element.\" ]\n                                                }\n                                                checkInfo.fnRange\n                                                (replaceBySubExpressionFix (Node.range listArg) tuple.first\n                                                    ++ [ Fix.replaceRangeBy checkInfo.fnRange\n                                                            (qualifiedToString (qualify replacementFn checkInfo))\n                                                       ]\n                                                )\n                                            )\n\n                                    else\n                                        Just\n                                            (Rule.errorWithFix htmlAttributesClassListFalseElementError\n                                                checkInfo.fnRange\n                                                [ Fix.replaceRangeBy (Node.range listArg) \"[]\" ]\n                                            )\n\n                                Nothing ->\n                                    Nothing\n\n                        Nothing ->\n                            Nothing\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getListLiteral listArg of\n                Just (tuple0 :: tuple1 :: tuple2Up) ->\n                    case findMapNeighboring (getTupleWithSpecificSecond False) (tuple0 :: tuple1 :: tuple2Up) of\n                        Just classPart ->\n                            Just\n                                (Rule.errorWithFix htmlAttributesClassListFalseElementError\n                                    checkInfo.fnRange\n                                    (listLiteralElementRemoveFix classPart)\n                                )\n\n                        Nothing ->\n                            Nothing\n\n                _ ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getCollapsedCons listArg of\n                Just classParts ->\n                    case findMapNeighboring (getTupleWithSpecificSecond False) classParts.consed of\n                        Just classPart ->\n                            Just\n                                (Rule.errorWithFix htmlAttributesClassListFalseElementError\n                                    checkInfo.fnRange\n                                    (collapsedConsRemoveElementFix\n                                        { toRemove = classPart\n                                        , tailRange = Node.range classParts.tail\n                                        }\n                                    )\n                                )\n\n                        Nothing ->\n                            Nothing\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\n\n-- PARSER\n\n\noneOfChecks : CheckInfo -> Maybe (Error {})\noneOfChecks checkInfo =\n    case AstHelpers.getListSingleton checkInfo.lookupTable checkInfo.firstArg of\n        Just listSingletonArg ->\n            Just\n                (Rule.errorWithFix\n                    { message = \"Unnecessary oneOf\"\n                    , details = [ \"There is only a single element in the list of elements to try out.\" ]\n                    }\n                    checkInfo.fnRange\n                    (replaceBySubExpressionFix checkInfo.parentRange listSingletonArg.element)\n                )\n\n        Nothing ->\n            Nothing\n\n\n\n-- RANDOM\n\n\nrandomUniformChecks : CheckInfo -> Maybe (Error {})\nrandomUniformChecks checkInfo =\n    case secondArg checkInfo of\n        Just otherOptionsArg ->\n            case AstHelpers.getListLiteral otherOptionsArg of\n                Just [] ->\n                    let\n                        onlyValueRange : Range\n                        onlyValueRange =\n                            Node.range checkInfo.firstArg\n                    in\n                    Just\n                        (Rule.errorWithFix\n                            { message = \"Random.uniform with only one possible value can be replaced by Random.constant\"\n                            , details = [ \"Only a single value can be produced by this Random.uniform call. You can replace the call with Random.constant with the value.\" ]\n                            }\n                            checkInfo.fnRange\n                            [ Fix.replaceRangeBy { start = checkInfo.parentRange.start, end = onlyValueRange.start }\n                                (qualifiedToString (qualify ( [ \"Random\" ], \"constant\" ) checkInfo) ++ \" \")\n                            , Fix.removeRange { start = onlyValueRange.end, end = checkInfo.parentRange.end }\n                            ]\n                        )\n\n                _ ->\n                    Nothing\n\n        Nothing ->\n            Nothing\n\n\nrandomWeightedChecks : CheckInfo -> Maybe (Error {})\nrandomWeightedChecks checkInfo =\n    case secondArg checkInfo of\n        Just otherOptionsArg ->\n            case AstHelpers.getListLiteral otherOptionsArg of\n                Just [] ->\n                    Just\n                        (Rule.errorWithFix\n                            { message = \"Random.weighted with only one possible value can be replaced by Random.constant\"\n                            , details = [ \"Only a single value can be produced by this Random.weighted call. You can replace the call with Random.constant with the value.\" ]\n                            }\n                            checkInfo.fnRange\n                            (case Node.value checkInfo.firstArg of\n                                Expression.TupledExpression (_ :: (Node valuePartRange _) :: []) ->\n                                    [ Fix.replaceRangeBy { start = checkInfo.parentRange.start, end = valuePartRange.start }\n                                        (qualifiedToString (qualify ( [ \"Random\" ], \"constant\" ) checkInfo) ++ \" \")\n                                    , Fix.removeRange { start = valuePartRange.end, end = checkInfo.parentRange.end }\n                                    ]\n\n                                _ ->\n                                    let\n                                        tupleRange : Range\n                                        tupleRange =\n                                            Node.range checkInfo.firstArg\n                                    in\n                                    [ Fix.replaceRangeBy { start = checkInfo.parentRange.start, end = tupleRange.start }\n                                        (qualifiedToString (qualify ( [ \"Random\" ], \"constant\" ) checkInfo) ++ \" (Tuple.first \")\n                                    , Fix.replaceRangeBy { start = tupleRange.end, end = checkInfo.parentRange.end }\n                                        \")\"\n                                    ]\n                            )\n                        )\n\n                _ ->\n                    Nothing\n\n        Nothing ->\n            Nothing\n\n\nrandomListChecks : CheckInfo -> Maybe (Error {})\nrandomListChecks checkInfo =\n    let\n        maybeElementGeneratorArg : Maybe (Node Expression)\n        maybeElementGeneratorArg =\n            secondArg checkInfo\n    in\n    firstThatConstructsJust\n        [ \\() ->\n            case Evaluate.getInt checkInfo checkInfo.firstArg of\n                Just 1 ->\n                    Just\n                        (Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" 1 can be replaced by \" ++ qualifiedToString ( [ \"Random\" ], \"map\" ) ++ \" \" ++ qualifiedToString ( [ \"List\" ], \"singleton\" )\n                            , details = [ \"This \" ++ qualifiedToString checkInfo.fn ++ \" call always produces a list with one generated element. This means you can replace the call with \" ++ qualifiedToString ( [ \"Random\" ], \"map\" ) ++ \" \" ++ qualifiedToString ( [ \"List\" ], \"singleton\" ) ++ \".\" ]\n                            }\n                            checkInfo.fnRange\n                            [ Fix.replaceRangeBy\n                                (Range.combine [ checkInfo.fnRange, Node.range checkInfo.firstArg ])\n                                (qualifiedToString (qualify ( [ \"Random\" ], \"map\" ) checkInfo)\n                                    ++ \" \"\n                                    ++ qualifiedToString (qualify ( [ \"List\" ], \"singleton\" ) checkInfo)\n                                )\n                            ]\n                        )\n\n                Just non1Length ->\n                    if non1Length <= 0 then\n                        Just\n                            (alwaysResultsInConstantError\n                                (case non1Length of\n                                    0 ->\n                                        \"Random.list with length 0\"\n\n                                    _ ->\n                                        \"Random.list with a negative length\"\n                                )\n                                { replacement =\n                                    \\res -> qualifiedToString (qualify ( [ \"Random\" ], \"constant\" ) res) ++ \" []\"\n                                , replacementNeedsParens = True\n                                , lastArg = maybeElementGeneratorArg\n                                }\n                                checkInfo\n                            )\n\n                    else\n                        Nothing\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case maybeElementGeneratorArg of\n                Just elementGeneratorArg ->\n                    case AstHelpers.getSpecificFunctionCall ( [ \"Random\" ], \"constant\" ) checkInfo.lookupTable elementGeneratorArg of\n                        Just constantCall ->\n                            let\n                                currentAsString : String\n                                currentAsString =\n                                    qualifiedToString checkInfo.fn ++ \" n (\" ++ qualifiedToString ( [ \"Random\" ], \"constant\" ) ++ \" el)\"\n\n                                replacementAsString : String\n                                replacementAsString =\n                                    qualifiedToString ( [ \"Random\" ], \"constant\" ) ++ \" (\" ++ qualifiedToString ( [ \"List\" ], \"repeat\" ) ++ \" n el)\"\n                            in\n                            Just\n                                (Rule.errorWithFix\n                                    { message = currentAsString ++ \" can be replaced by \" ++ replacementAsString\n                                    , details = [ currentAsString ++ \" generates the same value for each of the n elements. This means you can replace the call with \" ++ replacementAsString ++ \".\" ]\n                                    }\n                                    checkInfo.fnRange\n                                    (replaceBySubExpressionFix constantCall.nodeRange constantCall.firstArg\n                                        ++ [ Fix.replaceRangeBy checkInfo.fnRange\n                                                (qualifiedToString (qualify ( [ \"List\" ], \"repeat\" ) checkInfo))\n                                           , Fix.insertAt checkInfo.parentRange.start\n                                                (qualifiedToString (qualify ( [ \"Random\" ], \"constant\" ) checkInfo)\n                                                    ++ \" (\"\n                                                )\n                                           , Fix.insertAt checkInfo.parentRange.end \")\"\n                                           ]\n                                    )\n                                )\n\n                        Nothing ->\n                            Nothing\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\nrandomMapChecks : CheckInfo -> Maybe (Error {})\nrandomMapChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> mapIdentityChecks randomGeneratorWrapper checkInfo\n        , \\() -> mapWrapChecks randomGeneratorWrapper checkInfo\n        , \\() -> nonEmptiableWrapperMapAlwaysChecks randomGeneratorWrapper checkInfo\n        ]\n        ()\n\n\nrandomMapCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nrandomMapCompositionChecks checkInfo =\n    wrapperMapCompositionChecks randomGeneratorWrapper checkInfo\n\n\nrandomAndThenChecks : CheckInfo -> Maybe (Error {})\nrandomAndThenChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> wrapperAndThenChecks randomGeneratorWrapper checkInfo\n        , \\() -> nonEmptiableWrapperAndThenAlwaysChecks randomGeneratorWrapper checkInfo\n        ]\n        ()\n\n\nnonEmptiableWrapperAndThenAlwaysChecks :\n    NonEmptiableProperties (WrapperProperties otherProperties)\n    -> CheckInfo\n    -> Maybe (Error {})\nnonEmptiableWrapperAndThenAlwaysChecks wrapper checkInfo =\n    case AstHelpers.getAlwaysResult checkInfo.lookupTable checkInfo.firstArg of\n        Just alwaysResult ->\n            Just\n                (let\n                    replacementAndFix : { replacementDescription : String, fix : List Fix }\n                    replacementAndFix =\n                        case secondArg checkInfo of\n                            Nothing ->\n                                { replacementDescription = \"always with the \" ++ wrapper.represents ++ \" produced by the function\"\n                                , fix = keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.firstArg }\n                                }\n\n                            Just _ ->\n                                { replacementDescription = \"the \" ++ wrapper.represents ++ \" produced by the function\"\n                                , fix = replaceBySubExpressionFix checkInfo.parentRange alwaysResult\n                                }\n                 in\n                 Rule.errorWithFix\n                    { message = qualifiedToString checkInfo.fn ++ \" with a function that always returns to the same \" ++ wrapper.represents ++ \" will result in that \" ++ wrapper.represents\n                    , details = [ \"You can replace this call by \" ++ replacementAndFix.replacementDescription ++ \".\" ]\n                    }\n                    checkInfo.fnRange\n                    replacementAndFix.fix\n                )\n\n        Nothing ->\n            Nothing\n\n\n\n--\n\n\ntype alias TypeProperties properties =\n    { properties\n        | moduleName : ModuleName\n        , represents : String\n    }\n\n\n{-| Properties of a type that can hold some data or none.\n-}\ntype alias EmptiableProperties otherProperties =\n    TypeProperties\n        { otherProperties\n            | empty : ConstantProperties\n        }\n\n\ntype alias ConstantProperties =\n    { asString : QualifyResources {} -> String\n    , description : Description\n    , is : ModuleNameLookupTable -> Node Expression -> Bool\n    }\n\n\n{-| `TypeProperties` of a structure that will always have data inside, for example a non-empty list, a `Test`, a `Benchmark` or a tree (but not a forest).\n\nThis can be really valuable, for example when you want to know whether the function of a map or andThen will always be called.\n\nThe way this type is defined,\nit is impossible to have one type that has both `EmptiableProperties` and `NonEmptiableProperties`\n\n-}\ntype alias NonEmptiableProperties otherProperties =\n    TypeProperties\n        { otherProperties\n            | empty : { invalid : () }\n        }\n\n\n{-| Properties of a type that has a construction function that takes one value.\n\nExample \"wrap\" construction functions: `Just`, `Err`, `List.singleton` and `[ a ]`\nNote that for example `Cmd.batch [ a ]` is not a \"wrap\" because it keeps the type of the inner value `a`\n\n-}\ntype alias WrapperProperties otherProperties =\n    TypeProperties\n        { otherProperties\n            | wrap : ConstructWithOneArgProperties\n        }\n\n\ntype alias FromListProperties otherProperties =\n    TypeProperties\n        { otherProperties\n            | fromListLiteralRange : ModuleNameLookupTable -> Node Expression -> Maybe Range\n            , fromListLiteralDescription : String\n            , literalUnionLeftElementsStayOnTheLeft : Bool\n        }\n\n\ntype alias IndexableProperties otherProperties =\n    TypeProperties\n        { otherProperties\n            | literalElements : ModuleNameLookupTable -> Node Expression -> Maybe (List (Node Expression))\n        }\n\n\ntype alias ConstructWithOneArgProperties =\n    { description : Description\n    , fnName : String\n    , getValue : ModuleNameLookupTable -> Node Expression -> Maybe (Node Expression)\n    }\n\n\n{-| Properties of a type with with multiple elements. Includes `EmptiableProperties`.\n-}\ntype alias CollectionProperties otherProperties =\n    EmptiableProperties\n        { otherProperties\n            | nameForSize : String\n            , determineSize : Infer.Resources {} -> Node Expression -> Maybe CollectionSize\n        }\n\n\ngetEmpty :\n    ModuleNameLookupTable\n    -> { otherProperties | empty : { empty | is : ModuleNameLookupTable -> Node Expression -> Bool } }\n    -> Node Expression\n    -> Maybe { range : Range }\ngetEmpty lookupTable emptiable expressionNode =\n    if emptiable.empty.is lookupTable expressionNode then\n        Just { range = Node.range expressionNode }\n\n    else\n        Nothing\n\n\ngetEmptyExpressionNode :\n    ModuleNameLookupTable\n    -> { otherProperties | empty : { empty | is : ModuleNameLookupTable -> Node Expression -> Bool } }\n    -> Node Expression\n    -> Maybe (Node Expression)\ngetEmptyExpressionNode lookupTable emptiable expressionNode =\n    if emptiable.empty.is lookupTable expressionNode then\n        Just expressionNode\n\n    else\n        Nothing\n\n\n{-| Description of a set of values.\n\n  - Only one value is possible, like Cmd.none or [] \u2192 Constant\n  - Multiple values are possible, like `Ok anyValue` or `[ onlyElementAnyValue ]`? \u2192 `A`/`An` depending on the indefinite article in front of the description\n\n-}\ntype Description\n    = A String\n    | An String\n    | Constant String\n\n\ndescriptionForIndefinite : Description -> String\ndescriptionForIndefinite incomingArgDescription =\n    case incomingArgDescription of\n        A description ->\n            \"a \" ++ description\n\n        An description ->\n            \"an \" ++ description\n\n        Constant description ->\n            description\n\n\ndescriptionForDefinite : String -> Description -> String\ndescriptionForDefinite startWithDefiniteArticle referenceArgDescription =\n    case referenceArgDescription of\n        A description ->\n            startWithDefiniteArticle ++ \" \" ++ description\n\n        An description ->\n            startWithDefiniteArticle ++ \" \" ++ description\n\n        Constant description ->\n            description\n\n\ndescriptionWithoutArticle : Description -> String\ndescriptionWithoutArticle referenceArgDescription =\n    case referenceArgDescription of\n        A description ->\n            description\n\n        An description ->\n            description\n\n        Constant description ->\n            description\n\n\nextractQualifyResources : QualifyResources a -> QualifyResources {}\nextractQualifyResources resources =\n    { importLookup = resources.importLookup\n    , moduleBindings = resources.moduleBindings\n    , localBindings = resources.localBindings\n    }\n\n\nextractInferResources : Infer.Resources a -> Infer.Resources {}\nextractInferResources resources =\n    { lookupTable = resources.lookupTable\n    , inferredConstants = resources.inferredConstants\n    }\n\n\nemptyAsString : QualifyResources a -> { emptiable | empty : { empty | asString : QualifyResources {} -> String } } -> String\nemptyAsString qualifyResources emptiable =\n    emptiable.empty.asString (extractQualifyResources qualifyResources)\n\n\nrandomGeneratorWrapper : NonEmptiableProperties (WrapperProperties { mapFnName : String })\nrandomGeneratorWrapper =\n    { moduleName = [ \"Random\" ]\n    , represents = \"random generator\"\n    , wrap =\n        { description = A \"constant generator\"\n        , fnName = \"constant\"\n        , getValue =\n            \\lookupTable expr ->\n                Maybe.map .firstArg (AstHelpers.getSpecificFunctionCall ( [ \"Random\" ], \"constant\" ) lookupTable expr)\n        }\n    , empty = { invalid = () }\n    , mapFnName = \"map\"\n    }\n\n\nmaybeWithJustAsWrap :\n    EmptiableProperties\n        (WrapperProperties { mapFnName : String })\nmaybeWithJustAsWrap =\n    { moduleName = [ \"Maybe\" ]\n    , represents = \"maybe\"\n    , empty =\n        { description = Constant \"Nothing\"\n        , is =\n            \\lookupTable expr ->\n                isJust (AstHelpers.getSpecificValueOrFunction ( [ \"Maybe\" ], \"Nothing\" ) lookupTable expr)\n        , asString =\n            \\resources ->\n                qualifiedToString (qualify ( [ \"Maybe\" ], \"Nothing\" ) resources)\n        }\n    , wrap =\n        { description = A \"just maybe\"\n        , fnName = \"Just\"\n        , getValue =\n            \\lookupTable expr ->\n                Maybe.map .firstArg (AstHelpers.getSpecificFunctionCall ( [ \"Maybe\" ], \"Just\" ) lookupTable expr)\n        }\n    , mapFnName = \"map\"\n    }\n\n\nresultWithOkAsWrap :\n    WrapperProperties\n        { empty :\n            { description : Description\n            , is : ModuleNameLookupTable -> Node Expression -> Bool\n            }\n        , mapFnName : String\n        }\nresultWithOkAsWrap =\n    { moduleName = [ \"Result\" ]\n    , represents = \"result\"\n    , wrap =\n        { description = An \"okay result\"\n        , fnName = \"Ok\"\n        , getValue =\n            \\lookupTable expr ->\n                Maybe.map .firstArg (AstHelpers.getSpecificFunctionCall ( [ \"Result\" ], \"Ok\" ) lookupTable expr)\n        }\n    , empty =\n        { description = An \"error\"\n        , is =\n            \\lookupTable expr ->\n                isJust (AstHelpers.getSpecificFunctionCall ( [ \"Result\" ], \"Err\" ) lookupTable expr)\n        }\n    , mapFnName = \"map\"\n    }\n\n\nresultWithErrAsWrap :\n    WrapperProperties\n        { empty :\n            { description : Description\n            , is : ModuleNameLookupTable -> Node Expression -> Bool\n            }\n        }\nresultWithErrAsWrap =\n    { moduleName = [ \"Result\" ]\n    , represents = \"result\"\n    , wrap =\n        { description = An \"error\"\n        , fnName = \"Err\"\n        , getValue =\n            \\lookupTable expr ->\n                Maybe.map .firstArg (AstHelpers.getSpecificFunctionCall ( [ \"Result\" ], \"Err\" ) lookupTable expr)\n        }\n    , empty =\n        { description = An \"okay result\"\n        , is =\n            \\lookupTable expr ->\n                isJust (AstHelpers.getSpecificFunctionCall ( [ \"Result\" ], \"Ok\" ) lookupTable expr)\n        }\n    }\n\n\ntaskWithSucceedAsWrap :\n    WrapperProperties\n        { empty :\n            { description : Description\n            , is : ModuleNameLookupTable -> Node Expression -> Bool\n            }\n        , mapFnName : String\n        }\ntaskWithSucceedAsWrap =\n    { moduleName = [ \"Task\" ]\n    , represents = \"task\"\n    , wrap =\n        { description = A \"succeeding task\"\n        , fnName = \"succeed\"\n        , getValue =\n            \\lookupTable expr ->\n                Maybe.map .firstArg (AstHelpers.getSpecificFunctionCall ( [ \"Task\" ], \"succeed\" ) lookupTable expr)\n        }\n    , empty =\n        { description = A \"failing task\"\n        , is =\n            \\lookupTable expr ->\n                isJust (AstHelpers.getSpecificFunctionCall ( [ \"Task\" ], \"fail\" ) lookupTable expr)\n        }\n    , mapFnName = \"map\"\n    }\n\n\ntaskWithFailAsWrap :\n    WrapperProperties\n        { empty :\n            { description : Description\n            , is : ModuleNameLookupTable -> Node Expression -> Bool\n            }\n        , mapFnName : String\n        }\ntaskWithFailAsWrap =\n    { moduleName = [ \"Task\" ]\n    , represents = \"task\"\n    , wrap =\n        { description = A \"failing task\"\n        , fnName = \"fail\"\n        , getValue =\n            \\lookupTable expr ->\n                Maybe.map .firstArg (AstHelpers.getSpecificFunctionCall ( [ \"Task\" ], \"fail\" ) lookupTable expr)\n        }\n    , empty =\n        { description = A \"succeeding task\"\n        , is =\n            \\lookupTable expr ->\n                isJust (AstHelpers.getSpecificFunctionCall ( [ \"Task\" ], \"succeed\" ) lookupTable expr)\n        }\n    , mapFnName = \"mapError\"\n    }\n\n\nlistCollection : CollectionProperties (WrapperProperties (FromListProperties { mapFnName : String }))\nlistCollection =\n    { moduleName = [ \"List\" ]\n    , represents = \"list\"\n    , empty =\n        { description = Constant \"[]\"\n        , is = \\_ expr -> AstHelpers.getListLiteral expr == Just []\n        , asString = \\_ -> \"[]\"\n        }\n    , nameForSize = \"length\"\n    , determineSize = listDetermineLength\n    , wrap =\n        { description = A \"singleton list\"\n        , fnName = \"singleton\"\n        , getValue =\n            \\lookupTable expr ->\n                Maybe.map .element (AstHelpers.getListSingleton lookupTable expr)\n        }\n    , mapFnName = \"map\"\n    , fromListLiteralRange = \\_ expr -> AstHelpers.getListLiteralRange expr\n    , fromListLiteralDescription = \"list literal\"\n    , literalUnionLeftElementsStayOnTheLeft = True\n    }\n\n\nlistDetermineLength : Infer.Resources a -> Node Expression -> Maybe CollectionSize\nlistDetermineLength resources expressionNode =\n    case Node.value (AstHelpers.removeParens expressionNode) of\n        Expression.ListExpr list ->\n            Just (Exactly (List.length list))\n\n        Expression.OperatorApplication \"::\" _ _ right ->\n            case listDetermineLength resources right of\n                Just (Exactly n) ->\n                    Just (Exactly (n + 1))\n\n                _ ->\n                    Just NotEmpty\n\n        Expression.Application ((Node fnRange (Expression.FunctionOrValue _ \"singleton\")) :: _ :: []) ->\n            if ModuleNameLookupTable.moduleNameAt resources.lookupTable fnRange == Just [ \"List\" ] then\n                Just (Exactly 1)\n\n            else\n                Nothing\n\n        _ ->\n            Nothing\n\n\nstringCollection : CollectionProperties (WrapperProperties (FromListProperties {}))\nstringCollection =\n    { moduleName = [ \"String\" ]\n    , represents = \"string\"\n    , empty =\n        { description = Constant emptyStringAsString\n        , asString = \\_ -> emptyStringAsString\n        , is = \\_ (Node _ expr) -> expr == Expression.Literal \"\"\n        }\n    , nameForSize = \"length\"\n    , determineSize = \\_ (Node _ expr) -> stringDetermineLength expr\n    , wrap =\n        { description = A \"single-char string\"\n        , fnName = \"fromChar\"\n        , getValue =\n            \\lookupTable expr ->\n                Maybe.map .firstArg (AstHelpers.getSpecificFunctionCall ( [ \"String\" ], \"fromChar\" ) lookupTable expr)\n        }\n    , fromListLiteralRange =\n        \\lookupTable expr ->\n            AstHelpers.getSpecificFunctionCall ( [ \"String\" ], \"fromList\" ) lookupTable expr\n                |> Maybe.andThen (\\{ firstArg } -> AstHelpers.getListLiteralRange firstArg)\n    , fromListLiteralDescription = \"String.fromList call\"\n    , literalUnionLeftElementsStayOnTheLeft = True\n    }\n\n\nstringDetermineLength : Expression -> Maybe CollectionSize\nstringDetermineLength expression =\n    case expression of\n        Expression.Literal string ->\n            Just (Exactly (String.length string))\n\n        _ ->\n            Nothing\n\n\narrayCollection : CollectionProperties (FromListProperties (IndexableProperties {}))\narrayCollection =\n    { moduleName = [ \"Array\" ]\n    , represents = \"array\"\n    , empty =\n        { description = Constant (qualifiedToString ( [ \"Array\" ], \"empty\" ))\n        , is =\n            \\lookupTable expr ->\n                isJust (AstHelpers.getSpecificValueOrFunction ( [ \"Array\" ], \"empty\" ) lookupTable expr)\n        , asString =\n            \\resources ->\n                qualifiedToString (qualify ( [ \"Array\" ], \"empty\" ) resources)\n        }\n    , nameForSize = \"length\"\n    , determineSize = arrayDetermineSize\n    , literalElements =\n        \\lookupTable expr ->\n            AstHelpers.getSpecificFunctionCall ( [ \"Array\" ], \"fromList\" ) lookupTable expr\n                |> Maybe.andThen (\\{ firstArg } -> AstHelpers.getListLiteral firstArg)\n    , fromListLiteralRange =\n        \\lookupTable expr ->\n            AstHelpers.getSpecificFunctionCall ( [ \"Array\" ], \"fromList\" ) lookupTable expr\n                |> Maybe.andThen (\\call -> AstHelpers.getListLiteralRange call.firstArg)\n    , fromListLiteralDescription = \"Array.fromList call\"\n    , literalUnionLeftElementsStayOnTheLeft = True\n    }\n\n\narrayDetermineSize :\n    Infer.Resources a\n    -> Node Expression\n    -> Maybe CollectionSize\narrayDetermineSize resources expressionNode =\n    firstThatConstructsJust\n        [ \\() ->\n            case AstHelpers.getSpecificValueOrFunction ( [ \"Array\" ], \"empty\" ) resources.lookupTable expressionNode of\n                Just _ ->\n                    Just (Exactly 0)\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getSpecificFunctionCall ( [ \"Array\" ], \"fromList\" ) resources.lookupTable expressionNode of\n                Just fromListCall ->\n                    listDetermineLength resources fromListCall.firstArg\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getSpecificFunctionCall ( [ \"Array\" ], \"repeat\" ) resources.lookupTable expressionNode of\n                Just repeatCall ->\n                    Evaluate.getInt resources repeatCall.firstArg\n                        |> Maybe.map (\\n -> Exactly (max 0 n))\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getSpecificFunctionCall ( [ \"Array\" ], \"initialize\" ) resources.lookupTable expressionNode of\n                Just repeatCall ->\n                    Evaluate.getInt resources repeatCall.firstArg\n                        |> Maybe.map (\\n -> Exactly (max 0 n))\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\nsetCollection : CollectionProperties (WrapperProperties (FromListProperties {}))\nsetCollection =\n    { moduleName = [ \"Set\" ]\n    , represents = \"set\"\n    , empty =\n        { description = Constant (qualifiedToString ( [ \"Set\" ], \"empty\" ))\n        , is =\n            \\lookupTable expr ->\n                isJust (AstHelpers.getSpecificValueOrFunction ( [ \"Set\" ], \"empty\" ) lookupTable expr)\n        , asString =\n            \\resources ->\n                qualifiedToString (qualify ( [ \"Set\" ], \"empty\" ) resources)\n        }\n    , nameForSize = \"size\"\n    , determineSize = setDetermineSize\n    , wrap =\n        { description = A \"singleton set\"\n        , fnName = \"singleton\"\n        , getValue =\n            \\lookupTable expr ->\n                Maybe.map .firstArg (AstHelpers.getSpecificFunctionCall ( [ \"Set\" ], \"singleton\" ) lookupTable expr)\n        }\n    , fromListLiteralRange =\n        \\lookupTable expr ->\n            AstHelpers.getSpecificFunctionCall ( [ \"Set\" ], \"fromList\" ) lookupTable expr\n                |> Maybe.andThen (\\{ firstArg } -> AstHelpers.getListLiteralRange firstArg)\n    , fromListLiteralDescription = \"Set.fromList call\"\n    , literalUnionLeftElementsStayOnTheLeft = True\n    }\n\n\nsetDetermineSize :\n    Infer.Resources a\n    -> Node Expression\n    -> Maybe CollectionSize\nsetDetermineSize resources expressionNode =\n    firstThatConstructsJust\n        [ \\() ->\n            case AstHelpers.getSpecificValueOrFunction ( [ \"Set\" ], \"empty\" ) resources.lookupTable expressionNode of\n                Just _ ->\n                    Just (Exactly 0)\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getSpecificFunctionCall ( [ \"Set\" ], \"singleton\" ) resources.lookupTable expressionNode of\n                Just _ ->\n                    Just (Exactly 1)\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getSpecificFunctionCall ( [ \"Set\" ], \"fromList\" ) resources.lookupTable expressionNode of\n                Just fromListCall ->\n                    case AstHelpers.getListLiteral fromListCall.firstArg of\n                        Just [] ->\n                            Just (Exactly 0)\n\n                        Just (_ :: []) ->\n                            Just (Exactly 1)\n\n                        Just (el0 :: el1 :: el2Up) ->\n                            case traverse getComparableExpression (el0 :: el1 :: el2Up) of\n                                Nothing ->\n                                    Just NotEmpty\n\n                                Just comparableExpressions ->\n                                    comparableExpressions |> unique |> List.length |> Exactly |> Just\n\n                        Nothing ->\n                            Nothing\n\n                _ ->\n                    Nothing\n        ]\n        ()\n\n\ndictCollection : CollectionProperties (FromListProperties {})\ndictCollection =\n    { moduleName = [ \"Dict\" ]\n    , represents = \"dict\"\n    , empty =\n        { description = Constant (qualifiedToString ( [ \"Dict\" ], \"empty\" ))\n        , is =\n            \\lookupTable expr ->\n                isJust (AstHelpers.getSpecificValueOrFunction ( [ \"Dict\" ], \"empty\" ) lookupTable expr)\n        , asString =\n            \\resources ->\n                qualifiedToString (qualify ( [ \"Dict\" ], \"empty\" ) resources)\n        }\n    , nameForSize = \"size\"\n    , determineSize = dictDetermineSize\n    , fromListLiteralRange =\n        \\lookupTable expr ->\n            AstHelpers.getSpecificFunctionCall ( [ \"Dict\" ], \"fromList\" ) lookupTable expr\n                |> Maybe.andThen (\\{ firstArg } -> AstHelpers.getListLiteralRange firstArg)\n    , fromListLiteralDescription = \"Dict.fromList call\"\n    , literalUnionLeftElementsStayOnTheLeft = False\n    }\n\n\ndictDetermineSize :\n    Infer.Resources a\n    -> Node Expression\n    -> Maybe CollectionSize\ndictDetermineSize resources expressionNode =\n    findMap (\\f -> f ())\n        [ \\() ->\n            case AstHelpers.getSpecificValueOrFunction ( [ \"Dict\" ], \"empty\" ) resources.lookupTable expressionNode of\n                Just _ ->\n                    Just (Exactly 0)\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getSpecificFunctionCall ( [ \"Dict\" ], \"singleton\" ) resources.lookupTable expressionNode of\n                Just singletonCall ->\n                    case singletonCall.argsAfterFirst of\n                        _ :: [] ->\n                            Just (Exactly 1)\n\n                        _ ->\n                            Nothing\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getSpecificFunctionCall ( [ \"Dict\" ], \"fromList\" ) resources.lookupTable expressionNode of\n                Just fromListCall ->\n                    case AstHelpers.getListLiteral fromListCall.firstArg of\n                        Just [] ->\n                            Just (Exactly 0)\n\n                        Just (_ :: []) ->\n                            Just (Exactly 1)\n\n                        Just (el0 :: el1 :: el2Up) ->\n                            case traverse getComparableExpressionInTupleFirst (el0 :: el1 :: el2Up) of\n                                Nothing ->\n                                    Just NotEmpty\n\n                                Just comparableExpressions ->\n                                    comparableExpressions |> unique |> List.length |> Exactly |> Just\n\n                        Nothing ->\n                            Nothing\n\n                _ ->\n                    Nothing\n        ]\n\n\ncmdCollection : EmptiableProperties {}\ncmdCollection =\n    { moduleName = [ \"Platform\", \"Cmd\" ]\n    , represents = \"command\"\n    , empty =\n        { description =\n            Constant \"Cmd.none\"\n        , is =\n            \\lookupTable expr ->\n                isJust (AstHelpers.getSpecificValueOrFunction ( [ \"Platform\", \"Cmd\" ], \"none\" ) lookupTable expr)\n        , asString =\n            \\resources ->\n                qualifiedToString (qualify ( [ \"Platform\", \"Cmd\" ], \"none\" ) resources)\n        }\n    }\n\n\nsubCollection : EmptiableProperties {}\nsubCollection =\n    { moduleName = [ \"Platform\", \"Sub\" ]\n    , represents = \"subscription\"\n    , empty =\n        { description =\n            Constant \"Sub.none\"\n        , is =\n            \\lookupTable expr ->\n                isJust (AstHelpers.getSpecificValueOrFunction ( [ \"Platform\", \"Sub\" ], \"none\" ) lookupTable expr)\n        , asString =\n            \\resources ->\n                qualifiedToString (qualify ( [ \"Platform\", \"Sub\" ], \"none\" ) resources)\n        }\n    }\n\n\nemptiableMapChecks :\n    TypeProperties\n        { otherProperties\n            | empty :\n                { empty\n                    | description : Description\n                    , is : ModuleNameLookupTable -> Node Expression -> Bool\n                }\n        }\n    -> CheckInfo\n    -> Maybe (Error {})\nemptiableMapChecks emptiable checkInfo =\n    firstThatConstructsJust\n        [ \\() -> mapIdentityChecks emptiable checkInfo\n        , \\() ->\n            Maybe.andThen\n                (\\emptiableArg -> callOnEmptyReturnsEmptyCheck emptiableArg emptiable checkInfo)\n                (secondArg checkInfo)\n        ]\n        ()\n\n\nmapIdentityChecks :\n    TypeProperties properties\n    -> CheckInfo\n    -> Maybe (Error {})\nmapIdentityChecks mappable checkInfo =\n    if AstHelpers.isIdentity checkInfo.lookupTable checkInfo.firstArg then\n        Just\n            (alwaysReturnsLastArgError\n                (qualifiedToString checkInfo.fn ++ \" with an identity function\")\n                mappable\n                checkInfo\n            )\n\n    else\n        Nothing\n\n\nwrapperMapCompositionChecks : WrapperProperties otherProperties -> CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nwrapperMapCompositionChecks wrapper checkInfo =\n    firstThatConstructsJust\n        [ \\() -> wrapToMapCompositionChecks wrapper checkInfo\n        , \\() -> mapAlwaysCompositionChecks wrapper checkInfo\n        ]\n        ()\n\n\nmapWrapChecks :\n    WrapperProperties otherProperties\n    -> CheckInfo\n    -> Maybe (Error {})\nmapWrapChecks wrapper checkInfo =\n    case secondArg checkInfo of\n        Just wrapperArg ->\n            case sameInAllBranches (getValueWithNodeRange (wrapper.wrap.getValue checkInfo.lookupTable)) wrapperArg of\n                Determined wraps ->\n                    let\n                        mappingArgRange : Range\n                        mappingArgRange =\n                            Node.range checkInfo.firstArg\n\n                        removeWrapCalls : List Fix\n                        removeWrapCalls =\n                            List.concatMap\n                                (\\wrap ->\n                                    keepOnlyFix\n                                        { parentRange = wrap.nodeRange\n                                        , keep = Node.range wrap.value\n                                        }\n                                )\n                                wraps\n                    in\n                    Just\n                        (Rule.errorWithFix\n                            (mapWrapErrorInfo checkInfo.fn wrapper)\n                            checkInfo.fnRange\n                            (case checkInfo.callStyle of\n                                Pipe LeftToRight ->\n                                    [ Fix.removeRange { start = checkInfo.fnRange.start, end = mappingArgRange.start }\n                                    , Fix.insertAt mappingArgRange.end\n                                        (\" |> \" ++ qualifiedToString (qualify ( wrapper.moduleName, wrapper.wrap.fnName ) checkInfo))\n                                    ]\n                                        ++ removeWrapCalls\n\n                                Pipe RightToLeft ->\n                                    Fix.replaceRangeBy\n                                        { start = checkInfo.parentRange.start, end = mappingArgRange.start }\n                                        (qualifiedToString (qualify ( wrapper.moduleName, wrapper.wrap.fnName ) checkInfo) ++ \" <| \")\n                                        :: removeWrapCalls\n\n                                Application ->\n                                    [ Fix.replaceRangeBy\n                                        { start = checkInfo.parentRange.start, end = mappingArgRange.start }\n                                        (qualifiedToString (qualify ( wrapper.moduleName, wrapper.wrap.fnName ) checkInfo) ++ \" (\")\n                                    , Fix.insertAt checkInfo.parentRange.end \")\"\n                                    ]\n                                        ++ removeWrapCalls\n                            )\n                        )\n\n                Undetermined ->\n                    Nothing\n\n        Nothing ->\n            Nothing\n\n\nwrapToMapCompositionChecks :\n    WrapperProperties otherProperties\n    -> CompositionIntoCheckInfo\n    -> Maybe ErrorInfoAndFix\nwrapToMapCompositionChecks wrapper checkInfo =\n    case\n        ( checkInfo.earlier.fn == ( wrapper.moduleName, wrapper.wrap.fnName )\n        , checkInfo.later.args\n        )\n    of\n        ( True, (Node mapperFunctionRange _) :: _ ) ->\n            let\n                fixes : List Fix\n                fixes =\n                    case checkInfo.direction of\n                        LeftToRight ->\n                            [ Fix.removeRange\n                                { start = checkInfo.parentRange.start, end = mapperFunctionRange.start }\n                            , Fix.insertAt mapperFunctionRange.end\n                                (\" >> \" ++ qualifiedToString (qualify ( wrapper.moduleName, wrapper.wrap.fnName ) checkInfo))\n                            ]\n\n                        RightToLeft ->\n                            [ Fix.replaceRangeBy\n                                { start = checkInfo.parentRange.start, end = mapperFunctionRange.start }\n                                (qualifiedToString (qualify ( wrapper.moduleName, wrapper.wrap.fnName ) checkInfo) ++ \" << \")\n                            , Fix.removeRange { start = mapperFunctionRange.end, end = checkInfo.parentRange.end }\n                            ]\n            in\n            Just\n                { info = mapWrapErrorInfo checkInfo.later.fn wrapper\n                , fix = fixes\n                }\n\n        _ ->\n            Nothing\n\n\nnonEmptiableWrapperMapAlwaysChecks :\n    NonEmptiableProperties (WrapperProperties otherProperties)\n    -> CheckInfo\n    -> Maybe (Error {})\nnonEmptiableWrapperMapAlwaysChecks wrapper checkInfo =\n    case AstHelpers.getAlwaysResult checkInfo.lookupTable checkInfo.firstArg of\n        Just (Node alwaysMapResultRange alwaysMapResult) ->\n            let\n                ( leftParenIfRequired, rightParenIfRequired ) =\n                    if needsParens alwaysMapResult then\n                        ( \"(\", \")\" )\n\n                    else\n                        ( \"\", \"\" )\n            in\n            Just\n                (case secondArg checkInfo of\n                    Nothing ->\n                        Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" with a function that always maps to the same value will always result in \" ++ qualifiedToString ( wrapper.moduleName, wrapper.wrap.fnName ) ++ \" with that value\"\n                            , details = [ \"You can replace this call by \" ++ qualifiedToString ( wrapper.moduleName, wrapper.wrap.fnName ) ++ \" with the value produced by the mapper function.\" ]\n                            }\n                            checkInfo.fnRange\n                            [ Fix.replaceRangeBy\n                                { start = checkInfo.parentRange.start, end = alwaysMapResultRange.start }\n                                (qualifiedToString (qualify ( [ \"Basics\" ], \"always\" ) checkInfo)\n                                    ++ \" (\"\n                                    ++ qualifiedToString (qualify ( wrapper.moduleName, wrapper.wrap.fnName ) checkInfo)\n                                    ++ \" \"\n                                    ++ leftParenIfRequired\n                                )\n                            , Fix.replaceRangeBy\n                                { start = alwaysMapResultRange.end, end = checkInfo.parentRange.end }\n                                (rightParenIfRequired ++ \")\")\n                            ]\n\n                    Just _ ->\n                        Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" with a function that always maps to the same value will result in \" ++ qualifiedToString ( wrapper.moduleName, wrapper.wrap.fnName ) ++ \" with that value\"\n                            , details = [ \"You can replace this call by \" ++ qualifiedToString ( wrapper.moduleName, wrapper.wrap.fnName ) ++ \" with the value produced by the mapper function.\" ]\n                            }\n                            checkInfo.fnRange\n                            [ Fix.replaceRangeBy\n                                { start = checkInfo.parentRange.start, end = alwaysMapResultRange.start }\n                                (qualifiedToString (qualify ( wrapper.moduleName, wrapper.wrap.fnName ) checkInfo)\n                                    ++ \" \"\n                                    ++ leftParenIfRequired\n                                )\n                            , Fix.replaceRangeBy\n                                { start = alwaysMapResultRange.end, end = checkInfo.parentRange.end }\n                                rightParenIfRequired\n                            ]\n                )\n\n        Nothing ->\n            Nothing\n\n\nmapAlwaysCompositionChecks :\n    WrapperProperties otherProperties\n    -> CompositionIntoCheckInfo\n    -> Maybe ErrorInfoAndFix\nmapAlwaysCompositionChecks wrapper checkInfo =\n    case ( checkInfo.earlier.fn, checkInfo.earlier.args ) of\n        ( ( [ \"Basics\" ], \"always\" ), [] ) ->\n            Just\n                { info =\n                    { message = qualifiedToString checkInfo.later.fn ++ \" with a function that always maps to the same value is equivalent to \" ++ qualifiedToString ( wrapper.moduleName, wrapper.wrap.fnName )\n                    , details = [ \"You can replace this call by \" ++ qualifiedToString ( wrapper.moduleName, wrapper.wrap.fnName ) ++ \".\" ]\n                    }\n                , fix =\n                    [ Fix.replaceRangeBy checkInfo.parentRange\n                        (qualifiedToString (qualify ( wrapper.moduleName, wrapper.wrap.fnName ) checkInfo))\n                    ]\n                }\n\n        _ ->\n            Nothing\n\n\nemptiableAndThenChecks :\n    { otherProperties\n        | empty : ConstantProperties\n    }\n    -> CheckInfo\n    -> Maybe (Error {})\nemptiableAndThenChecks emptiable checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\emptiableArg -> callOnEmptyReturnsEmptyCheck emptiableArg emptiable checkInfo)\n                (secondArg checkInfo)\n        , \\() ->\n            case constructs (sameInAllBranches (getEmpty checkInfo.lookupTable emptiable)) checkInfo.lookupTable checkInfo.firstArg of\n                Determined _ ->\n                    Just\n                        (alwaysResultsInUnparenthesizedConstantError\n                            (qualifiedToString checkInfo.fn ++ \" with a function that will always return \" ++ emptiable.empty.asString defaultQualifyResources)\n                            { replacement = emptiable.empty.asString\n                            , lastArg = secondArg checkInfo\n                            }\n                            checkInfo\n                        )\n\n                Undetermined ->\n                    Nothing\n        ]\n        ()\n\n\ngetValueWithNodeRange :\n    (Node Expression -> Maybe (Node Expression))\n    -> Node Expression\n    -> Maybe { value : Node Expression, nodeRange : Range }\ngetValueWithNodeRange getValue expressionNode =\n    Maybe.map (\\value -> { value = value, nodeRange = Node.range expressionNode })\n        (getValue expressionNode)\n\n\nwrapperAndThenChecks :\n    WrapperProperties { otherProperties | mapFnName : String }\n    -> CheckInfo\n    -> Maybe (Error {})\nwrapperAndThenChecks wrapper checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            case secondArg checkInfo of\n                Just maybeArg ->\n                    case sameInAllBranches (getValueWithNodeRange (wrapper.wrap.getValue checkInfo.lookupTable)) maybeArg of\n                        Determined wrapCalls ->\n                            Just\n                                (Rule.errorWithFix\n                                    { message = qualifiedToString checkInfo.fn ++ \" on \" ++ descriptionForIndefinite wrapper.wrap.description ++ \" is the same as applying the function to the value from \" ++ descriptionForDefinite \"the\" wrapper.wrap.description\n                                    , details = [ \"You can replace this call by the function directly applied to the value inside \" ++ descriptionForDefinite \"the\" wrapper.wrap.description ++ \".\" ]\n                                    }\n                                    checkInfo.fnRange\n                                    (Fix.removeRange { start = checkInfo.fnRange.start, end = (Node.range checkInfo.firstArg).start }\n                                        :: List.concatMap (\\justCall -> replaceBySubExpressionFix justCall.nodeRange justCall.value) wrapCalls\n                                    )\n                                )\n\n                        Undetermined ->\n                            Nothing\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case AstHelpers.getSpecificValueOrFunction ( wrapper.moduleName, wrapper.wrap.fnName ) checkInfo.lookupTable checkInfo.firstArg of\n                Just _ ->\n                    Just\n                        (alwaysReturnsLastArgError\n                            (qualifiedToString checkInfo.fn ++ \" with a function equivalent to \" ++ qualifiedToString (qualify ( wrapper.moduleName, wrapper.wrap.fnName ) defaultQualifyResources))\n                            wrapper\n                            checkInfo\n                        )\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case\n                constructs\n                    (sameInAllBranches (\\expr -> getValueWithNodeRange (wrapper.wrap.getValue checkInfo.lookupTable) expr))\n                    checkInfo.lookupTable\n                    checkInfo.firstArg\n            of\n                Determined wrapCalls ->\n                    let\n                        mapFn : ( ModuleName, String )\n                        mapFn =\n                            ( wrapper.moduleName, wrapper.mapFnName )\n                    in\n                    Just\n                        (Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" with a function that always returns \" ++ descriptionForIndefinite wrapper.wrap.description ++ \" is the same as \" ++ qualifiedToString mapFn ++ \" with the function returning the value inside\"\n                            , details = [ \"You can replace this call by \" ++ qualifiedToString mapFn ++ \" with the function returning the value inside \" ++ descriptionForDefinite \"the\" wrapper.wrap.description ++ \".\" ]\n                            }\n                            checkInfo.fnRange\n                            (Fix.replaceRangeBy checkInfo.fnRange\n                                (qualifiedToString (qualify mapFn checkInfo))\n                                :: List.concatMap (\\call -> replaceBySubExpressionFix call.nodeRange call.value) wrapCalls\n                            )\n                        )\n\n                Undetermined ->\n                    Nothing\n        ]\n        ()\n\n\nmaybeAndThenChecks : CheckInfo -> Maybe (Error {})\nmaybeAndThenChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> wrapperAndThenChecks maybeWithJustAsWrap checkInfo\n        , \\() -> emptiableAndThenChecks maybeWithJustAsWrap checkInfo\n        ]\n        ()\n\n\nresultAndThenChecks : CheckInfo -> Maybe (Error {})\nresultAndThenChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\resultArg ->\n                    callOnEmptyReturnsEmptyCheck resultArg resultWithOkAsWrap checkInfo\n                )\n                (secondArg checkInfo)\n        , \\() -> wrapperAndThenChecks resultWithOkAsWrap checkInfo\n        ]\n        ()\n\n\nwithDefaultChecks :\n    WrapperProperties\n        { otherProperties\n            | empty :\n                { empty\n                    | description : Description\n                    , is : ModuleNameLookupTable -> Node Expression -> Bool\n                }\n        }\n    -> CheckInfo\n    -> Maybe (Error {})\nwithDefaultChecks emptiable checkInfo =\n    firstThatConstructsJust\n        [ \\() -> emptiableWithDefaultChecks emptiable checkInfo\n        , \\() ->\n            Maybe.andThen\n                (\\subjectArg -> callOnWrapReturnsItsValue subjectArg emptiable checkInfo)\n                (secondArg checkInfo)\n        ]\n        ()\n\n\nemptiableWithDefaultChecks :\n    { otherProperties\n        | empty :\n            { empty\n                | description : Description\n                , is : ModuleNameLookupTable -> Node Expression -> Bool\n            }\n    }\n    -> CheckInfo\n    -> Maybe (Error {})\nemptiableWithDefaultChecks emptiable checkInfo =\n    case secondArg checkInfo of\n        Just emptiableArg ->\n            case sameInAllBranches (getEmpty checkInfo.lookupTable emptiable) emptiableArg of\n                Determined _ ->\n                    Just\n                        (Rule.errorWithFix\n                            { message = qualifiedToString checkInfo.fn ++ \" on \" ++ descriptionForIndefinite emptiable.empty.description ++ \" will result in the default value\"\n                            , details = [ \"You can replace this call by the default value.\" ]\n                            }\n                            checkInfo.fnRange\n                            (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.firstArg })\n                        )\n\n                Undetermined ->\n                    Nothing\n\n        Nothing ->\n            Nothing\n\n\nunwrapToMaybeChecks :\n    WrapperProperties\n        { otherProperties\n            | empty :\n                { empty\n                    | is : ModuleNameLookupTable -> Node Expression -> Bool\n                    , description : Description\n                }\n        }\n    -> CheckInfo\n    -> Maybe (Error {})\nunwrapToMaybeChecks emptiableWrapper checkInfo =\n    firstThatConstructsJust\n        [ \\() -> callOnWrapReturnsJustItsValue checkInfo.firstArg emptiableWrapper checkInfo\n        , \\() ->\n            callOnEmptyReturnsCheck\n                { on = checkInfo.firstArg, resultAsString = \\res -> qualifiedToString (qualify ( [ \"Maybe\" ], \"Nothing\" ) res) }\n                emptiableWrapper\n                checkInfo\n        ]\n        ()\n\n\nwrapToMaybeCompositionChecks : WrapperProperties otherProperties -> CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nwrapToMaybeCompositionChecks wrapper checkInfo =\n    if checkInfo.earlier.fn == ( wrapper.moduleName, wrapper.wrap.fnName ) then\n        Just\n            { info =\n                { message = qualifiedToString checkInfo.later.fn ++ \" on \" ++ descriptionForIndefinite wrapper.wrap.description ++ \" will result in Just the value inside\"\n                , details = [ \"You can replace this call by Just.\" ]\n                }\n            , fix =\n                [ Fix.replaceRangeBy checkInfo.parentRange\n                    (qualifiedToString (qualify ( [ \"Maybe\" ], \"Just\" ) checkInfo))\n                ]\n            }\n\n    else\n        Nothing\n\n\nresultToMaybeCompositionChecks : CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nresultToMaybeCompositionChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> wrapToMaybeCompositionChecks resultWithOkAsWrap checkInfo\n        , \\() ->\n            case checkInfo.earlier.fn of\n                ( [ \"Result\" ], \"Err\" ) ->\n                    Just\n                        { info =\n                            { message = qualifiedToString ( [ \"Result\" ], \"toMaybe\" ) ++ \" on an error will result in Nothing\"\n                            , details = [ \"You can replace this call by always Nothing.\" ]\n                            }\n                        , fix =\n                            [ Fix.replaceRangeBy checkInfo.parentRange\n                                (qualifiedToString (qualify ( [ \"Basics\" ], \"always\" ) checkInfo)\n                                    ++ \" \"\n                                    ++ qualifiedToString (qualify ( [ \"Maybe\" ], \"Nothing\" ) checkInfo)\n                                )\n                            ]\n                        }\n\n                _ ->\n                    Nothing\n        ]\n        ()\n\n\npipelineChecks :\n    { commentRanges : List Range\n    , extractSourceCode : Range -> String\n    , nodeRange : Range\n    , pipedInto : Node Expression\n    , arg : Node Expression\n    , direction : LeftOrRightDirection\n    }\n    -> Maybe (Error {})\npipelineChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() -> pipingIntoCompositionChecks { commentRanges = checkInfo.commentRanges, extractSourceCode = checkInfo.extractSourceCode } checkInfo.direction checkInfo.pipedInto\n        , \\() -> fullyAppliedLambdaInPipelineChecks { nodeRange = checkInfo.nodeRange, function = checkInfo.pipedInto, firstArgument = checkInfo.arg }\n        ]\n        ()\n\n\nfullyAppliedLambdaInPipelineChecks : { nodeRange : Range, firstArgument : Node Expression, function : Node Expression } -> Maybe (Error {})\nfullyAppliedLambdaInPipelineChecks checkInfo =\n    case Node.value checkInfo.function of\n        Expression.ParenthesizedExpression (Node lambdaRange (Expression.LambdaExpression lambda)) ->\n            case Node.value (AstHelpers.removeParens checkInfo.firstArgument) of\n                Expression.OperatorApplication \"|>\" _ _ _ ->\n                    Nothing\n\n                Expression.OperatorApplication \"<|\" _ _ _ ->\n                    Nothing\n\n                _ ->\n                    appliedLambdaError\n                        { nodeRange = checkInfo.nodeRange\n                        , lambdaRange = lambdaRange\n                        , lambda = lambda\n                        }\n\n        _ ->\n            Nothing\n\n\npipingIntoCompositionChecks :\n    { commentRanges : List Range, extractSourceCode : Range -> String }\n    -> LeftOrRightDirection\n    -> Node Expression\n    -> Maybe (Error {})\npipingIntoCompositionChecks context compositionDirection expressionNode =\n    let\n        ( opToFind, replacement ) =\n            case compositionDirection of\n                RightToLeft ->\n                    ( \"<<\", \"<|\" )\n\n                LeftToRight ->\n                    ( \">>\", \"|>\" )\n\n        pipingIntoCompositionChecksHelp : Node Expression -> Maybe { opToReplaceRange : Range, fixes : List Fix, firstStepIsComposition : Bool }\n        pipingIntoCompositionChecksHelp subExpression =\n            case Node.value subExpression of\n                Expression.ParenthesizedExpression inParens ->\n                    case pipingIntoCompositionChecksHelp inParens of\n                        Nothing ->\n                            Nothing\n\n                        Just error ->\n                            if error.firstStepIsComposition then\n                                -- parens can safely be removed\n                                Just\n                                    { error\n                                        | fixes =\n                                            removeBoundariesFix subExpression ++ error.fixes\n                                    }\n\n                            else\n                                -- inside parenthesis is checked separately because\n                                -- the parens here can't safely be removed\n                                Nothing\n\n                Expression.OperatorApplication symbol _ left right ->\n                    let\n                        continuedSearch : Maybe { opToReplaceRange : Range, fixes : List Fix, firstStepIsComposition : Bool }\n                        continuedSearch =\n                            case compositionDirection of\n                                RightToLeft ->\n                                    pipingIntoCompositionChecksHelp left\n\n                                LeftToRight ->\n                                    pipingIntoCompositionChecksHelp right\n                    in\n                    if symbol == replacement then\n                        Maybe.map (\\errors -> { errors | firstStepIsComposition = False })\n                            continuedSearch\n\n                    else if symbol == opToFind then\n                        let\n                            opToFindRange : Range\n                            opToFindRange =\n                                findOperatorRange\n                                    { operator = opToFind\n                                    , commentRanges = context.commentRanges\n                                    , extractSourceCode = context.extractSourceCode\n                                    , leftRange = Node.range left\n                                    , rightRange = Node.range right\n                                    }\n                        in\n                        Just\n                            { opToReplaceRange = opToFindRange\n                            , fixes =\n                                Fix.replaceRangeBy opToFindRange replacement\n                                    :: (case continuedSearch of\n                                            Nothing ->\n                                                []\n\n                                            Just additionalErrorsFound ->\n                                                additionalErrorsFound.fixes\n                                       )\n                            , firstStepIsComposition = True\n                            }\n\n                    else\n                        Nothing\n\n                _ ->\n                    Nothing\n    in\n    case pipingIntoCompositionChecksHelp expressionNode of\n        Nothing ->\n            Nothing\n\n        Just error ->\n            Just\n                (Rule.errorWithFix\n                    { message = \"Use \" ++ replacement ++ \" instead of \" ++ opToFind\n                    , details =\n                        [ \"Because of the precedence of operators, using \" ++ opToFind ++ \" at this location is the same as using \" ++ replacement ++ \".\"\n                        , \"Please use \" ++ replacement ++ \" instead as that is more idiomatic in Elm and generally easier to read.\"\n                        ]\n                    }\n                    error.opToReplaceRange\n                    error.fixes\n                )\n\n\ncompositionAfterWrapIsUnnecessaryCheck : WrapperProperties otherProperties -> CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\ncompositionAfterWrapIsUnnecessaryCheck wrapper checkInfo =\n    let\n        wrapFn : ( ModuleName, String )\n        wrapFn =\n            ( wrapper.moduleName, wrapper.wrap.fnName )\n    in\n    if checkInfo.earlier.fn == wrapFn then\n        Just\n            { info =\n                { message = qualifiedToString checkInfo.later.fn ++ \" on \" ++ descriptionForIndefinite wrapper.wrap.description ++ \" will result in the given \" ++ wrapper.represents\n                , details = [ \"You can replace this call by \" ++ qualifiedToString (qualify wrapFn defaultQualifyResources) ++ \".\" ]\n                }\n            , fix =\n                keepOnlyFix\n                    { parentRange = checkInfo.parentRange\n                    , keep = checkInfo.earlier.range\n                    }\n            }\n\n    else\n        Nothing\n\n\ncallOnSingletonListDoesNotChangeItCheck : Node Expression -> CheckInfo -> Maybe (Error {})\ncallOnSingletonListDoesNotChangeItCheck listArg checkInfo =\n    callOnWrappedDoesNotChangeItCheck listArg listCollection checkInfo\n\n\ncallOnWrappedDoesNotChangeItCheck : Node Expression -> WrapperProperties otherProperties -> CheckInfo -> Maybe (Error {})\ncallOnWrappedDoesNotChangeItCheck wrapperArg wrapper checkInfo =\n    callOnDoesNotChangeItCheck\n        { description = wrapper.wrap.description\n        , is = \\lookupTable expr -> isJust (wrapper.wrap.getValue lookupTable expr)\n        }\n        wrapperArg\n        checkInfo\n\n\ncallOnDoesNotChangeItCheck :\n    { a\n        | description : Description\n        , is : ModuleNameLookupTable -> Node Expression -> Bool\n    }\n    -> Node Expression\n    -> CheckInfo\n    -> Maybe (Error {})\ncallOnDoesNotChangeItCheck constructable constructableArg checkInfo =\n    let\n        getConstructable : Node Expression -> Maybe ()\n        getConstructable expressionNode =\n            if constructable.is checkInfo.lookupTable expressionNode then\n                Just ()\n\n            else\n                Nothing\n    in\n    case sameInAllBranches getConstructable constructableArg of\n        Determined _ ->\n            Just\n                (Rule.errorWithFix\n                    (operationDoesNotChangeSpecificLastArgErrorInfo { fn = checkInfo.fn, specific = constructable.description })\n                    checkInfo.fnRange\n                    (keepOnlyFix\n                        { parentRange = checkInfo.parentRange\n                        , keep = Node.range constructableArg\n                        }\n                    )\n                )\n\n        Undetermined ->\n            Nothing\n\n\ncallOnEmptyReturnsEmptyCheck :\n    Node Expression\n    ->\n        { a\n            | empty :\n                { empty\n                    | is : ModuleNameLookupTable -> Node Expression -> Bool\n                    , description : Description\n                }\n        }\n    -> CheckInfo\n    -> Maybe (Error {})\ncallOnEmptyReturnsEmptyCheck emptiableArg emptiable checkInfo =\n    callOnDoesNotChangeItCheck emptiable.empty emptiableArg checkInfo\n\n\ncallOnEmptyReturnsCheck :\n    { on : Node Expression\n    , resultAsString : QualifyResources {} -> String\n    }\n    ->\n        { a\n            | empty :\n                { empty\n                    | is : ModuleNameLookupTable -> Node Expression -> Bool\n                    , description : Description\n                }\n        }\n    -> CheckInfo\n    -> Maybe (Error {})\ncallOnEmptyReturnsCheck config collection checkInfo =\n    if collection.empty.is checkInfo.lookupTable config.on then\n        let\n            resultDescription : String\n            resultDescription =\n                config.resultAsString defaultQualifyResources\n        in\n        Just\n            (Rule.errorWithFix\n                { message = qualifiedToString (qualify checkInfo.fn defaultQualifyResources) ++ \" on \" ++ descriptionForIndefinite collection.empty.description ++ \" will result in \" ++ resultDescription\n                , details = [ \"You can replace this call by \" ++ resultDescription ++ \".\" ]\n                }\n                checkInfo.fnRange\n                [ Fix.replaceRangeBy checkInfo.parentRange\n                    (config.resultAsString (extractQualifyResources checkInfo))\n                ]\n            )\n\n    else\n        Nothing\n\n\ncallOnWrapReturnsItsValue :\n    Node Expression\n    ->\n        { otherProperties\n            | wrap : ConstructWithOneArgProperties\n        }\n    -> CheckInfo\n    -> Maybe (Error {})\ncallOnWrapReturnsItsValue withWrapArg withWrap checkInfo =\n    case sameInAllBranches (getValueWithNodeRange (withWrap.wrap.getValue checkInfo.lookupTable)) withWrapArg of\n        Undetermined ->\n            Nothing\n\n        Determined wraps ->\n            Just\n                (Rule.errorWithFix\n                    { message = qualifiedToString (qualify checkInfo.fn defaultQualifyResources) ++ \" on \" ++ descriptionForIndefinite withWrap.wrap.description ++ \" will result in the value inside\"\n                    , details = [ \"You can replace this call by the value inside \" ++ descriptionForDefinite \"the\" withWrap.wrap.description ++ \".\" ]\n                    }\n                    checkInfo.fnRange\n                    (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range withWrapArg }\n                        ++ List.concatMap (\\wrap -> replaceBySubExpressionFix wrap.nodeRange wrap.value) wraps\n                    )\n                )\n\n\ncallOnWrapReturnsJustItsValue :\n    Node Expression\n    ->\n        { otherProperties\n            | wrap : ConstructWithOneArgProperties\n        }\n    -> CheckInfo\n    -> Maybe (Error {})\ncallOnWrapReturnsJustItsValue withWrapArg withWrap checkInfo =\n    case sameInAllBranches (getValueWithNodeRange (withWrap.wrap.getValue checkInfo.lookupTable)) withWrapArg of\n        Determined wraps ->\n            Just\n                (Rule.errorWithFix\n                    { message = qualifiedToString checkInfo.fn ++ \" on \" ++ descriptionForIndefinite withWrap.wrap.description ++ \" will result in Just the value inside\"\n                    , details = [ \"You can replace this call by Just the value inside \" ++ descriptionForDefinite \"the\" withWrap.wrap.description ++ \".\" ]\n                    }\n                    checkInfo.fnRange\n                    (Fix.removeRange { start = (Node.range withWrapArg).end, end = checkInfo.parentRange.end }\n                        :: List.concatMap (\\wrap -> replaceBySubExpressionFix wrap.nodeRange wrap.value) wraps\n                        ++ [ Fix.replaceRangeBy { start = checkInfo.parentRange.start, end = (Node.range withWrapArg).start }\n                                (qualifiedToString (qualify ( [ \"Maybe\" ], \"Just\" ) checkInfo) ++ \" \")\n                           ]\n                    )\n                )\n\n        Undetermined ->\n            Nothing\n\n\nemptiableFilterChecks : EmptiableProperties otherProperties -> CheckInfo -> Maybe (Error {})\nemptiableFilterChecks emptiable checkInfo =\n    let\n        maybeEmptiableArg : Maybe (Node Expression)\n        maybeEmptiableArg =\n            secondArg checkInfo\n    in\n    firstThatConstructsJust\n        [ \\() ->\n            Maybe.andThen\n                (\\emptiableArg -> callOnEmptyReturnsEmptyCheck emptiableArg emptiable checkInfo)\n                maybeEmptiableArg\n        , \\() ->\n            case Evaluate.isAlwaysBoolean checkInfo checkInfo.firstArg of\n                Determined True ->\n                    Just\n                        (alwaysReturnsLastArgError\n                            (qualifiedToString checkInfo.fn ++ \" with a function that will always return True\")\n                            emptiable\n                            checkInfo\n                        )\n\n                Determined False ->\n                    Just\n                        (alwaysResultsInUnparenthesizedConstantError\n                            (qualifiedToString checkInfo.fn ++ \" with a function that will always return False\")\n                            { replacement = emptiable.empty.asString\n                            , lastArg = maybeEmptiableArg\n                            }\n                            checkInfo\n                        )\n\n                Undetermined ->\n                    Nothing\n        ]\n        ()\n\n\ncollectionRemoveChecks : CollectionProperties otherProperties -> CheckInfo -> Maybe (Error {})\ncollectionRemoveChecks collection checkInfo =\n    Maybe.andThen\n        (\\collectionArg -> callOnEmptyReturnsEmptyCheck collectionArg collection checkInfo)\n        (secondArg checkInfo)\n\n\ncollectionIntersectChecks : CollectionProperties otherProperties -> CheckInfo -> Maybe (Error {})\ncollectionIntersectChecks collection checkInfo =\n    firstThatConstructsJust\n        [ \\() -> callOnEmptyReturnsEmptyCheck checkInfo.firstArg collection checkInfo\n        , \\() ->\n            Maybe.andThen\n                (\\collectionArg -> callOnEmptyReturnsEmptyCheck collectionArg collection checkInfo)\n                (secondArg checkInfo)\n        ]\n        ()\n\n\ncollectionDiffChecks : CollectionProperties otherProperties -> CheckInfo -> Maybe (Error {})\ncollectionDiffChecks collection checkInfo =\n    let\n        maybeCollectionArg : Maybe (Node Expression)\n        maybeCollectionArg =\n            secondArg checkInfo\n\n        collectionEmptyAsString : String\n        collectionEmptyAsString =\n            emptyAsString checkInfo collection\n    in\n    firstThatConstructsJust\n        [ \\() ->\n            if collection.empty.is checkInfo.lookupTable checkInfo.firstArg then\n                Just\n                    (alwaysResultsInUnparenthesizedConstantError\n                        (qualifiedToString checkInfo.fn ++ \" on \" ++ collectionEmptyAsString)\n                        { replacement = collection.empty.asString\n                        , lastArg = maybeCollectionArg\n                        }\n                        checkInfo\n                    )\n\n            else\n                Nothing\n        , \\() ->\n            case maybeCollectionArg of\n                Just collectionArg ->\n                    if collection.empty.is checkInfo.lookupTable collectionArg then\n                        Just\n                            (Rule.errorWithFix\n                                { message = \"Diffing a \" ++ collection.represents ++ \" with \" ++ collectionEmptyAsString ++ \" will result in the \" ++ collection.represents ++ \" itself\"\n                                , details = [ \"You can replace this call by the \" ++ collection.represents ++ \" itself.\" ]\n                                }\n                                checkInfo.fnRange\n                                (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.firstArg })\n                            )\n\n                    else\n                        Nothing\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\ncollectionUnionChecks : CollectionProperties (FromListProperties otherProperties) -> CheckInfo -> Maybe (Error {})\ncollectionUnionChecks collection checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            if collection.empty.is checkInfo.lookupTable checkInfo.firstArg then\n                Just\n                    (alwaysReturnsLastArgError\n                        (qualifiedToString checkInfo.fn ++ \" \" ++ descriptionForIndefinite collection.empty.description)\n                        collection\n                        checkInfo\n                    )\n\n            else\n                Nothing\n        , \\() ->\n            case secondArg checkInfo of\n                Just secondArg_ ->\n                    if collection.empty.is checkInfo.lookupTable secondArg_ then\n                        Just\n                            (Rule.errorWithFix\n                                { message = \"Unnecessary \" ++ qualifiedToString (qualify checkInfo.fn defaultQualifyResources) ++ \" with \" ++ descriptionForIndefinite collection.empty.description\n                                , details = [ \"You can replace this call by the \" ++ collection.represents ++ \" itself.\" ]\n                                }\n                                checkInfo.fnRange\n                                (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.firstArg })\n                            )\n\n                    else\n                        collectionUnionWithLiteralsChecks collection\n                            { lookupTable = checkInfo.lookupTable\n                            , extractSourceCode = checkInfo.extractSourceCode\n                            , parentRange = checkInfo.parentRange\n                            , first = checkInfo.firstArg\n                            , second = secondArg_\n                            , operationRange = checkInfo.fnRange\n                            , operation = qualifiedToString (qualify checkInfo.fn defaultQualifyResources)\n                            }\n\n                Nothing ->\n                    Nothing\n        ]\n        ()\n\n\ncollectionUnionWithLiteralsChecks :\n    CollectionProperties (FromListProperties otherProperties)\n    ->\n        { lookupTable : ModuleNameLookupTable\n        , extractSourceCode : Range -> String\n        , parentRange : Range\n        , first : Node Expression\n        , second : Node Expression\n        , operationRange : Range\n        , operation : String\n        }\n    -> Maybe (Error {})\ncollectionUnionWithLiteralsChecks collection checkInfo =\n    case collection.fromListLiteralRange checkInfo.lookupTable checkInfo.second of\n        Just literalListRangeSecond ->\n            case collection.fromListLiteralRange checkInfo.lookupTable checkInfo.first of\n                Just literalListRangeFirst ->\n                    Just\n                        (Rule.errorWithFix\n                            { message = checkInfo.operation ++ \" on \" ++ collection.fromListLiteralDescription ++ \"s can be turned into a single \" ++ collection.fromListLiteralDescription\n                            , details = [ \"Try moving all the elements into a single \" ++ collection.fromListLiteralDescription ++ \".\" ]\n                            }\n                            checkInfo.operationRange\n                            (if collection.literalUnionLeftElementsStayOnTheLeft then\n                                keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.second }\n                                    ++ [ Fix.insertAt\n                                            (rangeWithoutBoundaries literalListRangeSecond).start\n                                            (checkInfo.extractSourceCode (rangeWithoutBoundaries literalListRangeFirst) ++ \",\")\n                                       ]\n\n                             else\n                                keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range checkInfo.first }\n                                    ++ [ Fix.insertAt\n                                            (rangeWithoutBoundaries literalListRangeFirst).start\n                                            (checkInfo.extractSourceCode (rangeWithoutBoundaries literalListRangeSecond) ++ \",\")\n                                       ]\n                            )\n                        )\n\n                Nothing ->\n                    Nothing\n\n        Nothing ->\n            Nothing\n\n\ncollectionInsertChecks : CollectionProperties otherProperties -> CheckInfo -> Maybe (Error {})\ncollectionInsertChecks collection checkInfo =\n    case secondArg checkInfo of\n        Just collectionArg ->\n            if collection.empty.is checkInfo.lookupTable collectionArg then\n                Just\n                    (Rule.errorWithFix\n                        { message = \"Use \" ++ qualifiedToString ( collection.moduleName, \"singleton\" ) ++ \" instead of inserting in \" ++ descriptionForIndefinite collection.empty.description\n                        , details = [ \"You can replace this call by \" ++ qualifiedToString ( collection.moduleName, \"singleton\" ) ++ \".\" ]\n                        }\n                        checkInfo.fnRange\n                        (replaceBySubExpressionFix checkInfo.parentRange checkInfo.firstArg\n                            ++ [ Fix.insertAt checkInfo.parentRange.start\n                                    (qualifiedToString (qualify ( collection.moduleName, \"singleton\" ) checkInfo) ++ \" \")\n                               ]\n                        )\n                    )\n\n            else\n                Nothing\n\n        Nothing ->\n            Nothing\n\n\ncollectionMemberChecks : CollectionProperties otherProperties -> CheckInfo -> Maybe (Error {})\ncollectionMemberChecks collection checkInfo =\n    Maybe.andThen\n        (\\collectionArg ->\n            callOnEmptyReturnsCheck\n                { on = collectionArg, resultAsString = \\res -> qualifiedToString (qualify ( [ \"Basics\" ], \"False\" ) res) }\n                collection\n                checkInfo\n        )\n        (secondArg checkInfo)\n\n\ncollectionIsEmptyChecks : CollectionProperties otherProperties -> CheckInfo -> Maybe (Error {})\ncollectionIsEmptyChecks collection checkInfo =\n    case collection.determineSize (extractInferResources checkInfo) checkInfo.firstArg of\n        Just (Exactly 0) ->\n            Just\n                (resultsInConstantError\n                    (qualifiedToString checkInfo.fn ++ \" on \" ++ descriptionForIndefinite collection.empty.description)\n                    (\\res -> qualifiedToString (qualify ( [ \"Basics\" ], \"True\" ) res))\n                    checkInfo\n                )\n\n        Just _ ->\n            Just\n                (resultsInConstantError\n                    (qualifiedToString checkInfo.fn ++ \" on this \" ++ collection.represents)\n                    (\\res -> qualifiedToString (qualify ( [ \"Basics\" ], \"False\" ) res))\n                    checkInfo\n                )\n\n        Nothing ->\n            Nothing\n\n\ncollectionSizeChecks : CollectionProperties otherProperties -> CheckInfo -> Maybe (Error {})\ncollectionSizeChecks collection checkInfo =\n    case collection.determineSize (extractInferResources checkInfo) checkInfo.firstArg of\n        Just (Exactly size) ->\n            Just\n                (Rule.errorWithFix\n                    { message = \"The \" ++ collection.nameForSize ++ \" of the \" ++ collection.represents ++ \" is \" ++ String.fromInt size\n                    , details = [ \"The \" ++ collection.nameForSize ++ \" of the \" ++ collection.represents ++ \" can be determined by looking at the code.\" ]\n                    }\n                    checkInfo.fnRange\n                    [ Fix.replaceRangeBy checkInfo.parentRange (String.fromInt size) ]\n                )\n\n        _ ->\n            Nothing\n\n\ncollectionFromListChecks : CollectionProperties otherProperties -> CheckInfo -> Maybe (Error {})\ncollectionFromListChecks collection checkInfo =\n    callOnEmptyReturnsCheck\n        { on = checkInfo.firstArg\n        , resultAsString = collection.empty.asString\n        }\n        listCollection\n        checkInfo\n\n\nwrapperFromListSingletonChecks : WrapperProperties otherProperties -> CheckInfo -> Maybe (Error {})\nwrapperFromListSingletonChecks wrapper checkInfo =\n    case AstHelpers.getListSingleton checkInfo.lookupTable checkInfo.firstArg of\n        Nothing ->\n            Nothing\n\n        Just listSingleton ->\n            Just\n                (Rule.errorWithFix\n                    { message = qualifiedToString checkInfo.fn ++ \" on a singleton list will result in \" ++ qualifiedToString ( wrapper.moduleName, wrapper.wrap.fnName ) ++ \" with the value inside\"\n                    , details = [ \"You can replace this call by \" ++ qualifiedToString ( wrapper.moduleName, wrapper.wrap.fnName ) ++ \" with the value inside the singleton list.\" ]\n                    }\n                    checkInfo.fnRange\n                    (replaceBySubExpressionFix (Node.range checkInfo.firstArg) listSingleton.element\n                        ++ [ Fix.replaceRangeBy checkInfo.fnRange (qualifiedToString (qualify ( wrapper.moduleName, wrapper.wrap.fnName ) checkInfo)) ]\n                    )\n                )\n\n\nwrapperFromListSingletonCompositionChecks : WrapperProperties otherProperties -> CompositionIntoCheckInfo -> Maybe ErrorInfoAndFix\nwrapperFromListSingletonCompositionChecks wrapper checkInfo =\n    case checkInfo.earlier.fn of\n        ( [ \"List\" ], \"singleton\" ) ->\n            Just\n                { info =\n                    { message = qualifiedToString checkInfo.later.fn ++ \" on a singleton list will result in \" ++ qualifiedToString ( wrapper.moduleName, wrapper.wrap.fnName ) ++ \" with the value inside\"\n                    , details = [ \"You can replace this call by \" ++ qualifiedToString ( wrapper.moduleName, wrapper.wrap.fnName ) ++ \".\" ]\n                    }\n                , fix =\n                    [ Fix.replaceRangeBy checkInfo.parentRange\n                        (qualifiedToString (qualify ( wrapper.moduleName, wrapper.wrap.fnName ) checkInfo))\n                    ]\n                }\n\n        _ ->\n            Nothing\n\n\nemptiableToListChecks :\n    { otherProperties\n        | empty :\n            { empty\n                | is : ModuleNameLookupTable -> Node Expression -> Bool\n                , description : Description\n            }\n    }\n    -> CheckInfo\n    -> Maybe (Error {})\nemptiableToListChecks collection checkInfo =\n    callOnEmptyReturnsCheck { on = checkInfo.firstArg, resultAsString = \\_ -> \"[]\" } collection checkInfo\n\n\ncollectionPartitionChecks : CollectionProperties otherProperties -> CheckInfo -> Maybe (Error {})\ncollectionPartitionChecks collection checkInfo =\n    let\n        collectionEmptyAsString : String\n        collectionEmptyAsString =\n            emptyAsString checkInfo collection\n    in\n    firstThatConstructsJust\n        [ \\() ->\n            case secondArg checkInfo of\n                Just collectionArg ->\n                    callOnEmptyReturnsCheck\n                        { on = collectionArg\n                        , resultAsString = \\res -> \"( \" ++ collection.empty.asString res ++ \", \" ++ collection.empty.asString res ++ \" )\"\n                        }\n                        collection\n                        checkInfo\n\n                Nothing ->\n                    Nothing\n        , \\() ->\n            case Evaluate.isAlwaysBoolean checkInfo checkInfo.firstArg of\n                Determined True ->\n                    case secondArg checkInfo of\n                        Just (Node listArgRange _) ->\n                            Just\n                                (Rule.errorWithFix\n                                    { message = \"All elements will go to the first \" ++ collection.represents\n                                    , details = [ \"Since the predicate function always returns True, the second \" ++ collection.represents ++ \" will always be \" ++ collection.empty.asString defaultQualifyResources ++ \".\" ]\n                                    }\n                                    checkInfo.fnRange\n                                    [ Fix.replaceRangeBy { start = checkInfo.fnRange.start, end = listArgRange.start } \"( \"\n                                    , Fix.insertAt listArgRange.end (\", \" ++ collectionEmptyAsString ++ \" )\")\n                                    ]\n                                )\n\n                        Nothing ->\n                            Nothing\n\n                Determined False ->\n                    Just\n                        (Rule.errorWithFix\n                            { message = \"All elements will go to the second \" ++ collection.represents\n                            , details = [ \"Since the predicate function always returns False, the first \" ++ collection.represents ++ \" will always be \" ++ collection.empty.asString defaultQualifyResources ++ \".\" ]\n                            }\n                            checkInfo.fnRange\n                            (case secondArg checkInfo of\n                                Just listArg ->\n                                    [ Fix.replaceRangeBy { start = checkInfo.fnRange.start, end = (Node.range listArg).start } (\"( \" ++ collectionEmptyAsString ++ \", \")\n                                    , Fix.insertAt (Node.range listArg).end \" )\"\n                                    ]\n\n                                Nothing ->\n                                    [ Fix.replaceRangeBy checkInfo.parentRange\n                                        (\"(\"\n                                            ++ qualifiedToString (qualify ( [ \"Tuple\" ], \"pair\" ) checkInfo)\n                                            ++ \" \"\n                                            ++ collectionEmptyAsString\n                                            ++ \")\"\n                                        )\n                                    ]\n                            )\n                        )\n\n                Undetermined ->\n                    Nothing\n        ]\n        ()\n\n\ntype CollectionSize\n    = Exactly Int\n    | NotEmpty\n\n\nreplaceSingleElementListBySingleValue : ModuleNameLookupTable -> Node Expression -> Maybe (List Fix)\nreplaceSingleElementListBySingleValue lookupTable expressionNode =\n    case Node.value (AstHelpers.removeParens expressionNode) of\n        Expression.ListExpr (listElement :: []) ->\n            Just (replaceBySubExpressionFix (Node.range expressionNode) listElement)\n\n        Expression.Application ((Node fnRange (Expression.FunctionOrValue _ \"singleton\")) :: _ :: []) ->\n            if ModuleNameLookupTable.moduleNameAt lookupTable fnRange == Just [ \"List\" ] then\n                Just [ Fix.removeRange fnRange ]\n\n            else\n                Nothing\n\n        Expression.IfBlock _ thenBranch elseBranch ->\n            combineSingleElementFixes lookupTable [ thenBranch, elseBranch ] []\n\n        Expression.CaseExpression caseOf ->\n            combineSingleElementFixes lookupTable (List.map Tuple.second caseOf.cases) []\n\n        _ ->\n            Nothing\n\n\ncombineSingleElementFixes : ModuleNameLookupTable -> List (Node Expression) -> List Fix -> Maybe (List Fix)\ncombineSingleElementFixes lookupTable nodes soFar =\n    case nodes of\n        [] ->\n            Just soFar\n\n        node :: restOfNodes ->\n            case replaceSingleElementListBySingleValue lookupTable node of\n                Nothing ->\n                    Nothing\n\n                Just fixes ->\n                    combineSingleElementFixes lookupTable restOfNodes (fixes ++ soFar)\n\n\n\n-- RECORD UPDATE\n\n\nrecordUpdateChecks : Range -> Node String -> List (Node Expression.RecordSetter) -> Maybe (Error {})\nrecordUpdateChecks recordUpdateRange recordVariable fields =\n    case findMapNeighboring (getUnnecessaryRecordUpdateSetter (Node.value recordVariable)) fields of\n        Just unnecessarySetterAndNeighbors ->\n            Just\n                (Rule.errorWithFix\n                    { message = \"Unnecessary field assignment\"\n                    , details = [ \"The field is being set to its own value.\" ]\n                    }\n                    unnecessarySetterAndNeighbors.found.valueAccessRange\n                    (case unnecessarySetterAndNeighbors.before of\n                        Just (Node prevRange _) ->\n                            [ Fix.removeRange { start = prevRange.end, end = unnecessarySetterAndNeighbors.found.setterRange.end } ]\n\n                        Nothing ->\n                            case unnecessarySetterAndNeighbors.after of\n                                Nothing ->\n                                    -- it's the only setter\n                                    keepOnlyFix { parentRange = recordUpdateRange, keep = Node.range recordVariable }\n\n                                Just (Node afterRange _) ->\n                                    -- It's the first setter, so we can remove until the second setter\n                                    [ Fix.removeRange { start = unnecessarySetterAndNeighbors.found.setterRange.start, end = afterRange.start } ]\n                    )\n                )\n\n        Nothing ->\n            Nothing\n\n\ngetUnnecessaryRecordUpdateSetter : String -> Node ( Node String, Node Expression ) -> Maybe { valueAccessRange : Range, setterRange : Range }\ngetUnnecessaryRecordUpdateSetter recordVariableName (Node setterRange ( Node _ field, valueNode )) =\n    case AstHelpers.removeParens valueNode of\n        Node valueAccessRange (Expression.RecordAccess (Node _ (Expression.FunctionOrValue [] valueHolder)) (Node _ fieldName)) ->\n            if field == fieldName && recordVariableName == valueHolder then\n                Just { setterRange = setterRange, valueAccessRange = valueAccessRange }\n\n            else\n                Nothing\n\n        _ ->\n            Nothing\n\n\n\n-- IF\n\n\ntype alias IfCheckInfo =\n    { lookupTable : ModuleNameLookupTable\n    , inferredConstants : ( Infer.Inferred, List Infer.Inferred )\n    , importLookup : ImportLookup\n    , moduleBindings : Set String\n    , localBindings : RangeDict (Set String)\n    , nodeRange : Range\n    , condition : Node Expression\n    , trueBranch : Node Expression\n    , falseBranch : Node Expression\n    }\n\n\ntargetIfKeyword : Range -> Range\ntargetIfKeyword ifExpressionRange =\n    let\n        ifStart : Location\n        ifStart =\n            ifExpressionRange.start\n    in\n    { start = ifStart\n    , end = { ifStart | column = ifStart.column + 2 }\n    }\n\n\nifChecks :\n    IfCheckInfo\n    -> Maybe { errors : Error {}, rangesToIgnore : RangeDict () }\nifChecks checkInfo =\n    firstThatConstructsJust\n        [ \\() ->\n            case Evaluate.getBoolean checkInfo checkInfo.condition of\n                Determined determinedConditionResultIsTrue ->\n                    let\n                        branch : { expressionNode : Node Expression, name : String }\n                        branch =\n                            if determinedConditionResultIsTrue then\n                                { expressionNode = checkInfo.trueBranch, name = \"then\" }\n\n                            else\n                                { expressionNode = checkInfo.falseBranch, name = \"else\" }\n                    in\n                    Just\n                        { errors =\n                            Rule.errorWithFix\n                                { message = \"The condition will always evaluate to \" ++ AstHelpers.boolToString determinedConditionResultIsTrue\n                                , details = [ \"The expression can be replaced by what is inside the '\" ++ branch.name ++ \"' branch.\" ]\n                                }\n                                (targetIfKeyword checkInfo.nodeRange)\n                                (replaceBySubExpressionFix checkInfo.nodeRange branch.expressionNode)\n                        , rangesToIgnore = RangeDict.singleton (Node.range checkInfo.condition) ()\n                        }\n\n                Undetermined ->\n                    Nothing\n        , \\() ->\n            case ( Evaluate.getBoolean checkInfo checkInfo.trueBranch, Evaluate.getBoolean checkInfo checkInfo.falseBranch ) of\n                ( Determined True, Determined False ) ->\n                    Just\n                        { errors =\n                            Rule.errorWithFix\n                                { message = \"The if expression's value is the same as the condition\"\n                                , details = [ \"The expression can be replaced by the condition.\" ]\n                                }\n                                (targetIfKeyword checkInfo.nodeRange)\n                                (replaceBySubExpressionFix checkInfo.nodeRange checkInfo.condition)\n                        , rangesToIgnore = RangeDict.empty\n                        }\n\n                ( Determined False, Determined True ) ->\n                    Just\n                        { errors =\n                            Rule.errorWithFix\n                                { message = \"The if expression's value is the inverse of the condition\"\n                                , details = [ \"The expression can be replaced by the condition wrapped by `not`.\" ]\n                                }\n                                (targetIfKeyword checkInfo.nodeRange)\n                                (replaceBySubExpressionFix checkInfo.nodeRange checkInfo.condition\n                                    ++ [ Fix.insertAt checkInfo.nodeRange.start\n                                            (qualifiedToString (qualify ( [ \"Basics\" ], \"not\" ) checkInfo) ++ \" \")\n                                       ]\n                                )\n                        , rangesToIgnore = RangeDict.empty\n                        }\n\n                _ ->\n                    Nothing\n        , \\() ->\n            case Normalize.compare checkInfo checkInfo.trueBranch checkInfo.falseBranch of\n                Normalize.ConfirmedEquality ->\n                    Just\n                        { errors =\n                            Rule.errorWithFix\n                                { message = \"The values in both branches is the same.\"\n                                , details = [ \"The expression can be replaced by the contents of either branch.\" ]\n                                }\n                                (targetIfKeyword checkInfo.nodeRange)\n                                (replaceBySubExpressionFix checkInfo.nodeRange checkInfo.trueBranch)\n                        , rangesToIgnore = RangeDict.empty\n                        }\n\n                _ ->\n                    Nothing\n        ]\n        ()\n\n\n\n-- CASE OF\n\n\ncaseOfChecks : List (CaseOfCheckInfo -> Maybe (Error {}))\ncaseOfChecks =\n    [ sameBodyForCaseOfChecks\n    , booleanCaseOfChecks\n    , destructuringCaseOfChecks\n    ]\n\n\ntype alias CaseOfCheckInfo =\n    { lookupTable : ModuleNameLookupTable\n    , customTypesToReportInCases : Set ( ModuleName, ConstructorName )\n    , extractSourceCode : Range -> String\n    , inferredConstants : ( Infer.Inferred, List Infer.Inferred )\n    , parentRange : Range\n    , caseOf : Expression.CaseBlock\n    }\n\n\nsameBodyForCaseOfChecks :\n    CaseOfCheckInfo\n    -> Maybe (Error {})\nsameBodyForCaseOfChecks context =\n    case context.caseOf.cases of\n        [] ->\n            Nothing\n\n        ( firstPattern, firstBody ) :: rest ->\n            let\n                restPatterns : List (Node Pattern)\n                restPatterns =\n                    List.map Tuple.first rest\n            in\n            if\n                introducesVariableOrUsesTypeConstructor context (firstPattern :: restPatterns)\n                    || not (Normalize.areAllTheSame context firstBody (List.map Tuple.second rest))\n            then\n                Nothing\n\n            else\n                let\n                    firstBodyRange : Range\n                    firstBodyRange =\n                        Node.range firstBody\n                in\n                Just\n                    (Rule.errorWithFix\n                        { message = \"Unnecessary case expression\"\n                        , details = [ \"All the branches of this case expression resolve to the same value. You can remove the case expression and replace it with the body of one of the branches.\" ]\n                        }\n                        (caseKeyWordRange context.parentRange)\n                        [ Fix.removeRange { start = context.parentRange.start, end = firstBodyRange.start }\n                        , Fix.removeRange { start = firstBodyRange.end, end = context.parentRange.end }\n                        ]\n                    )\n\n\ncaseKeyWordRange : Range -> Range\ncaseKeyWordRange range =\n    { start = range.start\n    , end = { row = range.start.row, column = range.start.column + 4 }\n    }\n\n\nintroducesVariableOrUsesTypeConstructor :\n    { a | lookupTable : ModuleNameLookupTable, customTypesToReportInCases : Set ( ModuleName, ConstructorName ) }\n    -> List (Node Pattern)\n    -> Bool\nintroducesVariableOrUsesTypeConstructor resources nodesToLookAt =\n    case nodesToLookAt of\n        [] ->\n            False\n\n        node :: remaining ->\n            case Node.value node of\n                Pattern.VarPattern _ ->\n                    True\n\n                Pattern.RecordPattern _ ->\n                    True\n\n                Pattern.AsPattern _ _ ->\n                    True\n\n                Pattern.ParenthesizedPattern pattern ->\n                    introducesVariableOrUsesTypeConstructor resources (pattern :: remaining)\n\n                Pattern.TuplePattern nodes ->\n                    introducesVariableOrUsesTypeConstructor resources (nodes ++ remaining)\n\n                Pattern.UnConsPattern first rest ->\n                    introducesVariableOrUsesTypeConstructor resources (first :: rest :: remaining)\n\n                Pattern.ListPattern nodes ->\n                    introducesVariableOrUsesTypeConstructor resources (nodes ++ remaining)\n\n                Pattern.NamedPattern variantQualified nodes ->\n                    case ModuleNameLookupTable.fullModuleNameFor resources.lookupTable node of\n                        Just moduleName ->\n                            if Set.member ( moduleName, variantQualified.name ) resources.customTypesToReportInCases then\n                                introducesVariableOrUsesTypeConstructor resources (nodes ++ remaining)\n\n                            else\n                                True\n\n                        Nothing ->\n                            True\n\n                _ ->\n                    introducesVariableOrUsesTypeConstructor resources remaining\n\n\nbooleanCaseOfChecks : CaseOfCheckInfo -> Maybe (Error {})\nbooleanCaseOfChecks checkInfo =\n    case checkInfo.caseOf.cases of\n        ( firstPattern, Node firstRange _ ) :: ( Node secondPatternRange _, Node secondExprRange _ ) :: [] ->\n            case AstHelpers.getBoolPattern checkInfo.lookupTable firstPattern of\n                Just isTrueFirst ->\n                    let\n                        expressionRange : Range\n                        expressionRange =\n                            Node.range checkInfo.caseOf.expression\n                    in\n                    Just\n                        (Rule.errorWithFix\n                            { message = \"Replace `case..of` by an `if` condition\"\n                            , details =\n                                [ \"The idiomatic way to check for a condition is to use an `if` expression.\"\n                                , \"Read more about it at: https://guide.elm-lang.org/core_language.html#if-expressions\"\n                                ]\n                            }\n                            (Node.range firstPattern)\n                            (if isTrueFirst then\n                                [ Fix.replaceRangeBy { start = checkInfo.parentRange.start, end = expressionRange.start } \"if \"\n                                , Fix.replaceRangeBy { start = expressionRange.end, end = firstRange.start } \" then \"\n                                , Fix.replaceRangeBy { start = secondPatternRange.start, end = secondExprRange.start } \"else \"\n                                ]\n\n                             else\n                                [ Fix.replaceRangeBy { start = checkInfo.parentRange.start, end = expressionRange.start } \"if not (\"\n                                , Fix.replaceRangeBy { start = expressionRange.end, end = firstRange.start } \") then \"\n                                , Fix.replaceRangeBy { start = secondPatternRange.start, end = secondExprRange.start } \"else \"\n                                ]\n                            )\n                        )\n\n                Nothing ->\n                    Nothing\n\n        _ ->\n            Nothing\n\n\ndestructuringCaseOfChecks :\n    CaseOfCheckInfo\n    -> Maybe (Error {})\ndestructuringCaseOfChecks checkInfo =\n    case checkInfo.caseOf.cases of\n        ( rawSinglePattern, Node bodyRange _ ) :: [] ->\n            let\n                singlePattern : Node Pattern\n                singlePattern =\n                    AstHelpers.removeParensFromPattern rawSinglePattern\n            in\n            if isSimpleDestructurePattern singlePattern then\n                let\n                    exprRange : Range\n                    exprRange =\n                        Node.range checkInfo.caseOf.expression\n\n                    caseIndentation : String\n                    caseIndentation =\n                        String.repeat (checkInfo.parentRange.start.column - 1) \" \"\n\n                    bodyIndentation : String\n                    bodyIndentation =\n                        String.repeat (bodyRange.start.column - 1) \" \"\n                in\n                Just\n                    (Rule.errorWithFix\n                        { message = \"Use a let expression to destructure data\"\n                        , details = [ \"It is more idiomatic in Elm to use a let expression to define a new variable rather than to use pattern matching. This will also make the code less indented, therefore easier to read.\" ]\n                        }\n                        (Node.range singlePattern)\n                        [ Fix.replaceRangeBy { start = checkInfo.parentRange.start, end = exprRange.start }\n                            (\"let \" ++ checkInfo.extractSourceCode (Node.range singlePattern) ++ \" = \")\n                        , Fix.replaceRangeBy { start = exprRange.end, end = bodyRange.start }\n                            (\"\\n\" ++ caseIndentation ++ \"in\\n\" ++ bodyIndentation)\n                        ]\n                    )\n\n            else\n                Nothing\n\n        _ ->\n            Nothing\n\n\nisSimpleDestructurePattern : Node Pattern -> Bool\nisSimpleDestructurePattern (Node _ pattern) =\n    case pattern of\n        Pattern.TuplePattern _ ->\n            True\n\n        Pattern.RecordPattern _ ->\n            True\n\n        Pattern.VarPattern _ ->\n            True\n\n        _ ->\n            False\n\n\n\n-- NEGATION\n\n\nnegationChecks : { parentRange : Range, negatedExpression : Node Expression } -> Maybe (Error {})\nnegationChecks checkInfo =\n    case AstHelpers.removeParens checkInfo.negatedExpression of\n        Node range (Expression.Negation negatedValue) ->\n            let\n                doubleNegationRange : Range\n                doubleNegationRange =\n                    { start = checkInfo.parentRange.start\n                    , end = { row = range.start.row, column = range.start.column + 1 }\n                    }\n            in\n            Just\n                (Rule.errorWithFix\n                    { message = \"Unnecessary double number negation\"\n                    , details = [ \"Negating a number twice is the same as the number itself.\" ]\n                    }\n                    doubleNegationRange\n                    (replaceBySubExpressionFix checkInfo.parentRange negatedValue)\n                )\n\n        _ ->\n            Nothing\n\n\n\n-- FULLY APPLIED PREFIX OPERATORS\n\n\nfullyAppliedPrefixOperatorError :\n    { operator : String\n    , operatorRange : Range\n    , left : Node Expression\n    , right : Node Expression\n    }\n    -> Error {}\nfullyAppliedPrefixOperatorError checkInfo =\n    Rule.errorWithFix\n        { message = \"Use the infix form (a + b) over the prefix form ((+) a b)\"\n        , details = [ \"The prefix form is generally more unfamiliar to Elm developers, and therefore it is nicer when the infix form is used.\" ]\n        }\n        checkInfo.operatorRange\n        [ Fix.removeRange { start = checkInfo.operatorRange.start, end = (Node.range checkInfo.left).start }\n        , Fix.insertAt (Node.range checkInfo.right).start (checkInfo.operator ++ \" \")\n        ]\n\n\n\n-- APPLIED LAMBDA\n\n\nappliedLambdaError : { nodeRange : Range, lambdaRange : Range, lambda : Expression.Lambda } -> Maybe (Error {})\nappliedLambdaError checkInfo =\n    case checkInfo.lambda.args of\n        (Node unitRange Pattern.UnitPattern) :: otherPatterns ->\n            Just\n                (Rule.errorWithFix\n                    { message = \"Unnecessary unit argument\"\n                    , details =\n                        [ \"This function is expecting a unit, but also passing it directly.\"\n                        , \"Maybe this was made in attempt to make the computation lazy, but in practice the function will be evaluated eagerly.\"\n                        ]\n                    }\n                    unitRange\n                    (case otherPatterns of\n                        [] ->\n                            replaceBySubExpressionFix checkInfo.nodeRange checkInfo.lambda.expression\n\n                        secondPattern :: _ ->\n                            Fix.removeRange { start = unitRange.start, end = (Node.range secondPattern).start }\n                                :: keepOnlyAndParenthesizeFix { parentRange = checkInfo.nodeRange, keep = checkInfo.lambdaRange }\n                    )\n                )\n\n        (Node allRange Pattern.AllPattern) :: otherPatterns ->\n            Just\n                (Rule.errorWithFix\n                    { message = \"Unnecessary wildcard argument argument\"\n                    , details =\n                        [ \"This function is being passed an argument that is directly ignored.\"\n                        , \"Maybe this was made in attempt to make the computation lazy, but in practice the function will be evaluated eagerly.\"\n                        ]\n                    }\n                    allRange\n                    (case otherPatterns of\n                        [] ->\n                            replaceBySubExpressionFix checkInfo.nodeRange checkInfo.lambda.expression\n\n                        secondPattern :: _ ->\n                            Fix.removeRange { start = allRange.start, end = (Node.range secondPattern).start }\n                                :: keepOnlyAndParenthesizeFix { parentRange = checkInfo.nodeRange, keep = checkInfo.lambdaRange }\n                    )\n                )\n\n        _ ->\n            Nothing\n\n\n\n-- LET IN\n\n\nletInChecks : Expression.LetBlock -> Maybe (Error {})\nletInChecks letBlock =\n    case Node.value letBlock.expression of\n        Expression.LetExpression _ ->\n            let\n                letRange : Range\n                letRange =\n                    letKeyWordRange (Node.range letBlock.expression)\n            in\n            Just\n                (Rule.errorWithFix\n                    { message = \"Let blocks can be joined together\"\n                    , details = [ \"Let blocks can contain multiple declarations, and there is no advantage to having multiple chained let expressions rather than one longer let expression.\" ]\n                    }\n                    letRange\n                    (case listLast letBlock.declarations of\n                        Just (Node lastDeclRange _) ->\n                            [ Fix.replaceRangeBy { start = lastDeclRange.end, end = letRange.end } \"\\n\" ]\n\n                        Nothing ->\n                            []\n                    )\n                )\n\n        _ ->\n            Nothing\n\n\nletKeyWordRange : Range -> Range\nletKeyWordRange range =\n    { start = range.start\n    , end = { row = range.start.row, column = range.start.column + 3 }\n    }\n\n\n\n-- RECORD ACCESS\n\n\nrecordAccessChecks :\n    { nodeRange : Range\n    , maybeRecordNameRange : Maybe Range\n    , fieldName : String\n    , setters : List (Node Expression.RecordSetter)\n    }\n    -> Maybe ErrorInfoAndFix\nrecordAccessChecks checkInfo =\n    let\n        maybeMatchingSetterValue : Maybe (Node Expression)\n        maybeMatchingSetterValue =\n            findMap\n                (\\(Node _ ( Node _ setterField, setterValue )) ->\n                    if setterField == checkInfo.fieldName then\n                        Just setterValue\n\n                    else\n                        Nothing\n                )\n                checkInfo.setters\n    in\n    case maybeMatchingSetterValue of\n        Just setter ->\n            Just\n                { info =\n                    { message = \"Field access can be simplified\"\n                    , details = [ \"Accessing the field of a record or record update can be simplified to just that field's value\" ]\n                    }\n                , fix = replaceBySubExpressionFix checkInfo.nodeRange setter\n                }\n\n        Nothing ->\n            case checkInfo.maybeRecordNameRange of\n                Just recordNameRange ->\n                    Just\n                        { info =\n                            { message = \"Field access can be simplified\"\n                            , details = [ \"Accessing the field of an unrelated record update can be simplified to just the original field's value\" ]\n                            }\n                        , fix =\n                            [ Fix.replaceRangeBy { start = checkInfo.nodeRange.start, end = recordNameRange.start } \"\"\n                            , Fix.replaceRangeBy { start = recordNameRange.end, end = checkInfo.nodeRange.end } (\".\" ++ checkInfo.fieldName)\n                            ]\n                        }\n\n                Nothing ->\n                    Nothing\n\n\ndistributeFieldAccess : String -> Range -> List (Node Expression) -> String -> Maybe ErrorInfoAndFix\ndistributeFieldAccess kind dotFieldRange branches fieldName =\n    case returnsRecordInAllBranches branches of\n        Just records ->\n            Just\n                { info =\n                    { message = \"Field access can be simplified\"\n                    , details = [ \"Accessing the field outside \" ++ kind ++ \" expression can be simplified to access the field inside it\" ]\n                    }\n                , fix =\n                    Fix.removeRange dotFieldRange\n                        :: List.concatMap (\\leaf -> replaceSubExpressionByRecordAccessFix fieldName leaf) records\n                }\n\n        Nothing ->\n            Nothing\n\n\ninjectRecordAccessIntoLetExpression : Range -> Node Expression -> String -> ErrorInfoAndFix\ninjectRecordAccessIntoLetExpression dotFieldRange letBody fieldName =\n    { info =\n        { message = \"Field access can be simplified\"\n        , details = [ \"Accessing the field outside a let/in expression can be simplified to access the field inside it\" ]\n        }\n    , fix =\n        Fix.removeRange dotFieldRange\n            :: replaceSubExpressionByRecordAccessFix fieldName letBody\n    }\n\n\nreturnsRecordInAllBranches : List (Node Expression) -> Maybe (List (Node Expression))\nreturnsRecordInAllBranches nodes =\n    case Match.traverse (sameInAllBranches getRecordLeafExpression) nodes of\n        Match.Determined leaves ->\n            Just (List.concat leaves)\n\n        Match.Undetermined ->\n            Nothing\n\n\ngetRecordLeafExpression : Node Expression -> Maybe (Node Expression)\ngetRecordLeafExpression expressionNode =\n    case Node.value (AstHelpers.removeParens expressionNode) of\n        Expression.RecordExpr _ ->\n            Just expressionNode\n\n        Expression.RecordUpdateExpression _ _ ->\n            Just expressionNode\n\n        _ ->\n            Nothing\n\n\n\n-- FIX HELPERS\n\n\nparenthesizeIfNeededFix : Node Expression -> List Fix\nparenthesizeIfNeededFix (Node expressionRange expression) =\n    if needsParens expression then\n        parenthesizeFix expressionRange\n\n    else\n        []\n\n\nparenthesizeFix : Range -> List Fix\nparenthesizeFix toSurround =\n    [ Fix.insertAt toSurround.start \"(\"\n    , Fix.insertAt toSurround.end \")\"\n    ]\n\n\nkeepOnlyFix : { parentRange : Range, keep : Range } -> List Fix\nkeepOnlyFix config =\n    [ Fix.removeRange\n        { start = config.parentRange.start\n        , end = config.keep.start\n        }\n    , Fix.removeRange\n        { start = config.keep.end\n        , end = config.parentRange.end\n        }\n    ]\n\n\nkeepOnlyAndParenthesizeFix : { parentRange : Range, keep : Range } -> List Fix\nkeepOnlyAndParenthesizeFix config =\n    [ Fix.replaceRangeBy { start = config.parentRange.start, end = config.keep.start } \"(\"\n    , Fix.replaceRangeBy { start = config.keep.end, end = config.parentRange.end } \")\"\n    ]\n\n\nreplaceBySubExpressionFix : Range -> Node Expression -> List Fix\nreplaceBySubExpressionFix outerRange (Node exprRange exprValue) =\n    if needsParens exprValue then\n        keepOnlyAndParenthesizeFix { parentRange = outerRange, keep = exprRange }\n\n    else\n        keepOnlyFix { parentRange = outerRange, keep = exprRange }\n\n\nreplaceSubExpressionByRecordAccessFix : String -> Node Expression -> List Fix\nreplaceSubExpressionByRecordAccessFix fieldName (Node exprRange exprValue) =\n    if needsParens exprValue then\n        [ Fix.insertAt exprRange.start \"(\"\n        , Fix.insertAt exprRange.end (\").\" ++ fieldName)\n        ]\n\n    else\n        [ Fix.insertAt exprRange.end (\".\" ++ fieldName) ]\n\n\nrangeBetweenExclusive : ( Range, Range ) -> Range\nrangeBetweenExclusive ( aRange, bRange ) =\n    case Range.compareLocations aRange.start bRange.start of\n        GT ->\n            { start = bRange.end, end = aRange.start }\n\n        -- EQ | LT\n        _ ->\n            { start = aRange.end, end = bRange.start }\n\n\nrangeContainsLocation : Location -> Range -> Bool\nrangeContainsLocation location =\n    \\range ->\n        not\n            ((Range.compareLocations location range.start == LT)\n                || (Range.compareLocations location range.end == GT)\n            )\n\n\nrangeWithoutBoundaries : Range -> Range\nrangeWithoutBoundaries range =\n    { start = startWithoutBoundary range\n    , end = endWithoutBoundary range\n    }\n\n\nstartWithoutBoundary : Range -> Location\nstartWithoutBoundary range =\n    { row = range.start.row, column = range.start.column + 1 }\n\n\nendWithoutBoundary : Range -> Location\nendWithoutBoundary range =\n    { row = range.end.row, column = range.end.column - 1 }\n\n\nremoveBoundariesFix : Node a -> List Fix\nremoveBoundariesFix (Node nodeRange _) =\n    [ Fix.removeRange (leftBoundaryRange nodeRange)\n    , Fix.removeRange (rightBoundaryRange nodeRange)\n    ]\n\n\nleftBoundaryRange : Range -> Range\nleftBoundaryRange range =\n    { start = range.start\n    , end = { row = range.start.row, column = range.start.column + 1 }\n    }\n\n\nrightBoundaryRange : Range -> Range\nrightBoundaryRange range =\n    { start = { row = range.end.row, column = range.end.column - 1 }\n    , end = range.end\n    }\n\n\n{-| Shortcut for `alwaysResultsInConstantError` with `replacementNeedsParens = False`.\n\nIf you want to replace to something like `Just []`,\nuse `alwaysResultsInConstantError` with `replacementNeedsParens = True`.\n\n-}\nalwaysResultsInUnparenthesizedConstantError :\n    String\n    ->\n        { replacement : QualifyResources {} -> String\n        , lastArg : Maybe arg\n        }\n    -> CheckInfo\n    -> Error {}\nalwaysResultsInUnparenthesizedConstantError usingSituation config checkInfo =\n    alwaysResultsInConstantError usingSituation\n        { replacement = config.replacement\n        , replacementNeedsParens = False\n        , lastArg = config.lastArg\n        }\n        checkInfo\n\n\n{-| Regardless of what the next incoming value will be, the result is already determined to be a given constant.\n\nFor example, `List.repeat 0` will always return [], whatever the argument will be.\n\nIf your function also always returns a constant but it does not have an irrelevant next argument,\nlike `List.range 1 0`, use `resultsInConstantError`\n\n-}\nalwaysResultsInConstantError :\n    String\n    ->\n        { replacement : QualifyResources {} -> String\n        , replacementNeedsParens : Bool\n        , lastArg : Maybe arg\n        }\n    -> CheckInfo\n    -> Error {}\nalwaysResultsInConstantError usingSituation config checkInfo =\n    let\n        addNecessaryParens : String -> String\n        addNecessaryParens string =\n            if config.replacementNeedsParens then\n                \"(\" ++ string ++ \")\"\n\n            else\n                string\n\n        replacement : QualifyResources {} -> String\n        replacement =\n            case config.lastArg of\n                Just _ ->\n                    config.replacement\n\n                Nothing ->\n                    \\resources ->\n                        qualifiedToString (qualify ( [ \"Basics\" ], \"always\" ) resources)\n                            ++ \" \"\n                            ++ addNecessaryParens (config.replacement resources)\n    in\n    Rule.errorWithFix\n        { message = usingSituation ++ \" will always result in \" ++ config.replacement defaultQualifyResources\n        , details = [ \"You can replace this call by \" ++ replacement defaultQualifyResources ++ \".\" ]\n        }\n        checkInfo.fnRange\n        [ Fix.replaceRangeBy checkInfo.parentRange (replacement (extractQualifyResources checkInfo)) ]\n\n\n{-| The result in the given situation is determined to be a given constant.\n\nFor example, `List.range 1 0` will return [].\n\nIf your function also always returns a constant but has an irrelevant next argument,\nlike `List.repeat 0`, use `alwaysResultsInConstantError`\n\n-}\nresultsInConstantError : String -> (QualifyResources {} -> String) -> CheckInfo -> Error {}\nresultsInConstantError usingSituation replacement checkInfo =\n    Rule.errorWithFix\n        { message = usingSituation ++ \" will result in \" ++ replacement defaultQualifyResources\n        , details = [ \"You can replace this call by \" ++ replacement defaultQualifyResources ++ \".\" ]\n        }\n        checkInfo.fnRange\n        [ Fix.replaceRangeBy checkInfo.parentRange (replacement (extractQualifyResources checkInfo)) ]\n\n\noperationDoesNotChangeSpecificLastArgErrorInfo : { fn : ( ModuleName, String ), specific : Description } -> { message : String, details : List String }\noperationDoesNotChangeSpecificLastArgErrorInfo config =\n    let\n        specificLastArgReference : String\n        specificLastArgReference =\n            descriptionForDefinite \"the given\" config.specific\n    in\n    { message = qualifiedToString config.fn ++ \" on \" ++ descriptionForIndefinite config.specific ++ \" will result in \" ++ specificLastArgReference\n    , details = [ \"You can replace this call by \" ++ specificLastArgReference ++ \".\" ]\n    }\n\n\n{-| In your specific situation, the last incoming argument will always be returned unchanged.\n\nFor example, `List.map identity` will not change whatever list comes next. It is equivalent to `identity`\n\nUse `returnsArgError` with the given last arg as `arg` when the last arg is already present.\n\n-}\nalwaysReturnsLastArgError :\n    String\n    -> { b | represents : String }\n    -> QualifyResources { a | fnRange : Range, parentRange : Range, argCount : Int, argsAfterFirst : List (Node Expression) }\n    -> Error {}\nalwaysReturnsLastArgError usingSpecificSituation config checkInfo =\n    case List.drop (checkInfo.argCount - 2) checkInfo.argsAfterFirst |> List.head of\n        Just lastArg ->\n            returnsArgError usingSpecificSituation { arg = lastArg, argRepresents = config.represents } checkInfo\n\n        Nothing ->\n            -- Not enough arguments\n            let\n                replacement : { description : String, fix : List Fix }\n                replacement =\n                    case checkInfo.argCount - List.length checkInfo.argsAfterFirst - 1 of\n                        1 ->\n                            { description = \"identity\"\n                            , fix =\n                                [ Fix.replaceRangeBy checkInfo.parentRange\n                                    (qualifiedToString (qualify ( [ \"Basics\" ], \"identity\" ) checkInfo))\n                                ]\n                            }\n\n                        2 ->\n                            { description = \"always identity\"\n                            , fix =\n                                [ Fix.replaceRangeBy checkInfo.parentRange\n                                    (qualifiedToString (qualify ( [ \"Basics\" ], \"always\" ) checkInfo) ++ \" \" ++ qualifiedToString (qualify ( [ \"Basics\" ], \"identity\" ) checkInfo))\n                                ]\n                            }\n\n                        _ ->\n                            -- Use-case is absent for now\n                            { description = \"the \" ++ config.represents ++ \" argument\"\n                            , fix = []\n                            }\n            in\n            Rule.errorWithFix\n                { message = usingSpecificSituation ++ \" will always return the same given \" ++ config.represents\n                , details =\n                    [ \"You can replace this call by \" ++ replacement.description ++ \".\" ]\n                }\n                checkInfo.fnRange\n                replacement.fix\n\n\n{-| In your specific situation, the given arg will always be returned unchanged.\n\nUse `alwaysReturnsLastArgError` when the last arg could be absent and it would still not change, like with `List.map identity`.\n\n-}\nreturnsArgError :\n    String\n    ->\n        { argRepresents : String\n        , arg : Node Expression\n        }\n    -> QualifyResources { a | fnRange : Range, parentRange : Range }\n    -> Error {}\nreturnsArgError usingSituation config checkInfo =\n    Rule.errorWithFix\n        { message = usingSituation ++ \" will always return the same given \" ++ config.argRepresents\n        , details =\n            [ \"You can replace this call by the \" ++ config.argRepresents ++ \" itself.\" ]\n        }\n        checkInfo.fnRange\n        (keepOnlyFix { parentRange = checkInfo.parentRange, keep = Node.range config.arg })\n\n\nmultiAlways : Int -> String -> QualifyResources a -> String\nmultiAlways alwaysCount alwaysResultExpressionAsString qualifyResources =\n    case alwaysCount of\n        0 ->\n            alwaysResultExpressionAsString\n\n        1 ->\n            qualifiedToString (qualify ( [ \"Basics\" ], \"always\" ) qualifyResources)\n                ++ \" \"\n                ++ alwaysResultExpressionAsString\n\n        alwaysCountPositive ->\n            \"(\\\\\" ++ String.repeat alwaysCountPositive \"_ \" ++ \"-> \" ++ alwaysResultExpressionAsString ++ \")\"\n\n\n{-| Use in combination with\n`findMapNeighboring` where finding returns a record containing the element's Range\nWorks for patterns and expressions.\n-}\nlistLiteralElementRemoveFix : { before : Maybe (Node element), found : { found | range : Range }, after : Maybe (Node element) } -> List Fix\nlistLiteralElementRemoveFix toRemove =\n    case ( toRemove.before, toRemove.after ) of\n        -- found the only element\n        ( Nothing, Nothing ) ->\n            [ Fix.removeRange toRemove.found.range ]\n\n        -- found first element\n        ( Nothing, Just (Node afterRange _) ) ->\n            [ Fix.removeRange\n                { start = toRemove.found.range.start\n                , end = afterRange.start\n                }\n            ]\n\n        -- found after first element\n        ( Just (Node beforeRange _), _ ) ->\n            [ Fix.removeRange\n                { start = beforeRange.end\n                , end = toRemove.found.range.end\n                }\n            ]\n\n\n{-| Use in combination with\n`findMapNeighboring` where finding returns a record containing the element's Range\nWorks for patterns and expressions.\n-}\ncollapsedConsRemoveElementFix :\n    { toRemove : { before : Maybe (Node element), after : Maybe (Node element), found : { found | range : Range } }\n    , tailRange : Range\n    }\n    -> List Fix\ncollapsedConsRemoveElementFix config =\n    case ( config.toRemove.before, config.toRemove.after ) of\n        -- found the only consed element\n        ( Nothing, Nothing ) ->\n            [ Fix.removeRange\n                { start = config.toRemove.found.range.start, end = config.tailRange.start }\n            ]\n\n        -- found first consed element\n        ( Nothing, Just (Node afterRange _) ) ->\n            [ Fix.removeRange\n                { start = config.toRemove.found.range.start\n                , end = afterRange.start\n                }\n            ]\n\n        -- found after first consed element\n        ( Just (Node beforeRange _), _ ) ->\n            [ Fix.removeRange\n                { start = beforeRange.end\n                , end = config.toRemove.found.range.end\n                }\n            ]\n\n\n\n-- STRING\n\n\nwrapInBackticks : String -> String\nwrapInBackticks s =\n    \"`\" ++ s ++ \"`\"\n\n\n\n-- MATCHERS AND PARSERS\n\n\nneedsParens : Expression -> Bool\nneedsParens expr =\n    case expr of\n        Expression.Application _ ->\n            True\n\n        Expression.OperatorApplication _ _ _ _ ->\n            True\n\n        Expression.IfBlock _ _ _ ->\n            True\n\n        Expression.Negation _ ->\n            True\n\n        Expression.LetExpression _ ->\n            True\n\n        Expression.CaseExpression _ ->\n            True\n\n        Expression.LambdaExpression _ ->\n            True\n\n        Expression.UnitExpr ->\n            False\n\n        Expression.CharLiteral _ ->\n            False\n\n        Expression.Integer _ ->\n            False\n\n        Expression.Hex _ ->\n            False\n\n        Expression.Floatable _ ->\n            False\n\n        Expression.Literal _ ->\n            False\n\n        Expression.GLSLExpression _ ->\n            False\n\n        Expression.PrefixOperator _ ->\n            False\n\n        Expression.RecordAccessFunction _ ->\n            False\n\n        Expression.RecordAccess _ _ ->\n            False\n\n        Expression.FunctionOrValue _ _ ->\n            False\n\n        Expression.ParenthesizedExpression _ ->\n            False\n\n        Expression.TupledExpression _ ->\n            False\n\n        Expression.ListExpr _ ->\n            False\n\n        Expression.RecordExpr _ ->\n            False\n\n        Expression.RecordUpdateExpression _ _ ->\n            False\n\n        -- IMPOSSIBLE --\n        Expression.Operator _ ->\n            False\n\n\n{-| Take one argument and return a value that matches a given parser.\n-}\nconstructs :\n    (Node Expression -> Match specific)\n    -> ModuleNameLookupTable\n    -> Node Expression\n    -> Match specific\nconstructs getSpecific lookupTable expressionNode =\n    case AstHelpers.getSpecificFunctionCall ( [ \"Basics\" ], \"always\" ) lookupTable expressionNode of\n        Just alwaysCall ->\n            getSpecific alwaysCall.firstArg\n\n        Nothing ->\n            case Node.value (AstHelpers.removeParens expressionNode) of\n                Expression.LambdaExpression lambda ->\n                    case lambda.args of\n                        _ :: [] ->\n                            getSpecific lambda.expression\n\n                        _ ->\n                            Undetermined\n\n                _ ->\n                    Undetermined\n\n\nsameInAllBranches :\n    (Node Expression -> Maybe info)\n    -> Node Expression\n    -> Match (List info)\nsameInAllBranches getSpecific baseExpressionNode =\n    case getSpecific baseExpressionNode of\n        Just specific ->\n            Determined [ specific ]\n\n        Nothing ->\n            case Node.value (AstHelpers.removeParens baseExpressionNode) of\n                Expression.LetExpression letIn ->\n                    sameInAllBranches getSpecific letIn.expression\n\n                Expression.IfBlock _ thenBranch elseBranch ->\n                    Match.traverse\n                        (\\branchExpression -> sameInAllBranches getSpecific branchExpression)\n                        [ thenBranch, elseBranch ]\n                        |> Match.map List.concat\n\n                Expression.CaseExpression caseOf ->\n                    Match.traverse\n                        (\\( _, caseExpression ) -> sameInAllBranches getSpecific caseExpression)\n                        caseOf.cases\n                        |> Match.map List.concat\n\n                _ ->\n                    Undetermined\n\n\ngetComparableExpressionInTupleFirst : Node Expression -> Maybe (List Expression)\ngetComparableExpressionInTupleFirst expressionNode =\n    case AstHelpers.getTuple2Literal expressionNode of\n        Just tuple ->\n            getComparableExpression tuple.first\n\n        Nothing ->\n            Nothing\n\n\ngetComparableExpression : Node Expression -> Maybe (List Expression)\ngetComparableExpression =\n    getComparableExpressionHelper 1\n\n\ngetComparableExpressionHelper : Int -> Node Expression -> Maybe (List Expression)\ngetComparableExpressionHelper sign (Node _ expression) =\n    case expression of\n        Expression.Integer int ->\n            Just [ Expression.Integer (sign * int) ]\n\n        Expression.Hex hex ->\n            Just [ Expression.Integer (sign * hex) ]\n\n        Expression.Floatable float ->\n            Just [ Expression.Floatable (toFloat sign * float) ]\n\n        Expression.Negation expr ->\n            getComparableExpressionHelper (-1 * sign) expr\n\n        Expression.Literal string ->\n            Just [ Expression.Literal string ]\n\n        Expression.CharLiteral char ->\n            Just [ Expression.CharLiteral char ]\n\n        Expression.ParenthesizedExpression expr ->\n            getComparableExpressionHelper 1 expr\n\n        Expression.TupledExpression exprs ->\n            exprs\n                |> traverse (getComparableExpressionHelper 1)\n                |> Maybe.map List.concat\n\n        Expression.ListExpr exprs ->\n            exprs\n                |> traverse (getComparableExpressionHelper 1)\n                |> Maybe.map List.concat\n\n        _ ->\n            Nothing\n\n\n\n-- LIST HELPERS\n\n\nlistLast : List a -> Maybe a\nlistLast list =\n    case list of\n        [] ->\n            Nothing\n\n        head :: tail ->\n            Just (listFilledLast ( head, tail ))\n\n\nlistFilledLast : ( a, List a ) -> a\nlistFilledLast ( head, tail ) =\n    case tail of\n        [] ->\n            head\n\n        tailHead :: tailTail ->\n            listFilledLast ( tailHead, tailTail )\n\n\nfindMap : (a -> Maybe b) -> List a -> Maybe b\nfindMap mapper nodes =\n    case nodes of\n        [] ->\n            Nothing\n\n        node :: rest ->\n            case mapper node of\n                Just value ->\n                    Just value\n\n                Nothing ->\n                    findMap mapper rest\n\n\nfirstThatConstructsJust : List (a -> Maybe b) -> a -> Maybe b\nfirstThatConstructsJust remainingChecks data =\n    findMap (\\checkFn -> checkFn data) remainingChecks\n\n\nfindMapNeighboringAfter : Maybe a -> (a -> Maybe b) -> List a -> Maybe { before : Maybe a, found : b, after : Maybe a }\nfindMapNeighboringAfter before tryMap list =\n    case list of\n        [] ->\n            Nothing\n\n        now :: after ->\n            case tryMap now of\n                Just found ->\n                    Just { before = before, found = found, after = after |> List.head }\n\n                Nothing ->\n                    findMapNeighboringAfter (Just now) tryMap after\n\n\nfindMapNeighboring : (a -> Maybe b) -> List a -> Maybe { before : Maybe a, found : b, after : Maybe a }\nfindMapNeighboring tryMap list =\n    findMapNeighboringAfter Nothing tryMap list\n\n\nfindMapAndAllBefore : (a -> Maybe b) -> List a -> Maybe { before : List a, found : b }\nfindMapAndAllBefore tryMap list =\n    foldUntilOkFrom []\n        (\\el beforeReversed ->\n            case tryMap el of\n                Nothing ->\n                    Err (el :: beforeReversed)\n\n                Just found ->\n                    Ok\n                        { found = found\n                        , before = List.reverse beforeReversed\n                        }\n        )\n        list\n        |> Result.toMaybe\n\n\n{-| A fold that can stop early (\u2192 `Ok`) instead of traversing the whole list.\n\n    [ 4, 8, -1, 2 ]\n        -- take from the right while not negative\n        |> foldUntilOkFrom []\n            (\\n beforeReversed ->\n                if n < 0 then\n                    Ok (List.reverse beforeReversed) -- stop the fold\n                else\n                    Err (n :: beforeReversed)\n            )\n        |> Result.map\n    --> [ 4, 8 ]\n\n-}\nfoldUntilOkFrom : folded -> (a -> folded -> Result folded b) -> List a -> Result folded b\nfoldUntilOkFrom initialFolded mapOrFoldFurther list =\n    case list of\n        [] ->\n            Err initialFolded\n\n        head :: tail ->\n            case mapOrFoldFurther head initialFolded of\n                Ok found ->\n                    Ok found\n\n                Err newFolded ->\n                    foldUntilOkFrom newFolded mapOrFoldFurther tail\n\n\ntraverse : (a -> Maybe b) -> List a -> Maybe (List b)\ntraverse f list =\n    traverseHelp f list []\n\n\ntraverseHelp : (a -> Maybe b) -> List a -> List b -> Maybe (List b)\ntraverseHelp f list acc =\n    case list of\n        head :: tail ->\n            case f head of\n                Just a ->\n                    traverseHelp f tail (a :: acc)\n\n                Nothing ->\n                    Nothing\n\n        [] ->\n            Just (List.reverse acc)\n\n\nunique : List a -> List a\nunique list =\n    uniqueHelp [] list []\n\n\nuniqueHelp : List a -> List a -> List a -> List a\nuniqueHelp existing remaining accumulator =\n    case remaining of\n        [] ->\n            List.reverse accumulator\n\n        first :: rest ->\n            if List.member first existing then\n                uniqueHelp existing rest accumulator\n\n            else\n                uniqueHelp (first :: existing) rest (first :: accumulator)\n\n\n\n-- MAYBE HELPERS\n\n\nisJust : Maybe a -> Bool\nisJust maybe =\n    case maybe of\n        Just _ ->\n            True\n\n        Nothing ->\n            False\n\n\nisNothing : Maybe a -> Bool\nisNothing maybe =\n    case maybe of\n        Nothing ->\n            True\n\n        Just _ ->\n            False\n\n\nmaybeToList : Maybe a -> List a\nmaybeToList maybe =\n    case maybe of\n        Nothing ->\n            []\n\n        Just content ->\n            [ content ]\n\n";
    var $author$project$Main$operation = $elm_explorations$benchmark$Benchmark$LowLevel$operation(function (_v0) {
        return $author$project$Elm$Parser$parseToFile($author$project$Main$sampleFile);
    });
    var $elm_explorations$benchmark$Benchmark$LowLevel$sample_fn = function (n, operation_) {
        return _Benchmark_sample_fn(n, operation_);
    }, $elm_explorations$benchmark$Benchmark$LowLevel$sample = F2($elm_explorations$benchmark$Benchmark$LowLevel$sample_fn);
    var $author$project$Main$sampleSize = 100;
    var $author$project$Main$run = $elm$core$Task$attempt_fn($elm$core$Basics$identity, $elm_explorations$benchmark$Benchmark$LowLevel$sample_fn($author$project$Main$sampleSize, $author$project$Main$operation));
    var $elm$core$Platform$Cmd$batch = _Platform_batch;
    var $elm$core$Platform$Cmd$none = $elm$core$Platform$Cmd$batch(_List_Nil);
    var $author$project$Main$update_fn = function (msg, _v0) {
        if (!msg.$) {
            var time = msg.a;
            return _Utils_Tuple2(time, $elm$core$Platform$Cmd$none);
        }
        else {
            return _Utils_Tuple2(0, $elm$core$Platform$Cmd$none);
        }
    }, $author$project$Main$update = F2($author$project$Main$update_fn);
    var $elm$core$String$fromFloat = _String_fromNumber;
    var $elm$virtual_dom$VirtualDom$text = _VirtualDom_text;
    var $elm$html$Html$text = $elm$virtual_dom$VirtualDom$text;
    var $author$project$Main$view = function (time) {
        return $elm$html$Html$text($elm$core$String$fromFloat(time) + (" ms to do " + ($elm$core$String$fromInt($author$project$Main$sampleSize) + (" runs => " + ($elm$core$String$fromFloat(time / $author$project$Main$sampleSize) + " ms/run")))));
    };
    var $author$project$Main$main = $elm$browser$Browser$element({
        et: function (_v0) {
            return _Utils_Tuple2(-1, $author$project$Main$run);
        },
        fd: $elm$core$Basics$always($elm$core$Platform$Sub$none),
        fx: $author$project$Main$update,
        fy: $author$project$Main$view
    });
    _Platform_export({ "Main": { "init": $author$project$Main$main($elm$json$Json$Decode$succeed(0))(0) } });
}(this));
